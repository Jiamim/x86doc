C6.6.1         ADC

                       Add with carry: Rd = Rn + Rm + C




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9             5 4              0
                           sf 0 0 1 1 0 1 0 0 0 0                  Rm         0 0 0 0 0 0              Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       ADC <Wd>, <Wn>, <Wm>


                       64-bit variant

                       Applies when sf = 1.

                       ADC <Xd>, <Xn>, <Xm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bits(4) nzcv;

                         if sub_op then
                              operand2 = NOT(operand2);

                         (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);

                         if setflags then
                              PSTATE.<N,Z,C,V> = nzcv;

                         X[d] = result;




C6-400                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                  ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.2      ADCS

                Add with carry, setting the condition flags: Rd = Rn + Rm + C




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9              5 4              0
                  sf 0 1 1 1 0 1 0 0 0 0                   Rm         0 0 0 0 0 0              Rn              Rd
                     op S


                32-bit variant

                Applies when sf = 0.

                ADCS <Wd>, <Wn>, <Wm>


                64-bit variant

                Applies when sf = 1.

                ADCS <Xd>, <Xn>, <Xm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');


                Assembler symbols

                <Wd>           Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>           Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>           Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>           Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>           Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>           Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];
                 bits(4) nzcv;

                 if sub_op then
                     operand2 = NOT(operand2);

                 (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);

                 if setflags then
                     PSTATE.<N,Z,C,V> = nzcv;

                 X[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-401
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.3         ADD (extended register)

                       Add (extended register): Rd = Rn + LSL(extend(Rm), amount)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12      10 9            5 4            0
                           sf 0 0 0 1 0 1 1 0 0 1                  Rm          option    imm3           Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       ADD <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}


                       64-bit variant

                       Applies when sf = 1.

                       ADD <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = UInt(imm3);
                         if shift > 4 then ReservedValue();


                       Assembler symbols

                       <Wd|WSP>        Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Wn|WSP>        Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                       field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd|SP>         Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Xn|SP>         Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                       field.

                       <R>             Is a width specifier, encoded in the "option" field. It can have the following values:

                                       W           when option = 00x

                                       W           when option = 010

                                       X           when option = x11

                                       W           when option = 10x

                                       W           when option = 110

                       <m>             Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
                                       the "Rm" field.




C6-402                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



                <extend>      For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
                              "option" field. It can have the following values:

                              UXTB         when option = 000

                              UXTH         when option = 001

                              LSL|UXTW     when option = 010

                              UXTX         when option = 011

                              SXTB         when option = 100

                              SXTH         when option = 101

                              SXTW         when option = 110

                              SXTX         when option = 111

                              If "Rd" or "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted
                              when "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is
                              '010'.

                              For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
                              "option" field. It can have the following values:

                              UXTB         when option = 000

                              UXTH         when option = 001

                              UXTW         when option = 010

                              LSL|UXTX     when option = 011

                              SXTB         when option = 100

                              SXTH         when option = 101

                              SXTW         when option = 110

                              SXTX         when option = 111

                              If "Rd" or "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when
                              "imm3" is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.

                <amount>      Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
                              the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
                              and is optional when <extend> is present but not LSL.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                 bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
                 bits(4) nzcv;
                 bit carry_in;

                 if sub_op then
                     operand2 = NOT(operand2);
                     carry_in = '1';
                 else
                     carry_in = '0';

                 (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                 if setflags then
                     PSTATE.<N,Z,C,V> = nzcv;

                 if d == 31 && !setflags then
                     SP[] = result;
                 else
                     X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-403
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.4         ADD (immediate)

                       Add (immediate): Rd = Rn + shift(imm)

                       This instruction is used by the alias MOV (to/from SP). See the Alias conditions table for details of when each alias
                       is preferred.




                           31 30 29 28 27 26 25 24 23 22 21                                 10 9              5 4              0
                           sf 0 0 1 0 0 0 1 shift                        imm12                         Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       ADD <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}


                       64-bit variant

                       Applies when sf = 1.

                       ADD <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');
                         bits(datasize) imm;

                         case shift of
                              when '00' imm = ZeroExtend(imm12, datasize);
                              when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);
                              when '1x' ReservedValue();


                       Alias conditions


                                            Alias                    is preferred when

                                            MOV (to/from SP)         shift == '00' && imm12 == '000000000000' &&
                                                                     (Rd == '11111' || Rn == '11111')



                       Assembler symbols

                       <Wd|WSP>        Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Wn|WSP>        Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                       <Xd|SP>         Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Xn|SP>         Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                       <imm>           Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.




C6-404                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                <shift>       Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "shift"
                              field. It can have the following values:

                              LSL #0       when shift = 00

                              LSL #12      when shift = 01

                              It is RESERVED when shift = 1x.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                 bits(datasize) operand2 = imm;
                 bits(4) nzcv;
                 bit carry_in;

                 if sub_op then
                     operand2 = NOT(operand2);
                     carry_in = '1';
                 else
                     carry_in = '0';

                 (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                 if setflags then
                     PSTATE.<N,Z,C,V> = nzcv;

                 if d == 31 && !setflags then
                     SP[] = result;
                 else
                     X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-405
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.5         ADD (shifted register)

                       Add (shifted register): Rd = Rn + shift(Rm, amount)




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15              10 9            5 4             0
                           sf 0 0 0 1 0 1 1 shift 0                  Rm               imm6              Rn               Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       ADD <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                       64-bit variant

                       Applies when sf = 1.

                       ADD <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');

                         if shift == '11' then ReservedValue();
                         if sf == '0' && imm6<5> == '1' then ReservedValue();

                         ShiftType shift_type = DecodeShift(shift);
                         integer shift_amount = UInt(imm6);


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                       in the "shift" field. It can have the following values:

                                       LSL          when shift = 00

                                       LSR          when shift = 01

                                       ASR          when shift = 10

                                       It is RESERVED when shift = 11.

                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.




C6-406                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                              For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                              "imm6" field.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
                 bits(4) nzcv;
                 bit carry_in;

                 if sub_op then
                     operand2 = NOT(operand2);
                     carry_in = '1';
                 else
                     carry_in = '0';

                 (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                 if setflags then
                     PSTATE.<N,Z,C,V> = nzcv;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-407
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.6         ADDS (extended register)

                       Add (extended register), setting the condition flags: Rd = Rn + LSL(extend(Rm), amount)

                       This instruction is used by the alias CMN (extended register). See the Alias conditions table for details of when each
                       alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15     13 12      10 9            5 4             0
                           sf 0 1 0 1 0 1 1 0 0 1                   Rm          option    imm3           Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       ADDS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}


                       64-bit variant

                       Applies when sf = 1.

                       ADDS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = UInt(imm3);
                         if shift > 4 then ReservedValue();


                       Alias conditions


                                             Alias                     is preferred when

                                             CMN (extended             Rd == '11111'
                                             register)


                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn|WSP>         Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                        field.

                       <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn|SP>          Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                        field.

                       <R>              Is a width specifier, encoded in the "option" field. It can have the following values:

                                        W           when option = 00x



C6-408                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



                              W            when option = 010

                              X            when option = x11

                              W            when option = 10x

                              W            when option = 110

                <m>           Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
                              the "Rm" field.

                <extend>      For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
                              "option" field. It can have the following values:

                              UXTB         when option = 000

                              UXTH         when option = 001

                              LSL|UXTW     when option = 010

                              UXTX         when option = 011

                              SXTB         when option = 100

                              SXTH         when option = 101

                              SXTW         when option = 110

                              SXTX         when option = 111

                              If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
                              "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.

                              For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
                              "option" field. It can have the following values:

                              UXTB         when option = 000

                              UXTH         when option = 001

                              UXTW         when option = 010

                              LSL|UXTX     when option = 011

                              SXTB         when option = 100

                              SXTH         when option = 101

                              SXTW         when option = 110

                              SXTX         when option = 111

                              If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
                              is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.

                <amount>      Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
                              the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
                              and is optional when <extend> is present but not LSL.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                 bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
                 bits(4) nzcv;
                 bit carry_in;

                 if sub_op then
                     operand2 = NOT(operand2);
                     carry_in = '1';
                 else
                     carry_in = '0';

                 (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                 if setflags then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-409
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                              PSTATE.<N,Z,C,V> = nzcv;

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-410                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                        Non-Confidential - Beta                           ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.7      ADDS (immediate)

                Add (immediate), setting the condition flags: Rd = Rn + shift(imm)

                This instruction is used by the alias CMN (immediate). See the Alias conditions table for details of when each alias
                is preferred.




                  31 30 29 28 27 26 25 24 23 22 21                                     10 9             5 4              0
                   sf 0 1 1 0 0 0 1 shift                           imm12                        Rn             Rd
                     op S


                32-bit variant

                Applies when sf = 0.

                ADDS <Wd>, <Wn|WSP>, #<imm>{, <shift>}


                64-bit variant

                Applies when sf = 1.

                ADDS <Xd>, <Xn|SP>, #<imm>{, <shift>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');
                 bits(datasize) imm;

                 case shift of
                     when '00' imm = ZeroExtend(imm12, datasize);
                     when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);
                     when '1x' ReservedValue();


                Alias conditions


                                     Alias                      is preferred when

                                     CMN (immediate)            Rd == '11111'



                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn|WSP>        Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn|SP>         Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <imm>           Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

                <shift>         Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "shift"
                                field. It can have the following values:

                                LSL #0       when shift = 00




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-411
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                       LSL #12    when shift = 01

                                       It is RESERVED when shift = 1x.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                         bits(datasize) operand2 = imm;
                         bits(4) nzcv;
                         bit carry_in;

                         if sub_op then
                              operand2 = NOT(operand2);
                              carry_in = '1';
                         else
                              carry_in = '0';

                         (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                         if setflags then
                              PSTATE.<N,Z,C,V> = nzcv;

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-412                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                        Non-Confidential - Beta                           ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.8      ADDS (shifted register)

                Add (shifted register), setting the condition flags: Rd = Rn + shift(Rm, amount)

                This instruction is used by the alias CMN (shifted register). See the Alias conditions table for details of when each
                alias is preferred.




                  31 30 29 28 27 26 25 24 23 22 21 20               16 15             10 9              5 4              0
                   sf 0 1 0 1 0 1 1 shift 0                  Rm              imm6                Rn              Rd
                      op S


                32-bit variant

                Applies when sf = 0.

                ADDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                ADDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');

                 if shift == '11' then ReservedValue();
                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);


                Alias conditions


                                      Alias                     is preferred when

                                      CMN (shifted              Rd == '11111'
                                      register)


                Assembler symbols

                <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-413
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                       in the "shift" field. It can have the following values:

                                       LSL          when shift = 00

                                       LSR          when shift = 01

                                       ASR          when shift = 10

                                       It is RESERVED when shift = 11.

                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
                         bits(4) nzcv;
                         bit carry_in;

                         if sub_op then
                              operand2 = NOT(operand2);
                              carry_in = '1';
                         else
                              carry_in = '0';

                         (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                         if setflags then
                              PSTATE.<N,Z,C,V> = nzcv;

                         X[d] = result;




C6-414                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.9      ADR

                Address of label at a PC-relative offset




                  31 30 29 28 27 26 25 24 23                                                           5 4              0
                  0 immlo 1 0 0 0 0                                   immhi                                     Rd
                  op


                Literal variant

                ADR <Xd>, <label>


                Decode for this encoding

                 integer d = UInt(Rd);
                 boolean page = (op == '1');
                 bits(64) imm;

                 if page then
                     imm = SignExtend(immhi:immlo:Zeros(12), 64);
                 else
                     imm = SignExtend(immhi:immlo, 64);


                Assembler symbols

                <Xd>           Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <label>        Is the program label whose address is to be calculated. Its offset from the address of this instruction,
                               in the range +/-1MB, is encoded in "immhi:immlo".


                Operation

                 bits(64) base = PC[];

                 if page then
                     base<11:0> = Zeros(12);

                 X[d] = base + imm;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-415
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.10        ADRP

                       Address of 4KB page at a PC-relative offset




                           31 30 29 28 27 26 25 24 23                                                        5 4             0
                           1 immlo 1 0 0 0 0                                   immhi                                  Rd
                           op


                       Literal variant

                       ADRP <Xd>, <label>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         boolean page = (op == '1');
                         bits(64) imm;

                         if page then
                              imm = SignExtend(immhi:immlo:Zeros(12), 64);
                         else
                              imm = SignExtend(immhi:immlo, 64);


                       Assembler symbols

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <label>         Is the program label whose 4KB page address is to be calculated. Its offset from the page address of
                                       this instruction, in the range +/-4GB, is encoded as "immhi:immlo" times 4096.


                       Operation

                         bits(64) base = PC[];

                         if page then
                              base<11:0> = Zeros(12);

                         X[d] = base + imm;




C6-416                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.11     AND (immediate)

                Bitwise AND (immediate): Rd = Rn AND imm




                  31 30 29 28 27 26 25 24 23 22 21               16 15             10 9             5 4              0
                  sf 0 0 1 0 0 1 0 0 N                 immr               imms               Rn               Rd
                     opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                AND <Wd|WSP>, <Wn>, #<imm>


                64-bit variant

                Applies when sf = 1.

                AND <Xd|SP>, <Xn>, #<imm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 bits(datasize) imm;
                 if sf == '0' && N != '0' then ReservedValue();
                 (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);


                Assembler symbols

                <Wd|WSP>      Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                              field.

                <Wn>          Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd|SP>       Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                              field.

                <Xn>          Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <imm>         Is the bitmask immediate, encoded in "N:imms:immr".


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = imm;

                 case op of
                     when LogicalOp_AND result = operand1 AND operand2;
                     when LogicalOp_ORR result = operand1 OR     operand2;
                     when LogicalOp_EOR result = operand1 EOR operand2;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-417
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions




                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-418                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                        Non-Confidential - Beta                           ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.12     AND (shifted register)

                Bitwise AND (shifted register): Rd = Rn AND shift(Rm, amount)




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15               10 9             5 4             0
                  sf 0 0 0 1 0 1 0 shift 0                 Rm               imm6                Rn            Rd
                     opc                          N


                32-bit variant

                Applies when sf = 0.

                AND <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                AND <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);
                 boolean invert = (N == '1');


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>          Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>          Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>          Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>          Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>       Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                              field. It can have the following values:

                              LSL          when shift = 00

                              LSR          when shift = 01

                              ASR          when shift = 10

                              ROR          when shift = 11


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-419
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR       operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         X[d] = result;




C6-420                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.13     ANDS (immediate)

                Bitwise AND (immediate), setting the condition flags: Rd = Rn AND imm

                This instruction is used by the alias TST (immediate). See the Alias conditions table for details of when each alias
                is preferred.




                  31 30 29 28 27 26 25 24 23 22 21                16 15              10 9             5 4              0
                   sf 1 1 1 0 0 1 0 0 N                  immr              imms                Rn              Rd
                       opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                ANDS <Wd>, <Wn>, #<imm>


                64-bit variant

                Applies when sf = 1.

                ANDS <Xd>, <Xn>, #<imm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 bits(datasize) imm;
                 if sf == '0' && N != '0' then ReservedValue();
                 (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);


                Alias conditions


                                     Alias                   is preferred when

                                     TST (immediate)         Rd == '11111'



                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <imm>           Is the bitmask immediate, encoded in "N:imms:immr".




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-421
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = imm;

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR  operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-422                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                        Non-Confidential - Beta                           ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.14     ANDS (shifted register)

                Bitwise AND (shifted register), setting the condition flags: Rd = Rn AND shift(Rm, amount)

                This instruction is used by the alias TST (shifted register). See the Alias conditions table for details of when each
                alias is preferred.




                  31 30 29 28 27 26 25 24 23 22 21 20               16 15              10 9             5 4              0
                   sf 1 1 0 1 0 1 0 shift 0                  Rm               imm6               Rn              Rd
                       opc                         N


                32-bit variant

                Applies when sf = 0.

                ANDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                ANDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                      when '00' op = LogicalOp_AND; setflags = FALSE;
                      when '01' op = LogicalOp_ORR; setflags = FALSE;
                      when '10' op = LogicalOp_EOR; setflags = FALSE;
                      when '11' op = LogicalOp_AND; setflags = TRUE;

                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);
                 boolean invert = (N == '1');


                Alias conditions


                                      Alias                     is preferred when

                                      TST (shifted              Rd == '11111'
                                      register)


                Assembler symbols

                <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.



ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-423
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <shift>         Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                                       field. It can have the following values:

                                       LSL          when shift = 00

                                       LSR          when shift = 01

                                       ASR          when shift = 10

                                       ROR          when shift = 11

                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR       operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         X[d] = result;




C6-424                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.15     ASR (register)

                Arithmetic shift right (register): Rd = ASR(Rn, Rm)

                This instruction is an alias of the ASRV instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ASRV.

                ·      The description of ASRV gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9              5 4              0
                   sf 0 0 1 1 0 1 0 1 1 0                   Rm         0 0 1 0 1 0              Rn              Rd
                                                                                   op2


                32-bit variant

                Applies when sf = 0.

                ASR <Wd>, <Wn>, <Wm>

                is equivalent to

                ASRV <Wd>, <Wn>, <Wm>

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                ASR <Xd>, <Xn>, <Xm>

                is equivalent to

                ASRV <Xd>, <Xn>, <Xm>

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                31 in its bottom 5 bits, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                63 in its bottom 6 bits, encoded in the "Rm" field.


                Operation

                The description of ASRV gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-425
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.16        ASR (immediate)

                       Arithmetic shift right (immediate): Rd = ASR(Rn, shift)

                       This instruction is an alias of the SBFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SBFM.

                       ·       The description of SBFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21                 16 15             10 9             5 4            0
                           sf 0 0 1 0 0 1 1 0 N                  immr          x 1 1 1 1 1              Rn              Rd
                               opc                                                   imms


                       32-bit variant

                       Applies when sf = 0 && N = 0 && imms = 011111.

                       ASR <Wd>, <Wn>, #<shift>

                       is equivalent to

                       SBFM <Wd>, <Wn>, #<shift>, #31

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1 && N = 1 && imms = 111111.

                       ASR <Xd>, <Xn>, #<shift>

                       is equivalent to

                       SBFM <Xd>, <Xn>, #<shift>, #63

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <shift>         For the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the "immr" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the "immr" field.


                       Operation

                       The description of SBFM gives the operational pseudocode for this instruction.




C6-426                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.17     ASRV

                Arithmetic shift right variable : Rd = ASR(Rn, Rm)

                This instruction is used by the alias ASR (register). The alias is always the preferred disassembly.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9              5 4              0
                  sf 0 0 1 1 0 1 0 1 1 0                    Rm         0 0 1 0 1 0              Rn              Rd
                                                                                     op2


                32-bit variant

                Applies when sf = 0.

                ASRV <Wd>, <Wn>, <Wm>


                64-bit variant

                Applies when sf = 1.

                ASRV <Xd>, <Xn>, <Xm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 ShiftType shift_type = DecodeShift(op2);


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                31 in its bottom 5 bits, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                63 in its bottom 6 bits, encoded in the "Rm" field.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand2 = X[m];

                 result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
                 X[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-427
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.18        AT

                       Address translate

                       This instruction is an alias of the SYS instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SYS.

                       ·       The description of SYS gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15       12 11        8 7      5 4             0
                           1 1 0 1 0 1 0 1 0 0 0 0 1                  op1     0 1 1 1 1 0 0 0           op2           Rt
                                                           L                     CRn         CRm


                       System variant

                       AT <at_op>, <Xt>

                       is equivalent to

                       SYS #<op1>, C7, C8, #<op2>, <Xt>

                       and is the preferred disassembly when SysOp(op1,'0111','1000',op2) == Sys_AT.


                       Assembler symbols

                       <at_op>         Is an AT operation name, as listed for the AT system operation group, encoded in the "op1:op2"
                                       field. It can have the following values:

                                       S1E1R        when op1 = 000, op2 = 000

                                       S1E1W        when op1 = 000, op2 = 001

                                       S1E0R        when op1 = 000, op2 = 010

                                       S1E0W        when op1 = 000, op2 = 011

                                       S1E2R        when op1 = 100, op2 = 000

                                       S1E2W        when op1 = 100, op2 = 001

                                       S12E1R       when op1 = 100, op2 = 100

                                       S12E1W       when op1 = 100, op2 = 101

                                       S12E0R       when op1 = 100, op2 = 110

                                       S12E0W       when op1 = 100, op2 = 111

                                       S1E3R        when op1 = 110, op2 = 000

                                       S1E3W        when op1 = 110, op2 = 001

                       <op1>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

                       <op2>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

                       <Xt>            Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.


                       Operation

                       The description of SYS gives the operational pseudocode for this instruction.




C6-428                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.19     B.cond

                Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.




                  31 30 29 28 27 26 25 24 23                                                              5 4 3            0
                  0 1 0 1 0 1 0 0                                      imm19                                 0     cond




                19-bit signed PC-relative branch offset variant

                B.<cond> <label>


                Decode for this encoding

                 bits(64) offset = SignExtend(imm19:'00', 64);
                 bits(4) condition = cond;


                Assembler symbols

                <cond>        Is one of the standard conditions, encoded in the "cond" field in the standard way.

                <label>       Is the program label to be conditionally branched to. Its offset from the address of this instruction,
                              in the range +/-1MB, is encoded as "imm19" times 4.


                Operation

                 if ConditionHolds(condition) then
                     BranchTo(PC[] + offset, BranchType_JMP);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                          C6-429
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.20        B

                       Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call
                       or return.




                           31 30 29 28 27 26 25                                                                                  0
                           0 0 0 1 0 1                                            imm26
                           op


                       26-bit signed PC-relative branch offset variant

                       B <label>


                       Decode for this encoding

                         BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;
                         bits(64) offset = SignExtend(imm26:'00', 64);


                       Assembler symbols

                       <label>         Is the program label to be unconditionally branched to. Its offset from the address of this instruction,
                                       in the range +/-128MB, is encoded as "imm26" times 4.


                       Operation

                         if branch_type == BranchType_CALL then X[30] = PC[] + 4;

                         BranchTo(PC[] + offset, branch_type);




C6-430                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                     ID121714

                                                                                                    C6 A64 Base Instruction Descriptions
                                                                                                     C6.6 Alphabetical list of instructions



C6.6.21     BFI

                Bitfield insert, leaving other bits unchanged

                This instruction is an alias of the BFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of BFM.

                ·      The description of BFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                    16 15                10 9            5 4               0
                   sf 0 1 1 0 0 1 1 0 N                     immr                imms                Rn               Rd
                      opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                BFI <Wd>, <Wn>, #<lsb>, #<width>

                is equivalent to

                BFM  <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)

                and is the preferred disassembly when UInt(imms) < UInt(immr).

                64-bit variant

                Applies when sf = 1 && N = 1.

                BFI <Xd>, <Xn>, #<lsb>, #<width>

                is equivalent to

                BFM  <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)

                and is the preferred disassembly when UInt(imms) < UInt(immr).


                Assembler symbols

                <Wd>              Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>              Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>              Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>              Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <lsb>             For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

                                  For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

                <width>           For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

                                  For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.


                Operation

                The description of BFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-431
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.22        BFM

                       Bitfield move, leaving other bits unchanged

                       This instruction is used by the aliases BFI and BFXIL. See the Alias conditions on page C6-433 table for details of
                       when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21              16 15              10 9            5 4            0
                           sf 0 1 1 0 0 1 1 0 N                 immr               imms              Rn            Rd
                               opc


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       BFM <Wd>, <Wn>, #<immr>, #<imms>


                       64-bit variant

                       Applies when sf = 1 && N = 1.

                       BFM <Xd>, <Xn>, #<immr>, #<imms>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer datasize = if sf == '1' then 64 else 32;

                         boolean inzero;
                         boolean extend;
                         integer R;
                         integer S;
                         bits(datasize) wmask;
                         bits(datasize) tmask;

                         case opc of
                              when '00' inzero = TRUE;    extend = TRUE;      // SBFM
                              when '01' inzero = FALSE; extend = FALSE;       // BFM
                              when '10' inzero = TRUE;    extend = FALSE;     // UBFM
                              when '11' UnallocatedEncoding();

                         if sf == '1' && N != '1' then ReservedValue();
                         if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();

                         R = UInt(immr);
                         S = UInt(imms);
                         (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);




C6-432                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                              ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                Alias conditions


                                   Alias                      is preferred when

                                   BFI                        UInt(imms) < UInt(immr)

                                   BFXIL                      UInt(imms) >= UInt(immr)



                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>          Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>          Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <immr>        For the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the "immr" field.

                              For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the "immr" field.

                <imms>        For the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31,
                              encoded in the "imms" field.

                              For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63,
                              encoded in the "imms" field.


                Operation

                 bits(datasize) dst = if inzero then Zeros() else X[d];
                 bits(datasize) src = X[n];

                 // perform bitfield move on low bits
                 bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);

                 // determine extension bits (sign, zero or dest register)
                 bits(datasize) top = if extend then Replicate(src<S>) else dst;

                 // combine extension bits and result bits
                 X[d] = (top AND NOT(tmask)) OR (bot AND tmask);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-433
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.23        BFXIL

                       Bitfield extract and insert at low end, leaving other bits unchanged

                       This instruction is an alias of the BFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of BFM.

                       ·       The description of BFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21                 16 15                10 9            5 4              0
                           sf 0 1 1 0 0 1 1 0 N                   immr                imms                Rn              Rd
                               opc


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       BFXIL <Wd>, <Wn>, #<lsb>, #<width>

                       is equivalent to

                       BFM    <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)

                       and is the preferred disassembly when UInt(imms) >= UInt(immr).

                       64-bit variant

                       Applies when sf = 1 && N = 1.

                       BFXIL <Xd>, <Xn>, #<lsb>, #<width>

                       is equivalent to

                       BFM    <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)

                       and is the preferred disassembly when UInt(imms) >= UInt(immr).


                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>             Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>             Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <lsb>            For the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.

                                        For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.

                       <width>          For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

                                        For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.


                       Operation

                       The description of BFM gives the operational pseudocode for this instruction.




C6-434                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                    ID121714

                                                                                                   C6 A64 Base Instruction Descriptions
                                                                                                    C6.6 Alphabetical list of instructions



C6.6.24     BIC (shifted register)

                 Bitwise bit clear (shifted register): Rd = Rn AND NOT shift(Rm, amount)




                   31 30 29 28 27 26 25 24 23 22 21 20               16 15               10 9             5 4             0
                   sf 0 0 0 1 0 1 0 shift 1                   Rm               imm6                Rn            Rd
                      opc                            N


                 32-bit variant

                 Applies when sf = 0.

                 BIC <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                 64-bit variant

                 Applies when sf = 1.

                 BIC <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                 Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                  LogicalOp op;
                 case opc of
                      when '00' op = LogicalOp_AND; setflags = FALSE;
                      when '01' op = LogicalOp_ORR; setflags = FALSE;
                      when '10' op = LogicalOp_EOR; setflags = FALSE;
                      when '11' op = LogicalOp_AND; setflags = TRUE;

                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                  ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);
                 boolean invert = (N == '1');


                 Assembler symbols

                 <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                 <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                 <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                 <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                 <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                 <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                 <shift>         Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                                 field. It can have the following values:

                                 LSL          when shift = 00

                                 LSR          when shift = 01

                                 ASR          when shift = 10

                                 ROR          when shift = 11


ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-435
ID121714                                              Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR       operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         X[d] = result;




C6-436                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.25     BICS (shifted register)

                Bitwise bit clear (shifted register), setting the condition flags: Rd = Rn AND NOT shift(Rm, amount)




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15              10 9             5 4             0
                  sf 1 1 0 1 0 1 0 shift 1                    Rm               imm6               Rn            Rd
                     opc                            N


                32-bit variant

                Applies when sf = 0.

                BICS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                BICS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);
                 boolean invert = (N == '1');


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>         Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                                field. It can have the following values:

                                LSL          when shift = 00

                                LSR          when shift = 01

                                ASR          when shift = 10

                                ROR          when shift = 11


ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-437
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR       operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         X[d] = result;




C6-438                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                    C6.6 Alphabetical list of instructions



C6.6.26     BL

                Branch with Link calls a subroutine at a PC-relative offset, setting the register X30 to PC+4. It provides a hint that
                this is not a subroutine call or return.




                  31 30 29 28 27 26 25                                                                                    0
                   1 0 0 1 0 1                                              imm26
                  op


                26-bit signed PC-relative branch offset variant

                BL <label>


                Decode for this encoding

                 BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;
                 bits(64) offset = SignExtend(imm26:'00', 64);


                Assembler symbols

                <label>          Is the program label to be unconditionally branched to. Its offset from the address of this instruction,
                                 in the range +/-128MB, is encoded as "imm26" times 4.


                Operation

                 if branch_type == BranchType_CALL then X[30] = PC[] + 4;

                 BranchTo(PC[] + offset, branch_type);




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-439
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.27        BLR

                       Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4 3 2 1 0
                           1 1 0 1 0 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0                                 Rn         0 0 0 0 0
                                                       op


                       Integer variant

                       BLR <Xn>


                       Decode for this encoding

                         integer n = UInt(Rn);
                         BranchType branch_type;

                         case op of
                              when '00' branch_type = BranchType_JMP;
                              when '01' branch_type = BranchType_CALL;
                              when '10' branch_type = BranchType_RET;
                              otherwise UnallocatedEncoding();


                       Assembler symbols

                       <Xn>            Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
                                       the "Rn" field.


                       Operation

                         bits(64) target = X[n];

                         if branch_type == BranchType_CALL then X[30] = PC[] + 4;
                         BranchTo(target, branch_type);




C6-440                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.28     BR

                Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4 3 2 1 0
                  1 1 0 1 0 1 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0                                   Rn           0 0 0 0 0
                                               op


                Integer variant

                BR <Xn>


                Decode for this encoding

                 integer n = UInt(Rn);
                 BranchType branch_type;

                 case op of
                     when '00' branch_type = BranchType_JMP;
                     when '01' branch_type = BranchType_CALL;
                     when '10' branch_type = BranchType_RET;
                     otherwise UnallocatedEncoding();


                Assembler symbols

                <Xn>          Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
                              the "Rn" field.


                Operation

                 bits(64) target = X[n];

                 if branch_type == BranchType_CALL then X[30] = PC[] + 4;
                 BranchTo(target, branch_type);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                        C6-441
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.29        BRK

                       Self-hosted debug breakpoint




                           31 30 29 28 27 26 25 24 23 22 21 20                                              5 4 3 2 1 0
                           1 1 0 1 0 1 0 0 0 0 1                                 imm16                         0 0 0 0 0




                       System variant

                       BRK #<imm>


                       Decode for this encoding

                         bits(16) comment = imm16;


                       Assembler symbols

                       <imm>           Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.


                       Operation

                         AArch64.SoftwareBreakpoint(comment);




C6-442                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                            ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                    C6.6 Alphabetical list of instructions



C6.6.30     CBNZ

                Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label
                at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return.
                This instruction does not affect the condition flags.




                  31 30 29 28 27 26 25 24 23                                                              5 4             0
                   sf 0 1 1 0 1 0 1                                     imm19                                      Rt
                                          op


                32-bit variant

                Applies when sf = 0.

                CBNZ <Wt>, <label>


                64-bit variant

                Applies when sf = 1.

                CBNZ <Xt>, <label>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean iszero = (op == '0');
                 bits(64) offset = SignExtend(imm19:'00', 64);


                Assembler symbols

                <Wt>            Is the 32-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

                <Xt>            Is the 64-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

                <label>         Is the program label to be conditionally branched to. Its offset from the address of this instruction,
                                in the range +/-1MB, is encoded as "imm19" times 4.


                Operation

                 bits(datasize) operand1 = X[t];

                 if IsZero(operand1) == iszero then
                     BranchTo(PC[] + offset, BranchType_JMP);




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                        C6-443
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.31        CBZ

                       Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a
                       PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This
                       instruction does not affect condition flags.




                           31 30 29 28 27 26 25 24 23                                                           5 4               0
                           sf 0 1 1 0 1 0 0                                   imm19                                       Rt
                                                 op


                       32-bit variant

                       Applies when sf = 0.

                       CBZ <Wt>, <label>


                       64-bit variant

                       Applies when sf = 1.

                       CBZ <Xt>, <label>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean iszero = (op == '0');
                         bits(64) offset = SignExtend(imm19:'00', 64);


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

                       <Xt>            Is the 64-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

                       <label>         Is the program label to be conditionally branched to. Its offset from the address of this instruction,
                                       in the range +/-1MB, is encoded as "imm19" times 4.


                       Operation

                         bits(datasize) operand1 = X[t];

                         if IsZero(operand1) == iszero then
                              BranchTo(PC[] + offset, BranchType_JMP);




C6-444                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                     ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.32     CCMN (immediate)

                Conditional compare negative (immediate), setting condition flags to result of comparison or an immediate value:
                flags = if cond then compare(Rn, #-imm) else #nzcv




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15         12 11 10 9             5 4 3            0
                  sf 0 1 1 1 0 1 0 0 1 0                  imm5           cond     1 0          Rn         0     nzcv
                     op


                32-bit variant

                Applies when sf = 0.

                CCMN <Wn>, #<imm>, #<nzcv>, <cond>


                64-bit variant

                Applies when sf = 1.

                CCMN <Xn>, #<imm>, #<nzcv>, <cond>


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 bits(4) condition = cond;
                 bits(4) flags = nzcv;
                 bits(datasize) imm = ZeroExtend(imm5, datasize);


                Assembler symbols

                <Wn>          Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xn>          Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <imm>         Is a five bit unsigned (positive) immediate encoded in the "imm5" field.

                <nzcv>        Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
                              NZCV condition flags, encoded in the "nzcv" field.

                <cond>        Is one of the standard conditions, encoded in the "cond" field in the standard way.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = imm;
                 bit carry_in = '0';

                 if ConditionHolds(condition) then
                     if sub_op then
                         operand2 = NOT(operand2);
                         carry_in = '1';
                     (-, flags) = AddWithCarry(operand1, operand2, carry_in);
                 PSTATE.<N,Z,C,V> = flags;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-445
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.33        CCMN (register)

                       Conditional compare negative (register), setting condition flags to result of comparison or an immediate value:
                       flags = if cond then compare(Rn, -Rm) else #nzcv




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15         12 11 10 9             5 4 3            0
                           sf 0 1 1 1 0 1 0 0 1 0                     Rm           cond     0 0          Rn         0     nzcv
                              op


                       32-bit variant

                       Applies when sf = 0.

                       CCMN <Wn>, <Wm>, #<nzcv>, <cond>


                       64-bit variant

                       Applies when sf = 1.

                       CCMN <Xn>, <Xm>, #<nzcv>, <cond>


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         bits(4) condition = cond;
                         bits(4) flags = nzcv;


                       Assembler symbols

                       <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <nzcv>           Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
                                        NZCV condition flags, encoded in the "nzcv" field.

                       <cond>           Is one of the standard conditions, encoded in the "cond" field in the standard way.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bit carry_in = '0';

                         if ConditionHolds(condition) then
                              if sub_op then
                                   operand2 = NOT(operand2);
                                   carry_in = '1';
                              (-, flags) = AddWithCarry(operand1, operand2, carry_in);
                         PSTATE.<N,Z,C,V> = flags;




C6-446                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.34     CCMP (immediate)

                Conditional compare (immediate), setting condition flags to result of comparison or an immediate value: flags =
                if cond then compare(Rn, #imm) else #nzcv




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15         12 11 10 9             5 4 3            0
                  sf 1 1 1 1 0 1 0 0 1 0                  imm5           cond     1 0          Rn         0     nzcv
                     op


                32-bit variant

                Applies when sf = 0.

                CCMP <Wn>, #<imm>, #<nzcv>, <cond>


                64-bit variant

                Applies when sf = 1.

                CCMP <Xn>, #<imm>, #<nzcv>, <cond>


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 bits(4) condition = cond;
                 bits(4) flags = nzcv;
                 bits(datasize) imm = ZeroExtend(imm5, datasize);


                Assembler symbols

                <Wn>          Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xn>          Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <imm>         Is a five bit unsigned (positive) immediate encoded in the "imm5" field.

                <nzcv>        Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
                              NZCV condition flags, encoded in the "nzcv" field.

                <cond>        Is one of the standard conditions, encoded in the "cond" field in the standard way.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = imm;
                 bit carry_in = '0';

                 if ConditionHolds(condition) then
                     if sub_op then
                         operand2 = NOT(operand2);
                         carry_in = '1';
                     (-, flags) = AddWithCarry(operand1, operand2, carry_in);
                 PSTATE.<N,Z,C,V> = flags;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-447
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.35        CCMP (register)

                       Conditional compare (register), setting condition flags to result of comparison or an immediate value: flags = if
                       cond then compare(Rn, Rm) else #nzcv




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15         12 11 10 9             5 4 3            0
                           sf 1 1 1 1 0 1 0 0 1 0                     Rm           cond     0 0          Rn         0     nzcv
                              op


                       32-bit variant

                       Applies when sf = 0.

                       CCMP <Wn>, <Wm>, #<nzcv>, <cond>


                       64-bit variant

                       Applies when sf = 1.

                       CCMP <Xn>, <Xm>, #<nzcv>, <cond>


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         bits(4) condition = cond;
                         bits(4) flags = nzcv;


                       Assembler symbols

                       <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <nzcv>           Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
                                        NZCV condition flags, encoded in the "nzcv" field.

                       <cond>           Is one of the standard conditions, encoded in the "cond" field in the standard way.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bit carry_in = '0';

                         if ConditionHolds(condition) then
                              if sub_op then
                                   operand2 = NOT(operand2);
                                   carry_in = '1';
                              (-, flags) = AddWithCarry(operand1, operand2, carry_in);
                         PSTATE.<N,Z,C,V> = flags;




C6-448                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.36     CINC

                Conditional increment: Rd = if cond then Rn+1 else Rn

                This instruction is an alias of the CSINC instruction. This means that:

                ·      The encodings in this description are named to match the encodings of CSINC.

                ·      The description of CSINC gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15      12 11 10 9              5 4              0
                   sf 0 0 1 1 0 1 0 1 0 0                !=11111        !=111x    0 1       !=11111            Rd
                     op                                    Rm            cond        o2        Rn


                32-bit variant

                Applies when sf = 0.

                CINC <Wd>, <Wn>, <cond>

                is equivalent to

                CSINC <Wd>, <Wn>, <Wn>, invert(<cond>)

                and is the preferred disassembly when Rn == Rm.

                64-bit variant

                Applies when sf = 1.

                CINC <Xd>, <Xn>, <cond>

                is equivalent to

                CSINC <Xd>, <Xn>, <Xn>, invert(<cond>)

                and is the preferred disassembly when Rn == Rm.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                <cond>          Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
                                significant bit inverted.


                Operation

                The description of CSINC gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-449
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.37        CINV

                       Conditional invert: Rd = if cond then NOT(Rn) else Rn

                       This instruction is an alias of the CSINV instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of CSINV.

                       ·       The description of CSINV gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20           16 15       12 11 10 9             5 4              0
                           sf 1 0 1 1 0 1 0 1 0 0                !=11111       !=111x    0 0       !=11111            Rd
                              op                                   Rm           cond       o2         Rn


                       32-bit variant

                       Applies when sf = 0.

                       CINV <Wd>, <Wn>, <cond>

                       is equivalent to

                       CSINV <Wd>, <Wn>, <Wn>, invert(<cond>)

                       and is the preferred disassembly when Rn == Rm.

                       64-bit variant

                       Applies when sf = 1.

                       CINV <Xd>, <Xn>, <cond>

                       is equivalent to

                       CSINV <Xd>, <Xn>, <Xn>, invert(<cond>)

                       and is the preferred disassembly when Rn == Rm.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                       <cond>          Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
                                       significant bit inverted.


                       Operation

                       The description of CSINV gives the operational pseudocode for this instruction.




C6-450                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.38     CLREX

                Clear exclusive monitor




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11           8 7 6 5 4 3 2 1 0
                  1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1                           CRm       0 1 0 1 1 1 1 1




                System variant

                CLREX {#<imm>}


                Decode for this encoding

                 // CRm field is ignored


                Assembler symbols

                <imm>          Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the
                               "CRm" field.


                Operation

                 ClearExclusiveLocal(ProcessorID());




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-451
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.39        CLS

                       Count leading sign bits: Rd = CLS(Rn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9              5 4              0
                           sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 1                               Rn              Rd
                                                                                           op


                       32-bit variant

                       Applies when sf = 0.

                       CLS <Wd>, <Wn>


                       64-bit variant

                       Applies when sf = 1.

                       CLS <Xd>, <Xn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer datasize = if sf == '1' then 64 else 32;
                         CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                         integer result;
                         bits(datasize) operand1 = X[n];

                         if opcode == CountOp_CLZ then
                              result = CountLeadingZeroBits(operand1);
                         else
                              result = CountLeadingSignBits(operand1);

                         X[d] = result<datasize-1:0>;




C6-452                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                 ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.40     CLZ

                Count leading zero bits: Rd = CLZ(Rn)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9               5 4              0
                  sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0                               Rn              Rd
                                                                                  op


                32-bit variant

                Applies when sf = 0.

                CLZ <Wd>, <Wn>


                64-bit variant

                Applies when sf = 1.

                CLZ <Xd>, <Xn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>          Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>          Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.


                Operation

                 integer result;
                 bits(datasize) operand1 = X[n];

                 if opcode == CountOp_CLZ then
                     result = CountLeadingZeroBits(operand1);
                 else
                     result = CountLeadingSignBits(operand1);

                 X[d] = result<datasize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-453
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.41        CMN (extended register)

                       Compare negative (extended register), setting the condition flags and discarding the result: Rn + LSL(extend(Rm),
                       amount)

                       This instruction is an alias of the ADDS (extended register) instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of ADDS (extended register).

                       ·       The description of ADDS (extended register) gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12      10 9            5 4            0
                           sf 0 1 0 1 0 1 1 0 0 1                  Rm          option    imm3           Rn        1 1 1 1 1
                              op S                                                                                      Rd


                       32-bit variant

                       Applies when sf = 0.

                       CMN <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

                       is equivalent to

                       ADDS WZR, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       CMN <Xn|SP>, <R><m>{, <extend> {#<amount>}}

                       is equivalent to

                       ADDS XZR, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wn|WSP>        Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                       field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xn|SP>         Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                       field.

                       <R>             Is a width specifier, encoded in the "option" field. It can have the following values:

                                       W            when option = 00x

                                       W            when option = 010

                                       X            when option = x11

                                       W            when option = 10x

                                       W            when option = 110

                       <m>             Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
                                       the "Rm" field.




C6-454                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                <extend>       For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
                               "option" field. It can have the following values:

                               UXTB         when option = 000

                               UXTH         when option = 001

                               LSL|UXTW     when option = 010

                               UXTX         when option = 011

                               SXTB         when option = 100

                               SXTH         when option = 101

                               SXTW         when option = 110

                               SXTX         when option = 111

                               If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
                               "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.

                               For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
                               "option" field. It can have the following values:

                               UXTB         when option = 000

                               UXTH         when option = 001

                               UXTW         when option = 010

                               LSL|UXTX     when option = 011

                               SXTB         when option = 100

                               SXTH         when option = 101

                               SXTW         when option = 110

                               SXTX         when option = 111

                               If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
                               is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.

                <amount>       Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
                               the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
                               and is optional when <extend> is present but not LSL.


                Operation

                The description of ADDS (extended register) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-455
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.42        CMN (immediate)

                       Compare negative (immediate), setting the condition flags and discarding the result: Rn + shift(imm)

                       This instruction is an alias of the ADDS (immediate) instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of ADDS (immediate).

                       ·       The description of ADDS (immediate) gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21                                   10 9             5 4             0
                           sf 0 1 1 0 0 0 1 shift                          imm12                        Rn        1 1 1 1 1
                              op S                                                                                     Rd


                       32-bit variant

                       Applies when sf = 0.

                       CMN <Wn|WSP>, #<imm>{, <shift>}

                       is equivalent to

                       ADDS WZR, <Wn|WSP>, #<imm> {, <shift>}

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       CMN <Xn|SP>, #<imm>{, <shift>}

                       is equivalent to

                       ADDS XZR, <Xn|SP>, #<imm> {, <shift>}

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wn|WSP>        Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                       <Xn|SP>         Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                       <imm>           Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

                       <shift>         Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "shift"
                                       field. It can have the following values:

                                       LSL #0       when shift = 00

                                       LSL #12      when shift = 01

                                       It is RESERVED when shift = 1x.


                       Operation

                       The description of ADDS (immediate) gives the operational pseudocode for this instruction.




C6-456                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.43     CMN (shifted register)

                Compare negative (shifted register), setting the condition flags and discarding the result: Rn + shift(Rm, amount)

                This instruction is an alias of the ADDS (shifted register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ADDS (shifted register).

                ·      The description of ADDS (shifted register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15              10 9            5 4              0
                   sf 0 1 0 1 0 1 1 shift 0                   Rm               imm6              Rn         1 1 1 1 1
                     op S                                                                                         Rd


                32-bit variant

                Applies when sf = 0.

                CMN <Wn>, <Wm>{, <shift> #<amount>}

                is equivalent to

                ADDS WZR, <Wn>, <Wm> {, <shift> #<amount>}

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                CMN <Xn>, <Xm>{, <shift> #<amount>}

                is equivalent to

                ADDS XZR, <Xn>, <Xm> {, <shift> #<amount>}

                and is always the preferred disassembly.


                Assembler symbols

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                in the "shift" field. It can have the following values:

                                LSL          when shift = 00

                                LSR          when shift = 01

                                ASR          when shift = 10

                                It is RESERVED when shift = 11.

                <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                "imm6" field.

                                For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                "imm6" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-457
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                       The description of ADDS (shifted register) gives the operational pseudocode for this instruction.




C6-458                                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                       Non-Confidential - Beta                                              ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.44     CMP (extended register)

                Compare (extended register), setting the condition flags and discarding the result: Rn - LSL(extend(Rm), amount)

                This instruction is an alias of the SUBS (extended register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SUBS (extended register).

                ·      The description of SUBS (extended register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15     13 12      10 9            5 4             0
                   sf 1 1 0 1 0 1 1 0 0 1                   Rm          option    imm3           Rn        1 1 1 1 1
                     op S                                                                                        Rd


                32-bit variant

                Applies when sf = 0.

                CMP <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

                is equivalent to

                SUBS WZR, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                CMP <Xn|SP>, <R><m>{, <extend> {#<amount>}}

                is equivalent to

                SUBS XZR, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

                and is always the preferred disassembly.


                Assembler symbols

                <Wn|WSP>        Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                field.

                <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xn|SP>         Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                field.

                <R>             Is a width specifier, encoded in the "option" field. It can have the following values:

                                W            when option = 00x

                                W            when option = 010

                                X            when option = x11

                                W            when option = 10x

                                W            when option = 110

                <m>             Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
                                the "Rm" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-459
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <extend>        For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
                                       "option" field. It can have the following values:

                                       UXTB         when option = 000

                                       UXTH         when option = 001

                                       LSL|UXTW     when option = 010

                                       UXTX         when option = 011

                                       SXTB         when option = 100

                                       SXTH         when option = 101

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
                                       "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.

                                       For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
                                       "option" field. It can have the following values:

                                       UXTB         when option = 000

                                       UXTH         when option = 001

                                       UXTW         when option = 010

                                       LSL|UXTX     when option = 011

                                       SXTB         when option = 100

                                       SXTH         when option = 101

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
                                       is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.

                       <amount>        Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
                                       the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
                                       and is optional when <extend> is present but not LSL.


                       Operation

                       The description of SUBS (extended register) gives the operational pseudocode for this instruction.




C6-460                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.45     CMP (immediate)

                Compare (immediate), setting the condition flags and discarding the result: Rn - shift(imm)

                This instruction is an alias of the SUBS (immediate) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SUBS (immediate).

                ·      The description of SUBS (immediate) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                                     10 9             5 4              0
                   sf 1 1 1 0 0 0 1 shift                           imm12                        Rn        1 1 1 1 1
                     op S                                                                                       Rd


                32-bit variant

                Applies when sf = 0.

                CMP <Wn|WSP>, #<imm>{, <shift>}

                is equivalent to

                SUBS WZR, <Wn|WSP>, #<imm> {, <shift>}

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                CMP <Xn|SP>, #<imm>{, <shift>}

                is equivalent to

                SUBS XZR, <Xn|SP>, #<imm> {, <shift>}

                and is always the preferred disassembly.


                Assembler symbols

                <Wn|WSP>        Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <Xn|SP>         Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <imm>           Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

                <shift>         Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "shift"
                                field. It can have the following values:

                                LSL #0       when shift = 00

                                LSL #12      when shift = 01

                                It is RESERVED when shift = 1x.


                Operation

                The description of SUBS (immediate) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-461
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.46        CMP (shifted register)

                       Compare (shifted register), setting the condition flags and discarding the result: Rn - shift(Rm,amount)

                       This instruction is an alias of the SUBS (shifted register) instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SUBS (shifted register).

                       ·       The description of SUBS (shifted register) gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15              10 9            5 4             0
                           sf 1 1 0 1 0 1 1 shift 0                  Rm               imm6              Rn         1 1 1 1 1
                              op S                                                                                       Rd


                       32-bit variant

                       Applies when sf = 0.

                       CMP <Wn>, <Wm>{, <shift> #<amount>}

                       is equivalent to

                       SUBS WZR, <Wn>, <Wm> {, <shift> #<amount>}

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       CMP <Xn>, <Xm>{, <shift> #<amount>}

                       is equivalent to

                       SUBS XZR, <Xn>, <Xm> {, <shift> #<amount>}

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                       in the "shift" field. It can have the following values:

                                       LSL          when shift = 00

                                       LSR          when shift = 01

                                       ASR          when shift = 10

                                       It is RESERVED when shift = 11.

                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.




C6-462                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



                Operation

                The description of SUBS (shifted register) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-463
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.47        CNEG

                       Conditional negate: Rd = if cond then -Rn else Rn

                       This instruction is an alias of the CSNEG instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of CSNEG.

                       ·       The description of CSNEG gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20           16 15       12 11 10 9             5 4              0
                           sf 1 0 1 1 0 1 0 1 0 0                  Rm          !=111x    0 1          Rn              Rd
                              op                                                cond       o2


                       32-bit variant

                       Applies when sf = 0.

                       CNEG <Wd>, <Wn>, <cond>

                       is equivalent to

                       CSNEG <Wd>, <Wn>, <Wn>, invert(<cond>)

                       and is the preferred disassembly when Rn == Rm.

                       64-bit variant

                       Applies when sf = 1.

                       CNEG <Xd>, <Xn>, <cond>

                       is equivalent to

                       CSNEG <Xd>, <Xn>, <Xn>, invert(<cond>)

                       and is the preferred disassembly when Rn == Rm.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                       <cond>          Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
                                       significant bit inverted.


                       Operation

                       The description of CSNEG gives the operational pseudocode for this instruction.




C6-464                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.48     CRC32B, CRC32H, CRC32W, CRC32X

                CRC-32 checksum from byte, halfword, word or doubleword: Wd = CRC32(Wn, Rm<n:0>) // n = 7, 15, 31, 63




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9             5 4              0
                  sf 0 0 1 1 0 1 0 1 1 0                 Rm        0 1 0 0       sz          Rn              Rd
                                                                             C


                CRC32B variant

                Applies when sf = 0 && sz = 00.

                CRC32B <Wd>, <Wn>, <Wm>


                CRC32H variant

                Applies when sf = 0 && sz = 01.

                CRC32H <Wd>, <Wn>, <Wm>


                CRC32W variant

                Applies when sf = 0 && sz = 10.

                CRC32W <Wd>, <Wn>, <Wm>


                CRC32X variant

                Applies when sf = 1 && sz = 11.

                CRC32X <Wd>, <Wn>, <Xm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sf == '1' && sz != '11' then UnallocatedEncoding();
                 if sf == '0' && sz == '11' then UnallocatedEncoding();
                 integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
                 boolean crc32c = (C == '1');


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose accumulator output register, encoded in the "Rd" field.

                <Wn>          Is the 32-bit name of the general-purpose accumulator input register, encoded in the "Rn" field.

                <Xm>          Is the 64-bit name of the general-purpose data source register, encoded in the "Rm" field.

                <Wm>          Is the 32-bit name of the general-purpose data source register, encoded in the "Rm" field.


                Operation

                 if !HaveCRCExt() then
                     UnallocatedEncoding();

                 bits(32)      acc     = X[n];   // accumulator
                 bits(size)    val     = X[m];   // input value
                 bits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-465
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         bits(32+size) tempacc = BitReverse(acc) : Zeros(size);
                         bits(size+32) tempval = BitReverse(val) : Zeros(32);

                         // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
                         X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));




C6-466                                  Copyright © 2013, 2014 ARM Limited. All rights reserved.        ARM DDI 0487A.e
                                                       Non-Confidential - Beta                               ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.49     CRC32CB, CRC32CH, CRC32CW, CRC32CX

                CRC-32C checksum from byte, halfword, word, or doubleword: Wd = CRC32C(Wn, Rm<n:0>) // n = 7, 15, 31, 63




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9             5 4              0
                  sf 0 0 1 1 0 1 0 1 1 0                 Rm        0 1 0 1       sz          Rn              Rd
                                                                             C


                CRC32CB variant

                Applies when sf = 0 && sz = 00.

                CRC32CB <Wd>, <Wn>, <Wm>


                CRC32CH variant

                Applies when sf = 0 && sz = 01.

                CRC32CH <Wd>, <Wn>, <Wm>


                CRC32CW variant

                Applies when sf = 0 && sz = 10.

                CRC32CW <Wd>, <Wn>, <Wm>


                CRC32CX variant

                Applies when sf = 1 && sz = 11.

                CRC32CX <Wd>, <Wn>, <Xm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sf == '1' && sz != '11' then UnallocatedEncoding();
                 if sf == '0' && sz == '11' then UnallocatedEncoding();
                 integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
                 boolean crc32c = (C == '1');


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose accumulator output register, encoded in the "Rd" field.

                <Wn>          Is the 32-bit name of the general-purpose accumulator input register, encoded in the "Rn" field.

                <Xm>          Is the 64-bit name of the general-purpose data source register, encoded in the "Rm" field.

                <Wm>          Is the 32-bit name of the general-purpose data source register, encoded in the "Rm" field.


                Operation

                 if !HaveCRCExt() then
                     UnallocatedEncoding();

                 bits(32)      acc     = X[n];   // accumulator
                 bits(size)    val     = X[m];   // input value
                 bits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-467
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         bits(32+size) tempacc = BitReverse(acc) : Zeros(size);
                         bits(size+32) tempval = BitReverse(val) : Zeros(32);

                         // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
                         X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));




C6-468                                  Copyright © 2013, 2014 ARM Limited. All rights reserved.        ARM DDI 0487A.e
                                                       Non-Confidential - Beta                               ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.50     CSEL

                Conditional select, returning the first or second input: Rd = if cond then Rn else Rm




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15        12 11 10 9            5 4              0
                  sf 0 0 1 1 0 1 0 1 0 0                     Rm           cond     0 0         Rn              Rd
                     op                                                               o2


                32-bit variant

                Applies when sf = 0.

                CSEL <Wd>, <Wn>, <Wm>, <cond>


                64-bit variant

                Applies when sf = 1.

                CSEL <Xd>, <Xn>, <Xm>, <cond>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 bits(4) condition = cond;
                 boolean else_inv = (op == '1');
                 boolean else_inc = (o2 == '1');


                Assembler symbols

                <Wd>           Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>           Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>           Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>           Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>           Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>           Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <cond>         Is one of the standard conditions, encoded in the "cond" field in the standard way.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];

                 if ConditionHolds(condition) then
                     result = operand1;
                 else
                     result = operand2;
                     if else_inv then result = NOT(result);
                     if else_inc then result = result + 1;

                 X[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-469
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.51        CSET

                       Conditional set: Rd = if cond then 1 else 0

                       This instruction is an alias of the CSINC instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of CSINC.

                       ·       The description of CSINC gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15      12 11 10 9             5 4              0
                           sf 0 0 1 1 0 1 0 1 0 0 1 1 1 1 1                    !=111x    0 1 1 1 1 1 1                Rd
                              op                                   Rm           cond        o2        Rn


                       32-bit variant

                       Applies when sf = 0.

                       CSET <Wd>, <cond>

                       is equivalent to

                       CSINC <Wd>, WZR, WZR, invert(<cond>)

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       CSET <Xd>, <cond>

                       is equivalent to

                       CSINC <Xd>, XZR, XZR, invert(<cond>)

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <cond>          Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
                                       significant bit inverted.


                       Operation

                       The description of CSINC gives the operational pseudocode for this instruction.




C6-470                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.52     CSETM

                Conditional set mask: Rd = if cond then -1 else 0

                This instruction is an alias of the CSINV instruction. This means that:

                ·      The encodings in this description are named to match the encodings of CSINV.

                ·      The description of CSINV gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15       12 11 10 9              5 4              0
                   sf 1 0 1 1 0 1 0 1 0 0 1 1 1 1 1                     !=111x    0 0 1 1 1 1 1                Rd
                     op                                    Rm            cond       o2         Rn


                32-bit variant

                Applies when sf = 0.

                CSETM <Wd>, <cond>

                is equivalent to

                CSINV <Wd>, WZR, WZR, invert(<cond>)

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                CSETM <Xd>, <cond>

                is equivalent to

                CSINV <Xd>, XZR, XZR, invert(<cond>)

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <cond>          Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
                                significant bit inverted.


                Operation

                The description of CSINV gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-471
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.53        CSINC

                       Conditional select increment, returning the first input or incremented second input: Rd = if cond then Rn else (Rm
                       + 1)

                       This instruction is used by the aliases CINC and CSET. See the Alias conditions table for details of when each alias
                       is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15        12 11 10 9             5 4             0
                           sf 0 0 1 1 0 1 0 1 0 0                  Rm             cond    0 1          Rn              Rd
                              op                                                             o2


                       32-bit variant

                       Applies when sf = 0.

                       CSINC <Wd>, <Wn>, <Wm>, <cond>


                       64-bit variant

                       Applies when sf = 1.

                       CSINC <Xd>, <Xn>, <Xm>, <cond>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         bits(4) condition = cond;
                         boolean else_inv = (op == '1');
                         boolean else_inc = (o2 == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            CINC                      Rm != '11111' && cond != '111x' && Rn != '11111' && Rn == Rm

                                            CSET                      Rm == '11111' && cond != '111x' && Rn == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <cond>          Is one of the standard conditions, encoded in the "cond" field in the standard way.




C6-472                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];

                 if ConditionHolds(condition) then
                    result = operand1;
                 else
                    result = operand2;
                    if else_inv then result = NOT(result);
                    if else_inc then result = result + 1;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-473
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.54        CSINV

                       Conditional select inversion, returning the first input or inverted second input: Rd = if cond then Rn else NOT (Rm)

                       This instruction is used by the aliases CINV and CSETM. See the Alias conditions table for details of when each
                       alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15        12 11 10 9             5 4             0
                           sf 1 0 1 1 0 1 0 1 0 0                   Rm            cond      0 0         Rn              Rd
                              op                                                              o2


                       32-bit variant

                       Applies when sf = 0.

                       CSINV <Wd>, <Wn>, <Wm>, <cond>


                       64-bit variant

                       Applies when sf = 1.

                       CSINV <Xd>, <Xn>, <Xm>, <cond>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         bits(4) condition = cond;
                         boolean else_inv = (op == '1');
                         boolean else_inc = (o2 == '1');


                       Alias conditions


                                             Alias                     is preferred when

                                             CINV                      Rm != '11111' && cond != '111x' && Rn != '11111' && Rn == Rm

                                             CSETM                     Rm == '11111' && cond != '111x' && Rn == '11111'



                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <cond>           Is one of the standard conditions, encoded in the "cond" field in the standard way.




C6-474                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];

                 if ConditionHolds(condition) then
                    result = operand1;
                 else
                    result = operand2;
                    if else_inv then result = NOT(result);
                    if else_inc then result = result + 1;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-475
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.55        CSNEG

                       Conditional select negation, returning the first input or negated second input: Rd = if cond then Rn else -Rm

                       This instruction is used by the alias CNEG. See the Alias conditions table for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15        12 11 10 9              5 4            0
                           sf 1 0 1 1 0 1 0 1 0 0                  Rm            cond      0 1         Rn              Rd
                              op                                                             o2


                       32-bit variant

                       Applies when sf = 0.

                       CSNEG <Wd>, <Wn>, <Wm>, <cond>


                       64-bit variant

                       Applies when sf = 1.

                       CSNEG <Xd>, <Xn>, <Xm>, <cond>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         bits(4) condition = cond;
                         boolean else_inv = (op == '1');
                         boolean else_inc = (o2 == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            CNEG                      cond != '111x' && Rn == Rm



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <cond>          Is one of the standard conditions, encoded in the "cond" field in the standard way.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];



C6-476                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions




                 if ConditionHolds(condition) then
                    result = operand1;
                 else
                    result = operand2;
                    if else_inv then result = NOT(result);
                    if else_inc then result = result + 1;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-477
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.56        DC

                       Data cache operation

                       This instruction is an alias of the SYS instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SYS.

                       ·       The description of SYS gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15        12 11       8 7      5 4             0
                           1 1 0 1 0 1 0 1 0 0 0 0 1                  op1     0 1 1 1        CRm        op2           Rt
                                                           L                     CRn


                       System variant

                       DC <dc_op>, <Xt>

                       is equivalent to

                       SYS #<op1>, C7, <Cm>, #<op2>, <Xt>

                       and is the preferred disassembly when SysOp(op1,'0111',CRm,op2) == Sys_DC.


                       Assembler symbols

                       <dc_op>         Is a DC operation name, as listed for the DC system operation group, encoded in the
                                       "op1:CRm:op2" field. It can have the following values:

                                       IVAC         when op1 = 000, CRm = 0110, op2 = 001

                                       ISW          when op1 = 000, CRm = 0110, op2 = 010

                                       CSW          when op1 = 000, CRm = 1010, op2 = 010

                                       CISW         when op1 = 000, CRm = 1110, op2 = 010

                                       ZVA          when op1 = 011, CRm = 0100, op2 = 001

                                       CVAC         when op1 = 011, CRm = 1010, op2 = 001

                                       CVAU         when op1 = 011, CRm = 1011, op2 = 001

                                       CIVAC        when op1 = 011, CRm = 1110, op2 = 001

                       <op1>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

                       <Cm>            Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

                       <op2>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

                       <Xt>            Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.


                       Operation

                       The description of SYS gives the operational pseudocode for this instruction.




C6-478                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.57     DCPS1

                Debug Change PE State to EL1 allows the debugger to move the PE into EL1 from a lower Exception Level or to
                a specific mode at the current Exception Level.

                If the PE is at EL1 or lower, then the PE enters EL1h.

                If the PE is at an Exception Level higher than EL1, then the PE does not change Exception Level but selects use of
                the stack pointer for the current Exception Level by updating PSTATE.SP.

                This instruction is always UNDEFINED in Non-debug state.

                For more information on the operation of this instructions, see DCPS on page H2-4963.




                  31 30 29 28 27 26 25 24 23 22 21 20                                                 5 4 3 2 1 0
                   1 1 0 1 0 1 0 0 1 0 1                                   imm16                        0 0 0 0 1
                                                                                                                    LL


                System variant

                DCPS1 {#<imm>}


                Decode for this encoding

                 bits(2) target_level = LL;
                 if LL == '00' then UnallocatedEncoding();
                 if !Halted() then AArch64.UndefinedFault();


                Assembler symbols

                <imm>            Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in
                                 the "imm16" field.


                Operation

                 DCPSInstruction(target_level);




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-479
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.58        DCPS2

                       Debug Change PE State to EL2 allows the debugger to move the PE into EL2 from a lower Exception Level or to
                       a specific mode at the current Exception Level.

                       If the PE is at EL2 or lower, then the PE enters EL2h.

                       If the PE is at an Exception Level higher than EL2, then the PE does not change Exception Level but selects use of
                       the stack pointer for the current Exception Level by updating PSTATE.SP.

                       This instruction is always UNDEFINED in Non-debug state.

                       For more information on the operation of this instructions, see DCPS on page H2-4963.




                           31 30 29 28 27 26 25 24 23 22 21 20                                               5 4 3 2 1 0
                           1 1 0 1 0 1 0 0 1 0 1                                  imm16                        0 0 0 1 0
                                                                                                                           LL


                       System variant

                       DCPS2 {#<imm>}


                       Decode for this encoding

                         bits(2) target_level = LL;
                         if LL == '00' then UnallocatedEncoding();
                         if !Halted() then AArch64.UndefinedFault();


                       Assembler symbols

                       <imm>            Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in
                                        the "imm16" field.


                       Operation

                         DCPSInstruction(target_level);




C6-480                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.59     DCPS3

                Debug Change PE State to EL3 allows the debugger to move the PE into EL3 from a lower Exception Level or to
                a specific mode at the current Exception Level. The PE enters EL3h.

                This instruction is always UNDEFINED in Non-debug state.

                For more information on the operation of this instructions, see DCPS on page H2-4963.




                  31 30 29 28 27 26 25 24 23 22 21 20                                                5 4 3 2 1 0
                   1 1 0 1 0 1 0 0 1 0 1                                   imm16                       0 0 0 1 1
                                                                                                                   LL


                System variant

                DCPS3 {#<imm>}


                Decode for this encoding

                 bits(2) target_level = LL;
                 if LL == '00' then UnallocatedEncoding();
                 if !Halted() then AArch64.UndefinedFault();


                Assembler symbols

                <imm>           Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in
                                the "imm16" field.


                Operation

                 DCPSInstruction(target_level);




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-481
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.60        DMB

                       Data memory barrier




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11            8 7 6 5 4 3 2 1 0
                           1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1                            CRm       1 0 1 1 1 1 1 1
                                                                                                            opc


                       System variant

                       DMB <option>|#<imm>


                       Decode for this encoding

                         MemBarrierOp op;
                         MBReqDomain domain;
                         MBReqTypes types;

                         case opc of
                              when '00' op = MemBarrierOp_DSB;
                              when '01' op = MemBarrierOp_DMB;
                              when '10' op = MemBarrierOp_ISB;
                              otherwise UnallocatedEncoding();

                         case CRm<3:2> of
                              when '00' domain = MBReqDomain_OuterShareable;
                              when '01' domain = MBReqDomain_Nonshareable;
                              when '10' domain = MBReqDomain_InnerShareable;
                              when '11' domain = MBReqDomain_FullSystem;

                         case CRm<1:0> of
                              when '01' types = MBReqTypes_Reads;
                              when '10' types = MBReqTypes_Writes;
                              when '11' types = MBReqTypes_All;
                              otherwise
                                   types = MBReqTypes_All;
                                   domain = MBReqDomain_FullSystem;


                       Assembler symbols

                       <option>         Specifies the limitation on the barrier operation. Values are:

                                        SY          Full system is the required shareability domain, reads and writes are the required access
                                                    types in both Group A on page B2-85 and Group B on page B2-86. This option is
                                                    referred to as the full system DMB. Encoded as CRm = 0b1111.

                                        ST          Full system is the required shareability domain, writes are the required access type in
                                                    both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b1110.

                                        LD          Full system is the required shareability domain, reads are the required access type in
                                                    Group A on page B2-85, and reads and writes are the required access types in both
                                                    Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b1101.

                                        ISH         Inner Shareable is the required shareability domain, reads and writes are the required
                                                    access types in Group B on page B2-86. Encoded as CRm = 0b1011.

                                        ISHST       Inner Shareable is the required shareability domain, writes are the required access type
                                                    in both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b1010.

                                        ISHLD       Inner Shareable is the required shareability domain, reads are the required access type
                                                    in Group A on page B2-85. Encoded as CRm = 0b1001.

                                        NSH         Non-shareable is the required shareability domain, reads and writes are the required
                                                    access types in Group B on page B2-86. Encoded as CRm = 0b0111.


C6-482                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



                              NSHST       Non-shareable is the required shareability domain, writes are the required access type
                                          in both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b0110.

                              NSHLD       Non-shareable is the required shareability domain, reads are the required access type in
                                          Group A on page B2-85. Encoded as CRm = 0b0101.

                              OSH         Outer Shareable is the required shareability domain, reads and writes are the required
                                          access types in Group B on page B2-86. Encoded as CRm = 0b0011.

                              OSHST       Outer Shareable is the required shareability domain, writes are the required access type
                                          in both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b0010.

                              OSHLD       Outer Shareable is the required shareability domain, reads are the required access type
                                          in Group A on page B2-85. Encoded as CRm = 0b0001.

                               All other encodings of CRm that are not listed above are reserved, and can be encoded using the
                              #<imm> syntax. It is IMPLEMENTATION DEFINED whether options other than SY are implemented. All
                              unsupported and reserved options must execute as a full system operation, but software must not
                              rely on this behavior.

                <imm>         Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the "CRm" field.


                Operation

                 case op of
                    when MemBarrierOp_DSB
                         DataSynchronizationBarrier(domain, types);
                    when MemBarrierOp_DMB
                         DataMemoryBarrier(domain, types);
                    when MemBarrierOp_ISB
                         InstructionSynchronizationBarrier();




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-483
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.61        DRPS

                       Debug restore process state




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
                           1 1 0 1 0 1 1 0 1 0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0




                       System variant

                       DRPS


                       Decode for this encoding

                         if !Halted() || PSTATE.EL == EL0 then UnallocatedEncoding();


                       Operation

                         DRPSInstruction();




C6-484                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                 ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.62     DSB

                Data synchronization barrier




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11           8 7 6 5 4 3 2 1 0
                  1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1                           CRm       1 0 0 1 1 1 1 1
                                                                                                  opc


                System variant

                DSB <option>|#<imm>


                Decode for this encoding

                 MemBarrierOp op;
                 MBReqDomain domain;
                 MBReqTypes types;

                 case opc of
                     when '00' op = MemBarrierOp_DSB;
                     when '01' op = MemBarrierOp_DMB;
                     when '10' op = MemBarrierOp_ISB;
                     otherwise UnallocatedEncoding();

                 case CRm<3:2> of
                     when '00' domain = MBReqDomain_OuterShareable;
                     when '01' domain = MBReqDomain_Nonshareable;
                     when '10' domain = MBReqDomain_InnerShareable;
                     when '11' domain = MBReqDomain_FullSystem;

                 case CRm<1:0> of
                     when '01' types = MBReqTypes_Reads;
                     when '10' types = MBReqTypes_Writes;
                     when '11' types = MBReqTypes_All;
                     otherwise
                        types = MBReqTypes_All;
                        domain = MBReqDomain_FullSystem;


                Assembler symbols

                <option>      Specifies the limitation on the barrier operation. Values are:

                              SY          Full system is the required shareability domain, reads and writes are the required access
                                          types in both Group A on page B2-85 and Group B on page B2-86. This option is
                                          referred to as the full system DMB. Encoded as CRm = 0b1111.

                              ST          Full system is the required shareability domain, writes are the required access type in
                                          both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b1110.

                              LD          Full system is the required shareability domain, reads are the required access type in
                                          Group A on page B2-85, and reads and writes are the required access types in both
                                          Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b1101.

                              ISH         Inner Shareable is the required shareability domain, reads and writes are the required
                                          access types in Group B on page B2-86. Encoded as CRm = 0b1011.

                              ISHST       Inner Shareable is the required shareability domain, writes are the required access type
                                          in both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b1010.

                              ISHLD       Inner Shareable is the required shareability domain, reads are the required access type
                                          in Group A on page B2-85. Encoded as CRm = 0b1001.

                              NSH         Non-shareable is the required shareability domain, reads and writes are the required
                                          access types in Group B on page B2-86. Encoded as CRm = 0b0111.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-485
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                        NSHST       Non-shareable is the required shareability domain, writes are the required access type
                                                    in both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b0110.

                                        NSHLD       Non-shareable is the required shareability domain, reads are the required access type in
                                                    Group A on page B2-85. Encoded as CRm = 0b0101.

                                        OSH         Outer Shareable is the required shareability domain, reads and writes are the required
                                                    access types in Group B on page B2-86. Encoded as CRm = 0b0011.

                                        OSHST       Outer Shareable is the required shareability domain, writes are the required access type
                                                    in both Group A on page B2-85 and Group B on page B2-86. Encoded as CRm = 0b0010.

                                        OSHLD       Outer Shareable is the required shareability domain, reads are the required access type
                                                    in Group A on page B2-85. Encoded as CRm = 0b0001.

                                         All other encodings of CRm that are not listed above are reserved, and can be encoded using the
                                        #<imm> syntax. It is IMPLEMENTATION DEFINED whether options other than SY are implemented. All
                                        unsupported and reserved options must execute as a full system operation, but software must not
                                        rely on this behavior.

                       <imm>            Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the "CRm" field.


                       Operation

                         case op of
                              when MemBarrierOp_DSB
                                   DataSynchronizationBarrier(domain, types);
                              when MemBarrierOp_DMB
                                   DataMemoryBarrier(domain, types);
                              when MemBarrierOp_ISB
                                   InstructionSynchronizationBarrier();




C6-486                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.63     EON (shifted register)

                Bitwise exclusive OR NOT (shifted register): Rd = Rn EOR NOT shift(Rm, amount)




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15               10 9             5 4             0
                  sf 1 0 0 1 0 1 0 shift 1                  Rm               imm6                Rn            Rd
                     opc                           N


                32-bit variant

                Applies when sf = 0.

                EON <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                EON <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);
                 boolean invert = (N == '1');


                Assembler symbols

                <Wd>           Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>           Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>           Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>           Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>           Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>           Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>        Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                               field. It can have the following values:

                               LSL          when shift = 00

                               LSR          when shift = 01

                               ASR          when shift = 10

                               ROR          when shift = 11


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-487
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR       operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         X[d] = result;




C6-488                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.64     EOR (immediate)

                Bitwise exclusive OR (immediate): Rd = Rn EOR imm




                  31 30 29 28 27 26 25 24 23 22 21                16 15             10 9             5 4              0
                  sf 1 0 1 0 0 1 0 0 N                  immr               imms               Rn               Rd
                     opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                EOR <Wd|WSP>, <Wn>, #<imm>


                64-bit variant

                Applies when sf = 1.

                EOR <Xd|SP>, <Xn>, #<imm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 bits(datasize) imm;
                 if sf == '0' && N != '0' then ReservedValue();
                 (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);


                Assembler symbols

                <Wd|WSP>       Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                               field.

                <Wn>           Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd|SP>        Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                               field.

                <Xn>           Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <imm>          Is the bitmask immediate, encoded in "N:imms:immr".


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = imm;

                 case op of
                     when LogicalOp_AND result = operand1 AND operand2;
                     when LogicalOp_ORR result = operand1 OR      operand2;
                     when LogicalOp_EOR result = operand1 EOR operand2;



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-489
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions




                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-490                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                        Non-Confidential - Beta                           ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.65     EOR (shifted register)

                Bitwise exclusive OR (shifted register): Rd = Rn EOR shift(Rm, amount)




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15               10 9             5 4             0
                  sf 1 0 0 1 0 1 0 shift 0                  Rm               imm6                Rn            Rd
                     opc                           N


                32-bit variant

                Applies when sf = 0.

                EOR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                EOR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean setflags;
                 LogicalOp op;
                 case opc of
                     when '00' op = LogicalOp_AND; setflags = FALSE;
                     when '01' op = LogicalOp_ORR; setflags = FALSE;
                     when '10' op = LogicalOp_EOR; setflags = FALSE;
                     when '11' op = LogicalOp_AND; setflags = TRUE;

                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);
                 boolean invert = (N == '1');


                Assembler symbols

                <Wd>           Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>           Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>           Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>           Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>           Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>           Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>        Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                               field. It can have the following values:

                               LSL          when shift = 00

                               LSR          when shift = 01

                               ASR          when shift = 10

                               ROR          when shift = 11


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-491
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND result = operand1 AND operand2;
                              when LogicalOp_ORR result = operand1 OR       operand2;
                              when LogicalOp_EOR result = operand1 EOR operand2;

                         if setflags then
                              PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                         X[d] = result;




C6-492                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



C6.6.66     ERET

                Exception return using current ELR and SPSR




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
                  1 1 0 1 0 1 1 0 1 0 0 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0




                System variant

                ERET


                Decode for this encoding

                 if PSTATE.EL == EL0 then UnallocatedEncoding();


                Operation

                 AArch64.ExceptionReturn(ELR[], SPSR[]);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-493
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.67        EXTR

                       Extract register from pair of registers

                       This instruction is used by the alias ROR (immediate). See the Alias conditions table for details of when each alias
                       is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15                10 9            5 4               0
                           sf 0 0 1 0 0 1 1 1 N 0                   Rm                imms                Rn              Rd




                       32-bit variant

                       Applies when sf = 0 && N = 0 && imms = 0xxxxx.

                       EXTR <Wd>, <Wn>, <Wm>, #<lsb>


                       64-bit variant

                       Applies when sf = 1 && N = 1.

                       EXTR <Xd>, <Xn>, <Xm>, #<lsb>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         integer lsb;

                         if N != sf then UnallocatedEncoding();
                         if sf == '0' && imms<5> == '1' then ReservedValue();
                         lsb = UInt(imms);


                       Alias conditions


                                            Alias                      is preferred when

                                            ROR (immediate)            Rn == Rm



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <lsb>           For the 32-bit variant: is the least significant bit position from which to extract, in the range 0 to 31,
                                       encoded in the "imms" field.

                                       For the 64-bit variant: is the least significant bit position from which to extract, in the range 0 to 63,
                                       encoded in the "imms" field.


C6-494                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                    ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];
                 bits(2*datasize) concat = operand1:operand2;

                 result = concat<lsb+datasize-1:lsb>;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-495
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.68        HINT

                       Hint instruction

                       This instruction is used by the aliases NOP, SEVL, SEV, WFE, WFI, and YIELD. See the Alias conditions table
                       for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11          8 7      5 4 3 2 1 0
                           1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0                            CRm        op2  1 1 1 1 1




                       System variant

                       HINT #<imm>


                       Decode for this encoding

                         SystemHintOp op;

                         case CRm:op2 of
                              when '0000 000' op = SystemHintOp_NOP;
                              when '0000 001' op = SystemHintOp_YIELD;
                              when '0000 010' op = SystemHintOp_WFE;
                              when '0000 011' op = SystemHintOp_WFI;
                              when '0000 100' op = SystemHintOp_SEV;
                              when '0000 101' op = SystemHintOp_SEVL;
                              otherwise   op = SystemHintOp_NOP;


                       Alias conditions


                                             Alias                  is preferred when

                                             NOP                    CRm == '0000' && op2 == '000'

                                             SEVL                   CRm == '0000' && op2 == '101'

                                             SEV                    CRm == '0000' && op2 == '100'

                                             WFE                    CRm == '0000' && op2 == '010'

                                             WFI                    CRm == '0000' && op2 == '011'

                                             YIELD                  CRm == '0000' && op2 == '001'



                       Assembler symbols

                       <imm>            Is a 7-bit unsigned immediate, in the range 0 to 127, encoded in "CRm:op2".


                       Operation

                         case op of
                              when SystemHintOp_YIELD
                                   Hint_Yield();

                              when SystemHintOp_WFE
                                   if EventRegistered() then
                                       ClearEventRegister();
                                   else
                                      if PSTATE.EL == EL0 then



C6-496                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                       ID121714

                                                                                       C6 A64 Base Instruction Descriptions
                                                                                        C6.6 Alphabetical list of instructions



                               AArch64.CheckForWFxTrap(EL1, TRUE);
                          if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then
                               AArch64.CheckForWFxTrap(EL2, TRUE);
                          if HaveEL(EL3) && PSTATE.EL != EL3 then
                               AArch64.CheckForWFxTrap(EL3, TRUE);
                           WaitForEvent();

                   when SystemHintOp_WFI
                      if !InterruptPending() then
                          if PSTATE.EL == EL0 then
                              AArch64.CheckForWFxTrap(EL1, FALSE);
                          if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then
                              AArch64.CheckForWFxTrap(EL2, FALSE);
                          if HaveEL(EL3) && PSTATE.EL != EL3 then
                               AArch64.CheckForWFxTrap(EL3, FALSE);
                           WaitForInterrupt();

                   when SystemHintOp_SEV
                       SendEvent();

                   when SystemHintOp_SEVL
                       EventRegisterSet();

                   otherwise // do nothing




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-497
ID121714                                     Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.69        HLT

                       External debug breakpoint




                           31 30 29 28 27 26 25 24 23 22 21 20                                              5 4 3 2 1 0
                           1 1 0 1 0 1 0 0 0 1 0                                 imm16                         0 0 0 0 0




                       System variant

                       HLT #<imm>


                       Decode for this encoding

                         if EDSCR.HDE == '0' || !HaltingAllowed() then UndefinedFault();


                       Assembler symbols

                       <imm>           Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.


                       Operation

                         Halt(DebugHalt_HaltInstruction);




C6-498                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                            ID121714

                                                                                           C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



C6.6.70     HVC

                Generate exception targeting exception level 2




                  31 30 29 28 27 26 25 24 23 22 21 20                                              5 4 3 2 1 0
                  1 1 0 1 0 1 0 0 0 0 0                                 imm16                         0 0 0 1 0




                System variant

                HVC #<imm>


                Decode for this encoding

                 bits(16) imm = imm16;


                Assembler symbols

                <imm>         Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.


                Operation

                 if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && IsSecure()) then
                     UnallocatedEncoding();

                 hvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);
                 if hvc_enable == '0' then
                     AArch64.UndefinedFault();
                 else
                     AArch64.CallHypervisor(imm);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-499
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.71        IC

                       Instruction cache operation

                       This instruction is an alias of the SYS instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SYS.

                       ·       The description of SYS gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15         12 11       8 7       5 4             0
                           1 1 0 1 0 1 0 1 0 0 0 0 1                  op1      0 1 1 1        CRm        op2           Rt
                                                           L                      CRn


                       System variant

                       IC <ic_op>{, <Xt>}

                       is equivalent to

                       SYS #<op1>, C7, <Cm>, #<op2>{, <Xt>}

                       and is the preferred disassembly when SysOp(op1,'0111',CRm,op2) == Sys_IC.


                       Assembler symbols

                       <ic_op>         Is an IC operation name, as listed for the IC system operation pages, encoded in the "op1:CRm:op2"
                                       field. It can have the following values:

                                       IALLUIS      when op1 = 000, CRm = 0001, op2 = 000

                                       IALLU        when op1 = 000, CRm = 0101, op2 = 000

                                       IVAU         when op1 = 011, CRm = 0101, op2 = 001

                       <op1>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

                       <Cm>            Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

                       <op2>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

                       <Xt>            Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in
                                       the "Rt" field.


                       Operation

                       The description of SYS gives the operational pseudocode for this instruction.




C6-500                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.72     ISB

                Instruction synchronization barrier




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11           8 7 6 5 4 3 2 1 0
                  1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1                            CRm       1 1 0 1 1 1 1 1
                                                                                                   opc


                System variant

                ISB {<option>|#<imm>}


                Decode for this encoding

                 MemBarrierOp op;
                 MBReqDomain domain;
                 MBReqTypes types;

                 case opc of
                     when '00' op = MemBarrierOp_DSB;
                     when '01' op = MemBarrierOp_DMB;
                     when '10' op = MemBarrierOp_ISB;
                     otherwise UnallocatedEncoding();

                 case CRm<3:2> of
                     when '00' domain = MBReqDomain_OuterShareable;
                     when '01' domain = MBReqDomain_Nonshareable;
                     when '10' domain = MBReqDomain_InnerShareable;
                     when '11' domain = MBReqDomain_FullSystem;

                 case CRm<1:0> of
                     when '01' types = MBReqTypes_Reads;
                     when '10' types = MBReqTypes_Writes;
                     when '11' types = MBReqTypes_All;
                     otherwise
                          types = MBReqTypes_All;
                          domain = MBReqDomain_FullSystem;


                Assembler symbols

                <option>       Specifies an optional limitation on the barrier operation. Values are:

                               SY          Full system barrier operation, encoded as CRm = 0b1111. Can be omitted.

                                All other encodings of CRm are reserved. The corresponding instructions execute as full system
                               barrier operations, but must not be relied upon by software.

                <imm>          Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the
                               "CRm" field.


                Operation

                 case op of
                     when MemBarrierOp_DSB
                          DataSynchronizationBarrier(domain, types);
                     when MemBarrierOp_DMB
                          DataMemoryBarrier(domain, types);
                     when MemBarrierOp_ISB
                          InstructionSynchronizationBarrier();




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-501
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.73        LDAR

                       Load-Acquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The
                       instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For
                       information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4            0
                           1 x 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)             Rn              Rt
                           size                     o2 L o1        Rs        o0       Rt2


                       32-bit variant

                       Applies when size = 10.

                       LDAR <Wt>, [<Xn|SP>{,#0}]


                       64-bit variant

                       Applies when size = 11.

                       LDAR <Xt>, [<Xn|SP>{,#0}]


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN



C6-502                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                    if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                            when Constraint_NONE       rt_unknown = FALSE;       // store original value
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                         if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                 // This atomic write will be rejected if it does not refer
                                 // to the same physical locations after address translation.
                                 Mem[address, dbytes, acctype] = data;
                                 status = ExclusiveMonitorsStatus();
                             X[s] = ZeroExtend(status, 32);
                         else
                            // store release register (atomic)
                             Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                         if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                             AArch64.SetExclusiveMonitors(address, dbytes);

                         if pair then
                            // load exclusive pair



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-503
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      assert excl;
                                      if rt_unknown then
                                         // ConstrainedUNPREDICTABLE case
                                         X[t]   = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                         // 32-bit load exclusive pair (atomic)
                                         data = Mem[address, dbytes, acctype];
                                         if BigEndian() then
                                              X[t]  = data<datasize-1:elsize>;
                                              X[t2] = data<elsize-1:0>;
                                         else
                                              X[t]  = data<elsize-1:0>;
                                              X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                         // 64-bit load exclusive pair (not atomic),
                                         // but must be 128-bit aligned
                                         if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                         X[t]   = Mem[address + 0, 8, acctype];
                                         X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-504                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                          ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.74     LDARB

                Load-Acquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction
                also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For information
                about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14            10 9             5 4             0
                   0 0 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)           Rn              Rt
                   size                   o2 L o1        Rs        o0       Rt2


                No offset variant

                LDARB <Wt>, [<Xn|SP>{,#0}]


                Decode for this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);   // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Assembler symbols

                <Wt>          Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of
                         when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF       UnallocatedEncoding();
                         when Constraint_NOP         EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                     if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                         case c of
                            when Constraint_UNKNOWN       rt_unknown = TRUE;      // store UNKNOWN value
                            when Constraint_NONE          rt_unknown = FALSE;     // store original value



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-505
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;



C6-506                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                          ID121714

                                                                                  C6 A64 Base Instruction Descriptions
                                                                                   C6.6 Alphabetical list of instructions



                         else
                              X[t]  = data<elsize-1:0>;
                              X[t2] = data<datasize-1:elsize>;
                      else // elsize == 64
                         // 64-bit load exclusive pair (not atomic),
                         // but must be 128-bit aligned
                         if address != Align(address, dbytes) then
                              iswrite = FALSE;
                              secondstage = FALSE;
                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                         X[t]   = Mem[address + 0, 8, acctype];
                         X[t2] = Mem[address + 8, 8, acctype];
                   else
                      // load {acquire} {exclusive} single register
                      data = Mem[address, dbytes, acctype];
                      X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e          Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-507
ID121714                                Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.75        LDARH

                       Load-Acquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The
                       instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For
                       information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4            0
                           0 1 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)             Rn              Rt
                           size                     o2 L o1        Rs        o0       Rt2


                       No offset variant

                       LDARH <Wt>, [<Xn|SP>{,#0}]


                       Decode for this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN      rt_unknown = TRUE;       // store UNKNOWN value
                                      when Constraint_NONE         rt_unknown = FALSE;      // store original value



C6-508                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                        if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                // This atomic write will be rejected if it does not refer
                                // to the same physical locations after address translation.
                                Mem[address, dbytes, acctype] = data;
                                status = ExclusiveMonitorsStatus();
                            X[s] = ZeroExtend(status, 32);
                        else
                            // store release register (atomic)
                            Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                        if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                            AArch64.SetExclusiveMonitors(address, dbytes);

                        if pair then
                            // load exclusive pair
                            assert excl;
                            if rt_unknown then
                                // ConstrainedUNPREDICTABLE case
                                X[t]   = bits(datasize) UNKNOWN;
                            elsif elsize == 32 then
                                // 32-bit load exclusive pair (atomic)
                                data = Mem[address, dbytes, acctype];
                                if BigEndian() then
                                    X[t]   = data<datasize-1:elsize>;
                                    X[t2] = data<elsize-1:0>;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-509
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                         else
                                              X[t]  = data<elsize-1:0>;
                                              X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                         // 64-bit load exclusive pair (not atomic),
                                         // but must be 128-bit aligned
                                         if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                         X[t]   = Mem[address + 0, 8, acctype];
                                         X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-510                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                          ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.76     LDAXP

                Load-Acquire Exclusive Pair of Registers loads two 32-bit words or two 64-bit doublewords from memory, and
                writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic
                at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for
                each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive
                access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores
                on page B2-103. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release
                on page B2-88. For information about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14            10 9             5 4             0
                   1 x 0 0 1 0 0 0 0 1 1 (1) (1) (1) (1) (1) 1                 Rt2               Rn             Rt
                   size                     o2 L o1          Rs       o0


                32-bit variant

                Applies when size = 10.

                LDAXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]


                64-bit variant

                Applies when size = 11.

                LDAXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);     // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDAXP on page J1-5407.


                Assembler symbols

                <Wt1>           Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                <Wt2>           Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                field.

                <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt2>           Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                field.



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-511
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;     // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN      rt_unknown = TRUE;      // store UNKNOWN value
                                      when Constraint_NONE         rt_unknown = FALSE;     // store original value
                                      when Constraint_UNDEF        UnallocatedEncoding();
                                      when Constraint_NOP          EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN      rn_unknown = TRUE;      // address is UNKNOWN
                                      when Constraint_NONE         rn_unknown = FALSE;     // address is original base
                                      when Constraint_UNDEF        UnallocatedEncoding();
                                      when Constraint_NOP          EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();



C6-512                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                       C6 A64 Base Instruction Descriptions
                                                                                        C6.6 Alphabetical list of instructions



                          X[s] = ZeroExtend(status, 32);
                      else
                          // store release register (atomic)
                          Mem[address, dbytes, acctype] = data;

                   when MemOp_LOAD
                      if excl then
                          // Tell the Exclusive Monitors to record a sequence of one or more atomic
                          // memory reads from virtual address range [address, address+dbytes-1].
                          // The Exclusive Monitor will only be set if all the reads are from the
                          // same dbytes-aligned physical address, to allow for the possibility of
                          // an atomicity break if the translation is changed between reads.
                          AArch64.SetExclusiveMonitors(address, dbytes);

                      if pair then
                          // load exclusive pair
                          assert excl;
                          if rt_unknown then
                              // ConstrainedUNPREDICTABLE case
                              X[t]  = bits(datasize) UNKNOWN;
                          elsif elsize == 32 then
                              // 32-bit load exclusive pair (atomic)
                              data = Mem[address, dbytes, acctype];
                              if BigEndian() then
                                  X[t]  = data<datasize-1:elsize>;
                                  X[t2] = data<elsize-1:0>;
                              else
                                  X[t]  = data<elsize-1:0>;
                                  X[t2] = data<datasize-1:elsize>;
                          else // elsize == 64
                              // 64-bit load exclusive pair (not atomic),
                              // but must be 128-bit aligned
                              if address != Align(address, dbytes) then
                                  iswrite = FALSE;
                                  secondstage = FALSE;
                                  AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                              X[t]  = Mem[address + 0, 8, acctype];
                              X[t2] = Mem[address + 8, 8, acctype];
                      else
                          // load {acquire} {exclusive} single register
                          data = Mem[address, dbytes, acctype];
                          X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-513
ID121714                                     Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.77        LDAXR

                       Load-Acquire Exclusive Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register.
                       The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This
                       exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on
                       page B2-103. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on
                       page B2-88. For information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20           16 15 14            10 9             5 4            0
                           1 x 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)            Rn              Rt
                           size                    o2 L o1        Rs        o0       Rt2


                       32-bit variant

                       Applies when size = 10.

                       LDAXR <Wt>, [<Xn|SP>{,#0}]


                       64-bit variant

                       Applies when size = 11.

                       LDAXR <Xt>, [<Xn|SP>{,#0}]


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);    // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};



C6-514                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                    case c of
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                    if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                            when Constraint_NONE       rt_unknown = FALSE;       // store original value
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                         else
                            data = X[t];

                         if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                 // This atomic write will be rejected if it does not refer
                                 // to the same physical locations after address translation.
                                 Mem[address, dbytes, acctype] = data;
                                 status = ExclusiveMonitorsStatus();
                             X[s] = ZeroExtend(status, 32);
                         else
                            // store release register (atomic)
                             Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                         if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                             AArch64.SetExclusiveMonitors(address, dbytes);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-515
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;
                                           else
                                               X[t]  = data<elsize-1:0>;
                                               X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                           // 64-bit load exclusive pair (not atomic),
                                           // but must be 128-bit aligned
                                           if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                           X[t]  = Mem[address + 0, 8, acctype];
                                           X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-516                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.78     LDAXRB

                Load-Acquire Exclusive Register Byte loads a byte from memory, zero-extends it and writes it to a register. The
                memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive
                access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-103. The
                instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For
                information about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14            10 9             5 4             0
                   0 0 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)             Rn              Rt
                   size                     o2 L o1        Rs        o0       Rt2


                No offset variant

                LDAXRB <Wt>, [<Xn|SP>{,#0}]


                Decode for this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);     // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Assembler symbols

                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of
                          when Constraint_UNKNOWN      rt_unknown = TRUE;      // result is UNKNOWN
                          when Constraint_UNDEF        UnallocatedEncoding();
                          when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                     if s == t || (pair && s == t2) then
                          Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-517
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                                      when Constraint_NONE       rt_unknown = FALSE;       // store original value
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then



C6-518                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                          ID121714

                                                                                  C6 A64 Base Instruction Descriptions
                                                                                   C6.6 Alphabetical list of instructions



                              X[t]  = data<datasize-1:elsize>;
                              X[t2] = data<elsize-1:0>;
                         else
                              X[t]  = data<elsize-1:0>;
                              X[t2] = data<datasize-1:elsize>;
                      else // elsize == 64
                         // 64-bit load exclusive pair (not atomic),
                         // but must be 128-bit aligned
                         if address != Align(address, dbytes) then
                              iswrite = FALSE;
                              secondstage = FALSE;
                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                         X[t]   = Mem[address + 0, 8, acctype];
                         X[t2] = Mem[address + 8, 8, acctype];
                   else
                      // load {acquire} {exclusive} single register
                      data = Mem[address, dbytes, acctype];
                      X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e          Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-519
ID121714                                Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.79        LDAXRH

                       Load-Acquire Exclusive Register Halfword loads a halfword from memory, zero-extends it and writes it to a
                       register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access.
                       This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on
                       page B2-103. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on
                       page B2-88. For information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4            0
                           0 1 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)             Rn              Rt
                           size                     o2 L o1        Rs        o0       Rt2


                       No offset variant

                       LDAXRH <Wt>, [<Xn|SP>{,#0}]


                       Decode for this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of



C6-520                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                            when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                            when Constraint_NONE       rt_unknown = FALSE;       // store original value
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP         EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP         EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                        if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                // This atomic write will be rejected if it does not refer
                                // to the same physical locations after address translation.
                                 Mem[address, dbytes, acctype] = data;
                                status = ExclusiveMonitorsStatus();
                            X[s] = ZeroExtend(status, 32);
                        else
                            // store release register (atomic)
                            Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                        if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                            AArch64.SetExclusiveMonitors(address, dbytes);

                         if pair then
                            // load exclusive pair
                            assert excl;
                            if rt_unknown then
                                 // ConstrainedUNPREDICTABLE case
                                 X[t]  = bits(datasize) UNKNOWN;
                            elsif elsize == 32 then
                                 // 32-bit load exclusive pair (atomic)
                                 data = Mem[address, dbytes, acctype];
                                 if BigEndian() then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-521
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                              X[t]  = data<datasize-1:elsize>;
                                              X[t2] = data<elsize-1:0>;
                                         else
                                              X[t]  = data<elsize-1:0>;
                                              X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                         // 64-bit load exclusive pair (not atomic),
                                         // but must be 128-bit aligned
                                         if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                         X[t]   = Mem[address + 0, 8, acctype];
                                         X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-522                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                          ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.80     LDNP

                Load pair of registers, with non-temporal hint




                  31 30 29 28 27 26 25 24 23 22 21                     15 14         10 9              5 4               0
                  x 0 1 0 1 0 0 0 0 1                      imm7                Rt2              Rn              Rt
                  opc                          L


                32-bit variant

                Applies when opc = 00.

                LDNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]


                64-bit variant

                Applies when opc = 10.

                LDNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]


                Decode for all variants of this encoding

                 boolean wback   = FALSE;
                 boolean postindex = FALSE;


                Assembler symbols

                <Wt1>          Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                <Wt2>          Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                               field.

                <Xt1>          Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt2>          Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                               field.

                <Xn|SP>        Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>          For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
                               to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                               For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
                               to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2);
                 AccType acctype = AccType_STREAM;
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 if opc<0> == '1' then UnallocatedEncoding();
                 integer scale = 2 + UInt(opc<1>);
                 integer datasize = 8 << scale;
                 bits(64) offset = LSL(SignExtend(imm7, 64), scale);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-523
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(64) address;
                         bits(datasize) data1;
                         bits(datasize) data2;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown && t == n then
                                      data1 = bits(datasize) UNKNOWN;
                                   else
                                      data1 = X[t];
                                   if rt_unknown && t2 == n then
                                      data2 = bits(datasize) UNKNOWN;
                                   else
                                      data2 = X[t2];
                                   Mem[address + 0     , dbytes, acctype] = data1;
                                   Mem[address + dbytes, dbytes, acctype] = data2;

                              when MemOp_LOAD
                                   data1 = Mem[address + 0     , dbytes, acctype];
                                   data2 = Mem[address + dbytes, dbytes, acctype];
                                   if rt_unknown then
                                      data1 = bits(datasize) UNKNOWN;
                                      data2 = bits(datasize) UNKNOWN;
                                   X[t]  = data1;
                                   X[t2] = data2;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-524                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.            ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                   ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.81     LDP

                Load Pair of Registers calculates an address from a base register value and an immediate offset, loads two 32-bit
                words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory
                accesses see Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21                  15 14            10 9            5 4              0
                  x 0 1 0 1 0 0 0 1 1                    imm7                Rt2              Rn             Rt
                  opc                          L


                32-bit variant

                Applies when opc = 00.

                LDP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>


                64-bit variant

                Applies when opc = 10.

                LDP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>


                Decode for all variants of this encoding

                 boolean wback  = TRUE;
                 boolean postindex = TRUE;


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21                  15 14            10 9            5 4              0
                  x 0 1 0 1 0 0 1 1 1                    imm7                Rt2              Rn             Rt
                  opc                          L


                32-bit variant

                Applies when opc = 00.

                LDP <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!


                64-bit variant

                Applies when opc = 10.

                LDP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!


                Decode for all variants of this encoding

                 boolean wback  = TRUE;
                 boolean postindex = FALSE;


                Signed offset


                  31 30 29 28 27 26 25 24 23 22 21                  15 14            10 9            5 4              0
                  x 0 1 0 1 0 0 1 0 1                    imm7                Rt2              Rn             Rt
                  opc                          L




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-525
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       32-bit variant

                       Applies when opc = 00.

                       LDP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]


                       Decode for all variants of this encoding

                         boolean wback  = FALSE;
                         boolean postindex = FALSE;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDP on page J1-5406.


                       Assembler symbols

                       <Wt1>           Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt2>           Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                       field.

                       <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt2>           Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                       field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>           For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
                                       multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.

                                       For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
                                       the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                                       For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
                                       multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.

                                       For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
                                       the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         if L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();
                         boolean signed = (opc<0> != '0');
                         integer scale = 2 + UInt(opc<1>);
                         integer datasize = 8 << scale;
                         bits(64) offset = LSL(SignExtend(imm7, 64), scale);




C6-526                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation for all encodings

                 bits(64) address;
                 bits(datasize) data1;
                 bits(datasize) data2;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean wb_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;      // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;     // value stored is pre-writeback
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_LOAD && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                         if rt_unknown && t == n then
                            data1 = bits(datasize) UNKNOWN;
                         else
                            data1 = X[t];
                         if rt_unknown && t2 == n then
                            data2 = bits(datasize) UNKNOWN;
                         else
                            data2 = X[t2];
                         Mem[address + 0     , dbytes, acctype] = data1;
                         Mem[address + dbytes, dbytes, acctype] = data2;

                    when MemOp_LOAD
                         data1 = Mem[address + 0     , dbytes, acctype];
                         data2 = Mem[address + dbytes, dbytes, acctype];
                         if rt_unknown then
                            data1 = bits(datasize) UNKNOWN;
                            data2 = bits(datasize) UNKNOWN;
                         if signed then
                             X[t]  = SignExtend(data1, 64);
                             X[t2] = SignExtend(data2, 64);
                         else
                             X[t]  = data1;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-527
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                       X[t2] = data2;

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-528                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.82     LDPSW

                Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads
                two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory
                accesses see Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21                 15 14           10 9              5 4             0
                  0 1 1 0 1 0 0 0 1 1                   imm7                Rt2               Rn             Rt
                  opc                         L


                Post-index variant

                LDPSW <Xt1>, <Xt2>, [<Xn|SP>], #<imm>


                Decode for this encoding

                 boolean wback   = TRUE;
                 boolean postindex = TRUE;


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21                 15 14           10 9              5 4             0
                  0 1 1 0 1 0 0 1 1 1                   imm7                Rt2               Rn             Rt
                  opc                         L


                Pre-index variant

                LDPSW <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!


                Decode for this encoding

                 boolean wback   = TRUE;
                 boolean postindex = FALSE;


                Signed offset


                  31 30 29 28 27 26 25 24 23 22 21                 15 14           10 9              5 4             0
                  0 1 1 0 1 0 0 1 0 1                   imm7                Rt2               Rn             Rt
                  opc                         L


                Signed offset variant

                LDPSW <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]


                Decode for this encoding

                 boolean wback   = FALSE;
                 boolean postindex = FALSE;


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDPSW on page J1-5406.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-529
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Assembler symbols

                       <Xt1>            Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt2>            Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                        field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>            For the post-index and pre-index variant: is the signed immediate byte offset, a multiple of 4 in the
                                        range -256 to 252, encoded in the "imm7" field as <imm>/4.

                                        For the signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the
                                        range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         if L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();
                         boolean signed = (opc<0> != '0');
                         integer scale = 2 + UInt(opc<1>);
                         integer datasize = 8 << scale;
                         bits(64) offset = LSL(SignExtend(imm7, 64), scale);


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data1;
                         bits(datasize) data2;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean wb_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;             // writeback is suppressed
                                   when Constraint_UNKNOWN     wb_unknown = TRUE;        // writeback is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE        rt_unknown = FALSE;       // value stored is pre-writeback
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;        // value stored is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_LOAD && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;        // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];



C6-530                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                   ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown && t == n then
                            data1 = bits(datasize) UNKNOWN;
                        else
                            data1 = X[t];
                        if rt_unknown && t2 == n then
                            data2 = bits(datasize) UNKNOWN;
                        else
                            data2 = X[t2];
                         Mem[address + 0     , dbytes, acctype] = data1;
                         Mem[address + dbytes, dbytes, acctype] = data2;

                    when MemOp_LOAD
                        data1 = Mem[address + 0      , dbytes, acctype];
                        data2 = Mem[address + dbytes, dbytes, acctype];
                        if rt_unknown then
                            data1 = bits(datasize) UNKNOWN;
                            data2 = bits(datasize) UNKNOWN;
                        if signed then
                             X[t]  = SignExtend(data1, 64);
                             X[t2] = SignExtend(data2, 64);
                        else
                             X[t]  = data1;
                             X[t2] = data2;

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-531
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.83        LDR (immediate)

                       Load Register (immediate) calculates an address from a base register value and an immediate offset, loads a 32-bit
                       word or 64-bit doubleword from memory, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122. The Unsigned offset variant scales the immediate offset value by the
                       size of the value accessed before adding it to the base register value.


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9         5 4              0
                           1 x 1 1 1 0 0 0 0 1 0                        imm9               0 1      Rn             Rt
                           size                    opc


                       32-bit variant

                       Applies when size = 10.

                       LDR <Wt>, [<Xn|SP>], #<simm>


                       64-bit variant

                       Applies when size = 11.

                       LDR <Xt>, [<Xn|SP>], #<simm>


                       Decode for all variants of this encoding

                         boolean wback = TRUE;
                         boolean postindex = TRUE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Pre-index


                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9         5 4              0
                           1 x 1 1 1 0 0 0 0 1 0                        imm9               1 1      Rn             Rt
                           size                    opc


                       32-bit variant

                       Applies when size = 10.

                       LDR <Wt>, [<Xn|SP>, #<simm>]!


                       64-bit variant

                       Applies when size = 11.

                       LDR <Xt>, [<Xn|SP>, #<simm>]!


                       Decode for all variants of this encoding

                         boolean wback = TRUE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);




C6-532                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                               ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                   10 9              5 4             0
                  1 x 1 1 1 0 0 1 0 1                             imm12                       Rn                Rt
                  size                      opc


                32-bit variant

                Applies when size = 10.

                LDR <Wt>, [<Xn|SP>{, #<pimm>}]


                64-bit variant

                Applies when size = 11.

                LDR <Xt>, [<Xn|SP>{, #<pimm>}]


                Decode for all variants of this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDR (immediate) on page J1-5404.


                Assembler symbols

                <Wt>           Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt>           Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>        Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>         Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                <pimm>         For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
                               to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.

                               For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
                               to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                         UnallocatedEncoding();




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-533
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then



C6-534                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                       C6 A64 Base Instruction Descriptions
                                                                                        C6.6 Alphabetical list of instructions



                       SP[] = address;
                   else
                       X[n] = address;




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-535
ID121714                                     Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.84        LDR (literal)

                       Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory,
                       and writes it to a register. For information about memory accesses see Load/Store addressing modes on
                       page C1-122.




                           31 30 29 28 27 26 25 24 23                                                          5 4            0
                           0 x 0 1 1 0 0 0                                     imm19                                   Rt
                            opc


                       32-bit variant

                       Applies when opc = 00.

                       LDR <Wt>, <label>


                       64-bit variant

                       Applies when opc = 01.

                       LDR <Xt>, <label>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         MemOp memop = MemOp_LOAD;
                         boolean signed = FALSE;
                         integer size;
                         bits(64) offset;

                         case opc of
                              when '00'
                                   size = 4;
                              when '01'
                                   size = 8;
                              when '10'
                                   size = 4;
                                   signed = TRUE;
                              when '11'
                                   memop = MemOp_PREFETCH;

                         offset = SignExtend(imm19:'00', 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

                       <label>          Is the program label from which the data is to be loaded. Its offset from the address of this
                                        instruction, in the range +/-1MB, is encoded as "imm19" times 4.


                       Operation

                         bits(64) address = PC[] + offset;
                         bits(size*8) data;

                         case memop of
                              when MemOp_LOAD
                                   data = Mem[address, size, AccType_NORMAL];
                                   if signed then



C6-536                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                       C6 A64 Base Instruction Descriptions
                                                                                        C6.6 Alphabetical list of instructions



                          X[t] = SignExtend(data, 64);
                      else
                          X[t] = data;

                   when MemOp_PREFETCH
                      Prefetch(address, t<4:0>);




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-537
ID121714                                     Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.85        LDR (register)

                       Load Register (register) calculates an address from a base register value and an offset register value, loads a word
                       from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For
                       information about memory accesses, see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           1 x 1 1 1 0 0 0 0 1 1                   Rm          option   S 1 0           Rn              Rt
                           size                     opc


                       32-bit variant

                       Applies when size = 10.

                       LDR <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       64-bit variant

                       Applies when size = 11.

                       LDR <Xt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W           when option = x10

                                       X           when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW        when option = 010

                                       LSL         when option = 011

                                       SXTW        when option = 110

                                       SXTX        when option = 111




C6-538                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



                              It is RESERVED when:

                              ·      option = 00x.

                              ·      option = 10x.

                <amount>      For the 32-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #2          when S = 1

                              For the 64-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #3          when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                        when Constraint_WBSUPPRESS wback = FALSE;            // writeback is suppressed
                        when Constraint_UNKNOWN        wb_unknown = TRUE;    // writeback is UNKNOWN
                        when Constraint_UNDEF          UnallocatedEncoding();
                        when Constraint_NOP            EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-539
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-540                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.86     LDRB (immediate)

                Load Register Byte (immediate) calculates an address from a base register value and an immediate offset, loads a
                byte from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                           12 11 10 9            5 4             0
                  0 0 1 1 1 0 0 0 0 1 0                        imm9                 0 1        Rn            Rt
                  size                    opc


                Post-index variant

                LDRB <Wt>, [<Xn|SP>], #<simm>


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                           12 11 10 9            5 4             0
                  0 0 1 1 1 0 0 0 0 1 0                        imm9                 1 1        Rn            Rt
                  size                    opc


                Pre-index variant

                LDRB <Wt>, [<Xn|SP>, #<simm>]!


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                    10 9            5 4             0
                  0 0 1 1 1 0 0 1 0 1                            imm12                         Rn            Rt
                  size                    opc


                Unsigned offset variant

                LDRB <Wt>, [<Xn|SP>{, #<pimm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-541
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRB (immediate) on page J1-5404.


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded
                                        in the "imm12" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;           // writeback is suppressed
                                   when Constraint_UNKNOWN      wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();
                                   when Constraint_NOP          EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE         rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN      rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();



C6-542                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-543
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.87        LDRB (register)

                       Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a
                       byte from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           0 0 1 1 1 0 0 0 0 1 1                   Rm          option   S 1 0           Rn              Rt
                           size                      opc


                       32-bit variant

                       LDRB <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W            when option = x10

                                       X            when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW         when option = 010

                                       LSL          when option = 011

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <amount>        Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                                       "S" field. It can have the following values:

                                       [absent]     when S = 0

                                       #0           when S = 1



C6-544                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-545
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-546                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.88     LDRH (immediate)

                Load Register Halfword (immediate) calculates an address from a base register value and an immediate offset, loads
                a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                  0 1 1 1 1 0 0 0 0 1 0                       imm9                0 1          Rn            Rt
                   size                   opc


                Post-index variant

                LDRH <Wt>, [<Xn|SP>], #<simm>


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                  0 1 1 1 1 0 0 0 0 1 0                       imm9                1 1          Rn            Rt
                   size                   opc


                Pre-index variant

                LDRH <Wt>, [<Xn|SP>, #<simm>]!


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                    10 9            5 4             0
                  0 1 1 1 1 0 0 1 0 1                          imm12                           Rn            Rt
                   size                   opc


                Unsigned offset variant

                LDRH <Wt>, [<Xn|SP>{, #<pimm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-547
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRH (immediate) on page J1-5405.


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0
                                        and encoded in the "imm12" field as <pimm>/2.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;           // writeback is suppressed
                                   when Constraint_UNKNOWN      wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();
                                   when Constraint_NOP          EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE         rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN      rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();



C6-548                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-549
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.89        LDRH (register)

                       Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads
                       a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           0 1 1 1 1 0 0 0 0 1 1                   Rm          option   S 1 0           Rn              Rt
                           size                     opc


                       32-bit variant

                       LDRH <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRH (register) on page J1-5340.


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W           when option = x10

                                       X           when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW        when option = 010

                                       LSL         when option = 011

                                       SXTW        when option = 110

                                       SXTX        when option = 111

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.



C6-550                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                   ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                <amount>      Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                              "S" field. It can have the following values:

                              #0           when S = 0

                              #1           when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN      wb_unknown = TRUE;    // writeback is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE         rt_unknown = FALSE;   // value stored is original value
                         when Constraint_UNKNOWN      rt_unknown = TRUE;    // value stored is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-551
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-552                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.90     LDRSB (immediate)

                Load Register Signed Byte (immediate) calculates an address from a base register value and an immediate byte
                offset, loads a byte from memory, sign-extends it to either 32 or 64 bits, and writes it to a register. For information
                about memory accesses see Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9               5 4               0
                  0 0 1 1 1 0 0 0 1 x 0                        imm9                0 1         Rn                 Rt
                   size                      opc


                32-bit variant

                Applies when opc = 11.

                LDRSB <Wt>, [<Xn|SP>], #<simm>


                64-bit variant

                Applies when opc = 10.

                LDRSB <Xt>, [<Xn|SP>], #<simm>


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9               5 4               0
                  0 0 1 1 1 0 0 0 1 x 0                        imm9                1 1         Rn                 Rt
                   size                      opc


                32-bit variant

                Applies when opc = 11.

                LDRSB <Wt>, [<Xn|SP>, #<simm>]!


                64-bit variant

                Applies when opc = 10.

                LDRSB <Xt>, [<Xn|SP>, #<simm>]!


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-553
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Unsigned offset


                           31 30 29 28 27 26 25 24 23 22 21                                   10 9             5 4              0
                           0 0 1 1 1 0 0 1 1 x                           imm12                          Rn              Rt
                           size                      opc


                       32-bit variant

                       Applies when opc = 11.

                       LDRSB <Wt>, [<Xn|SP>{, #<pimm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDRSB <Xt>, [<Xn|SP>{, #<pimm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRSB (immediate) on page J1-5405.


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded
                                        in the "imm12" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;



C6-554                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation for all encodings

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                         else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-555
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.91        LDRSB (register)

                       Load Register Signed Byte (register) calculates an address from a base register value and an offset register value,
                       loads a byte from memory, sign-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           0 0 1 1 1 0 0 0 1 x 1                   Rm          option   S 1 0           Rn              Rt
                           size                     opc


                       32-bit variant

                       Applies when opc = 11.

                       LDRSB <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       64-bit variant

                       Applies when opc = 10.

                       LDRSB <Xt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W           when option = x10

                                       X           when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW        when option = 010

                                       LSL         when option = 011

                                       SXTW        when option = 110

                                       SXTX        when option = 111




C6-556                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                   ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                              It is RESERVED when:

                              ·      option = 00x.

                              ·      option = 10x.

                <amount>      Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                              "S" field. It can have the following values:

                              [absent]     when S = 0

                              #0           when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN      wb_unknown = TRUE;    // writeback is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE         rt_unknown = FALSE;   // value stored is original value
                         when Constraint_UNKNOWN      rt_unknown = TRUE;    // value stored is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if n == 31 then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-557
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-558                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.92     LDRSH (immediate)

                Load Register Signed Halfword (immediate) calculates an address from a base register value and an immediate
                offset, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory
                accesses see Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9               5 4             0
                  0 1 1 1 1 0 0 0 1 x 0                       imm9                 0 1         Rn               Rt
                   size                      opc


                32-bit variant

                Applies when opc = 11.

                LDRSH <Wt>, [<Xn|SP>], #<simm>


                64-bit variant

                Applies when opc = 10.

                LDRSH <Xt>, [<Xn|SP>], #<simm>


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9               5 4             0
                  0 1 1 1 1 0 0 0 1 x 0                       imm9                 1 1         Rn               Rt
                   size                      opc


                32-bit variant

                Applies when opc = 11.

                LDRSH <Wt>, [<Xn|SP>, #<simm>]!


                64-bit variant

                Applies when opc = 10.

                LDRSH <Xt>, [<Xn|SP>, #<simm>]!


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-559
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Unsigned offset


                           31 30 29 28 27 26 25 24 23 22 21                                   10 9               5 4            0
                           0 1 1 1 1 0 0 1 1 x                           imm12                           Rn               Rt
                           size                      opc


                       32-bit variant

                       Applies when opc = 11.

                       LDRSH <Wt>, [<Xn|SP>{, #<pimm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDRSH <Xt>, [<Xn|SP>{, #<pimm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRSH (immediate) on page J1-5405.


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0
                                        and encoded in the "imm12" field as <pimm>/2.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;



C6-560                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation for all encodings

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                         else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-561
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.93        LDRSH (register)

                       Load Register Signed Halfword (register) calculates an address from a base register value and an offset register
                       value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory
                       accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           0 1 1 1 1 0 0 0 1 x 1                   Rm          option   S 1 0           Rn              Rt
                           size                     opc


                       32-bit variant

                       Applies when opc = 11.

                       LDRSH <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       64-bit variant

                       Applies when opc = 10.

                       LDRSH <Xt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W           when option = x10

                                       X           when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW        when option = 010

                                       LSL         when option = 011

                                       SXTW        when option = 110

                                       SXTX        when option = 111




C6-562                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                                   ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                              It is RESERVED when:

                              ·      option = 00x.

                              ·      option = 10x.

                <amount>      Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                              "S" field. It can have the following values:

                              #0           when S = 0

                              #1           when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN      wb_unknown = TRUE;    // writeback is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE         rt_unknown = FALSE;   // value stored is original value
                         when Constraint_UNKNOWN      rt_unknown = TRUE;    // value stored is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if n == 31 then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-563
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-564                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.94     LDRSW (immediate)

                Load Register Signed Word (immediate) calculates an address from a base register value and an immediate offset,
                loads a word from memory, sign-extends it, and writes it to a register. For information about memory accesses see
                Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9             5 4              0
                  1 0 1 1 1 0 0 0 1 0 0                       imm9                0 1          Rn             Rt
                  size                    opc


                Post-index variant

                LDRSW <Xt>, [<Xn|SP>], #<simm>


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9             5 4              0
                  1 0 1 1 1 0 0 0 1 0 0                       imm9                1 1          Rn             Rt
                  size                    opc


                Pre-index variant

                LDRSW <Xt>, [<Xn|SP>, #<simm>]!


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                   10 9             5 4              0
                  1 0 1 1 1 0 0 1 1 0                          imm12                           Rn             Rt
                  size                    opc


                Unsigned offset variant

                LDRSW <Xt>, [<Xn|SP>{, #<pimm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-565
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDRSW (immediate) on page J1-5406.


                       Assembler symbols

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to
                                        0 and encoded in the "imm12" field as <pimm>/4.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;           // writeback is suppressed
                                   when Constraint_UNKNOWN      wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();
                                   when Constraint_NOP          EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE         rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN      rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();



C6-566                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-567
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.95        LDRSW (literal)

                       Load Register Signed Word (literal) calculates an address from the PC value and an immediate offset, loads a word
                       from memory, and writes it to a register. For information about memory accesses Load/Store addressing modes on
                       page C1-122.




                           31 30 29 28 27 26 25 24 23                                                          5 4            0
                           1 0 0 1 1 0 0 0                                     imm19                                   Rt
                            opc


                       Literal variant

                       LDRSW <Xt>, <label>


                       Decode for this encoding

                         integer t = UInt(Rt);
                         MemOp memop = MemOp_LOAD;
                         boolean signed = FALSE;
                         integer size;
                         bits(64) offset;

                         case opc of
                              when '00'
                                   size = 4;
                              when '01'
                                   size = 8;
                              when '10'
                                   size = 4;
                                   signed = TRUE;
                              when '11'
                                   memop = MemOp_PREFETCH;

                         offset = SignExtend(imm19:'00', 64);


                       Assembler symbols

                       <Xt>             Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

                       <label>          Is the program label from which the data is to be loaded. Its offset from the address of this
                                        instruction, in the range +/-1MB, is encoded as "imm19" times 4.


                       Operation

                         bits(64) address = PC[] + offset;
                         bits(size*8) data;

                         case memop of
                              when MemOp_LOAD
                                   data = Mem[address, size, AccType_NORMAL];
                                   if signed then
                                       X[t] = SignExtend(data, 64);
                                   else
                                       X[t] = data;

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);




C6-568                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.96     LDRSW (register)

                Load Register Signed Word (register) calculates an address from a base register value and an offset register value,
                loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value
                can be shifted left by 0 or 2 bits. For information about memory accesses see Load/Store addressing modes on
                page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20               16 15    13 12 11 10 9              5 4               0
                  1 0 1 1 1 0 0 0 1 0 1                      Rm         option   S 1 0           Rn              Rt
                  size                        opc


                64-bit variant

                LDRSW <Xt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                 ExtendType extend_type = DecodeRegExtend(option);
                 integer shift = if S == '1' then scale else 0;


                Assembler symbols

                <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                W            when option = x10

                                X            when option = x11

                                It is RESERVED when:

                                ·      option = 00x.

                                ·      option = 10x.

                <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                field.

                <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                the following values:

                                UXTW         when option = 010

                                LSL          when option = 011

                                SXTW         when option = 110

                                SXTX         when option = 111

                                It is RESERVED when:

                                ·      option = 00x.

                                ·      option = 10x.

                <amount>        Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                                "S" field. It can have the following values:

                                #0           when S = 0




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-569
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                        #2         when S = 1


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer m = UInt(Rm);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation

                         bits(64) offset = ExtendReg(m, extend_type, shift);
                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of



C6-570                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                        Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                        SP[] = address;
                    else
                        X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-571
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.97        LDTR

                       Load Register (unprivileged) calculates an address from a base register and an immediate byte offset, loads a word
                       or doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           1 x 1 1 1 0 0 0 0 1 0                        imm9               1 0         Rn               Rt
                           size                      opc


                       32-bit variant

                       Applies when size = 10.

                       LDTR <Wt>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when size = 11.

                       LDTR <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_UNPRIV;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();



C6-572                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-573
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.98        LDTRB

                       Load Register Byte (unprivileged) calculates an address from a base register and an immediate byte offset, loads a
                       byte from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 0 1 1 1 0 0 0 0 1 0                        imm9               1 0         Rn               Rt
                           size                      opc


                       Unscaled offset variant

                       LDTRB <Wt>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_UNPRIV;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;




C6-574                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-575
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.99        LDTRH

                       Load Register Halfword (unprivileged) calculates an address from a base register value and an immediate offset,
                       loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses
                       see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 1 1 1 1 0 0 0 0 1 0                        imm9               1 0         Rn               Rt
                           size                      opc


                       Unscaled offset variant

                       LDTRH <Wt>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_UNPRIV;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;




C6-576                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-577
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.100       LDTRSB

                       Load Register Signed Byte (unprivileged) calculates an address from a base register and an immediate byte offset,
                       loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses
                       see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 0 1 1 1 0 0 0 1 x 0                        imm9                1 0         Rn              Rt
                           size                      opc


                       32-bit variant

                       Applies when opc = 11.

                       LDTRSB <Wt>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDTRSB <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_UNPRIV;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();



C6-578                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-579
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.101       LDTRSH

                       Load Register Signed Halfword (unprivileged) calculates an address from a base register and an immediate offset,
                       loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses
                       see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 1 1 1 1 0 0 0 1 x 0                        imm9                1 0         Rn              Rt
                           size                      opc


                       32-bit variant

                       Applies when opc = 11.

                       LDTRSH <Wt>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDTRSH <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_UNPRIV;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();



C6-580                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-581
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.102       LDTRSW

                       Load Register Signed Word (unprivileged) calculates an address from a base register and an immediate offset, loads
                       a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           1 0 1 1 1 0 0 0 1 0 0                        imm9               1 0         Rn               Rt
                           size                      opc


                       Unscaled offset variant

                       LDTRSW <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_UNPRIV;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;




C6-582                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-583
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.103       LDUR

                       Load Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or
                       64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses
                       see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           1 x 1 1 1 0 0 0 0 1 0                        imm9               0 0         Rn               Rt
                           size                      opc


                       32-bit variant

                       Applies when size = 10.

                       LDUR <Wt>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when size = 11.

                       LDUR <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;



C6-584                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                         else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-585
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.104       LDURB

                       Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from
                       memory, zero-extends it, and writes it to a register. For information about memory accesses see Load/Store
                       addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 0 1 1 1 0 0 0 0 1 0                        imm9               0 0         Rn               Rt
                           size                      opc


                       Unscaled offset variant

                       LDURB <Wt>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;




C6-586                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-587
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.105       LDURH

                       Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a
                       halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 1 1 1 1 0 0 0 0 1 0                        imm9               0 0         Rn               Rt
                           size                      opc


                       Unscaled offset variant

                       LDURH <Wt>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;




C6-588                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-589
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.106       LDURSB

                       Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a
                       signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 0 1 1 1 0 0 0 1 x 0                        imm9               0 0         Rn               Rt
                           size                      opc


                       32-bit variant

                       Applies when opc = 11.

                       LDURSB <Wt>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDURSB <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;



C6-590                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                         else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-591
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.107       LDURSH

                       Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads
                       a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses
                       see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           0 1 1 1 1 0 0 0 1 x 0                        imm9               0 0         Rn               Rt
                           size                      opc


                       32-bit variant

                       Applies when opc = 11.

                       LDURSH <Wt>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when opc = 10.

                       LDURSH <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;



C6-592                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                         else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-593
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.108       LDURSW

                       Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a
                       signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                           1 0 1 1 1 0 0 0 1 0 0                        imm9               0 0         Rn               Rt
                           size                      opc


                       Unscaled offset variant

                       LDURSW <Xt>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                        in the "imm9" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;




C6-594                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-595
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.109       LDXP

                       Load Exclusive Pair of Registers loads two 32-bit words or two 64-bit doublewords from memory, and writes them
                       to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at
                       doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for
                       each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive
                       access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores
                       on page B2-103. For information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14           10 9              5 4             0
                           1 x 0 0 1 0 0 0 0 1 1 (1) (1) (1) (1) (1) 0                Rt2               Rn             Rt
                           size                    o2 L o1          Rs        o0


                       32-bit variant

                       Applies when size = 10.

                       LDXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]


                       64-bit variant

                       Applies when size = 11.

                       LDXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly LDXP on page J1-5407.


                       Assembler symbols

                       <Wt1>           Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt2>           Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                       field.

                       <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt2>           Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                       field.




C6-596                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_UNKNOWN     rt_unknown = TRUE;     // result is UNKNOWN
                         when Constraint_UNDEF       UnallocatedEncoding();
                         when Constraint_NOP         EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                    if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN      rt_unknown = TRUE;      // store UNKNOWN value
                            when Constraint_NONE         rt_unknown = FALSE;     // store original value
                            when Constraint_UNDEF        UnallocatedEncoding();
                            when Constraint_NOP          EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN      rn_unknown = TRUE;      // address is UNKNOWN
                            when Constraint_NONE         rn_unknown = FALSE;     // address is original base
                            when Constraint_UNDEF        UnallocatedEncoding();
                            when Constraint_NOP          EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                         if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                         elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                         else
                            data = X[t];

                         if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                 // This atomic write will be rejected if it does not refer
                                 // to the same physical locations after address translation.
                                 Mem[address, dbytes, acctype] = data;
                                 status = ExclusiveMonitorsStatus();



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-597
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;
                                           else
                                               X[t]  = data<elsize-1:0>;
                                               X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                           // 64-bit load exclusive pair (not atomic),
                                           // but must be 128-bit aligned
                                           if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                           X[t]  = Mem[address + 0, 8, acctype];
                                           X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                       X[t] = ZeroExtend(data, regsize);




C6-598                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.110    LDXR

                Load Exclusive Register loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The
                memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive
                access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-103. For
                information about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4             0
                   1 x 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)            Rn              Rt
                   size                    o2 L o1        Rs        o0       Rt2


                32-bit variant

                Applies when size = 10.

                LDXR <Wt>, [<Xn|SP>{,#0}]


                64-bit variant

                Applies when size = 11.

                LDXR <Xt>, [<Xn|SP>{,#0}]


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);    // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Assembler symbols

                <Wt>           Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt>           Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>        Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-599
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                                      when Constraint_NONE       rt_unknown = FALSE;       // store original value
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP        EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then



C6-600                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                          ID121714

                                                                                  C6 A64 Base Instruction Descriptions
                                                                                   C6.6 Alphabetical list of instructions



                      // load exclusive pair
                      assert excl;
                      if rt_unknown then
                         // ConstrainedUNPREDICTABLE case
                         X[t]   = bits(datasize) UNKNOWN;
                      elsif elsize == 32 then
                         // 32-bit load exclusive pair (atomic)
                         data = Mem[address, dbytes, acctype];
                         if BigEndian() then
                              X[t]  = data<datasize-1:elsize>;
                              X[t2] = data<elsize-1:0>;
                         else
                              X[t]  = data<elsize-1:0>;
                              X[t2] = data<datasize-1:elsize>;
                      else // elsize == 64
                         // 64-bit load exclusive pair (not atomic),
                         // but must be 128-bit aligned
                         if address != Align(address, dbytes) then
                              iswrite = FALSE;
                              secondstage = FALSE;
                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                         X[t]   = Mem[address + 0, 8, acctype];
                         X[t2] = Mem[address + 8, 8, acctype];
                   else
                      // load {acquire} {exclusive} single register
                      data = Mem[address, dbytes, acctype];
                      X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e          Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-601
ID121714                                Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.111       LDXRB

                       Load Exclusive Register Byte loads a byte from memory, zero-extends it and writes it to a register. The memory
                       access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access
                       mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-103. For
                       information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4            0
                           0 0 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)             Rn              Rt
                           size                     o2 L o1        Rs        o0       Rt2


                       No offset variant

                       LDXRB <Wt>, [<Xn|SP>{,#0}]


                       Decode for this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN      rt_unknown = TRUE;       // store UNKNOWN value



C6-602                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                            when Constraint_NONE       rt_unknown = FALSE;       // store original value
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                        if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                // This atomic write will be rejected if it does not refer
                                // to the same physical locations after address translation.
                                Mem[address, dbytes, acctype] = data;
                                status = ExclusiveMonitorsStatus();
                            X[s] = ZeroExtend(status, 32);
                        else
                            // store release register (atomic)
                            Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                        if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                            AArch64.SetExclusiveMonitors(address, dbytes);

                        if pair then
                            // load exclusive pair
                            assert excl;
                            if rt_unknown then
                                // ConstrainedUNPREDICTABLE case
                                X[t]   = bits(datasize) UNKNOWN;
                            elsif elsize == 32 then
                                // 32-bit load exclusive pair (atomic)
                                data = Mem[address, dbytes, acctype];
                                if BigEndian() then
                                     X[t]  = data<datasize-1:elsize>;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-603
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                              X[t2] = data<elsize-1:0>;
                                         else
                                              X[t]  = data<elsize-1:0>;
                                              X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                         // 64-bit load exclusive pair (not atomic),
                                         // but must be 128-bit aligned
                                         if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                         X[t]   = Mem[address + 0, 8, acctype];
                                         X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-604                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                          ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.112    LDXRH

                Load Exclusive Register Halfword loads a halfword from memory, zero-extends it and writes it to a register. The
                memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive
                access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-103. For
                information about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4             0
                   0 1 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)            Rn              Rt
                   size                    o2 L o1        Rs        o0       Rt2


                No offset variant

                LDXRH <Wt>, [<Xn|SP>{,#0}]


                Decode for this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);    // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Assembler symbols

                <Wt>           Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>        Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of
                         when Constraint_UNKNOWN      rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                     if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                         case c of
                             when Constraint_UNKNOWN      rt_unknown = TRUE;       // store UNKNOWN value



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-605
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      when Constraint_NONE       rt_unknown = FALSE;       // store original value
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;



C6-606                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                          ID121714

                                                                                  C6 A64 Base Instruction Descriptions
                                                                                   C6.6 Alphabetical list of instructions



                              X[t2] = data<elsize-1:0>;
                         else
                              X[t]  = data<elsize-1:0>;
                              X[t2] = data<datasize-1:elsize>;
                      else // elsize == 64
                         // 64-bit load exclusive pair (not atomic),
                         // but must be 128-bit aligned
                         if address != Align(address, dbytes) then
                              iswrite = FALSE;
                              secondstage = FALSE;
                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                         X[t]   = Mem[address + 0, 8, acctype];
                         X[t2] = Mem[address + 8, 8, acctype];
                   else
                      // load {acquire} {exclusive} single register
                      data = Mem[address, dbytes, acctype];
                      X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e          Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-607
ID121714                                Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.113       LSL (register)

                       Logical shift left (register): Rd = LSL(Rn, Rm)

                       This instruction is an alias of the LSLV instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of LSLV.

                       ·       The description of LSLV gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9             5 4              0
                           sf 0 0 1 1 0 1 0 1 1 0                  Rm          0 0 1 0 0 0             Rn              Rd
                                                                                          op2


                       32-bit variant

                       Applies when sf = 0.

                       LSL <Wd>, <Wn>, <Wm>

                       is equivalent to

                       LSLV <Wd>, <Wn>, <Wm>

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       LSL <Xd>, <Xn>, <Xm>

                       is equivalent to

                       LSLV <Xd>, <Xn>, <Xm>

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                       31 in its bottom 5 bits, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                       63 in its bottom 6 bits, encoded in the "Rm" field.


                       Operation

                       The description of LSLV gives the operational pseudocode for this instruction.




C6-608                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                               ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.114    LSL (immediate)

                Logical shift left (immediate): Rd = LSL(Rn, shift)

                This instruction is an alias of the UBFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of UBFM.

                ·      The description of UBFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                   16 15             10 9            5 4              0
                   sf 1 0 1 0 0 1 1 0 N                   immr             !=x11111              Rn            Rd
                      opc                                                     imms


                32-bit variant

                Applies when sf = 0 && N = 0 && imms != 011111.

                LSL <Wd>, <Wn>, #<shift>

                is equivalent to

                UBFM <Wd>, <Wn>, #(-<shift> MOD 32), #(31-<shift>)

                and is the preferred disassembly when imms + 1 == immr.

                64-bit variant

                Applies when sf = 1 && N = 1 && imms != 111111.

                LSL <Xd>, <Xn>, #<shift>

                is equivalent to

                UBFM <Xd>, <Xn>, #(-<shift> MOD 64), #(63-<shift>)

                and is the preferred disassembly when imms + 1 == immr.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <shift>         For the 32-bit variant: is the shift amount, in the range 0 to 31.

                                For the 64-bit variant: is the shift amount, in the range 0 to 63.


                Operation

                The description of UBFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-609
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.115       LSLV

                       Logical shift left variable: Rd = LSL(Rn, Rm)

                       This instruction is used by the alias LSL (register). The alias is always the preferred disassembly.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4            0
                           sf 0 0 1 1 0 1 0 1 1 0                  Rm         0 0 1 0 0 0              Rn              Rd
                                                                                            op2


                       32-bit variant

                       Applies when sf = 0.

                       LSLV <Wd>, <Wn>, <Wm>


                       64-bit variant

                       Applies when sf = 1.

                       LSLV <Xd>, <Xn>, <Xm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         ShiftType shift_type = DecodeShift(op2);


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                       31 in its bottom 5 bits, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                       63 in its bottom 6 bits, encoded in the "Rm" field.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand2 = X[m];

                         result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
                         X[d] = result;




C6-610                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.116    LSR (register)

                Logical shift right (register): Rd = LSR(Rn, Rm)

                This instruction is an alias of the LSRV instruction. This means that:

                ·      The encodings in this description are named to match the encodings of LSRV.

                ·      The description of LSRV gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9              5 4              0
                   sf 0 0 1 1 0 1 0 1 1 0                   Rm         0 0 1 0 0 1              Rn              Rd
                                                                                   op2


                32-bit variant

                Applies when sf = 0.

                LSR <Wd>, <Wn>, <Wm>

                is equivalent to

                LSRV <Wd>, <Wn>, <Wm>

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                LSR <Xd>, <Xn>, <Xm>

                is equivalent to

                LSRV <Xd>, <Xn>, <Xm>

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                31 in its bottom 5 bits, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                63 in its bottom 6 bits, encoded in the "Rm" field.


                Operation

                The description of LSRV gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-611
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.117       LSR (immediate)

                       Logical shift right (immediate): Rd = LSR(Rn, shift)

                       This instruction is an alias of the UBFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of UBFM.

                       ·       The description of UBFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21                 16 15             10 9             5 4            0
                           sf 1 0 1 0 0 1 1 0 N                  immr          x 1 1 1 1 1              Rn              Rd
                               opc                                                   imms


                       32-bit variant

                       Applies when sf = 0 && N = 0 && imms = 011111.

                       LSR <Wd>, <Wn>, #<shift>

                       is equivalent to

                       UBFM <Wd>, <Wn>, #<shift>, #31

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1 && N = 1 && imms = 111111.

                       LSR <Xd>, <Xn>, #<shift>

                       is equivalent to

                       UBFM <Xd>, <Xn>, #<shift>, #63

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <shift>         For the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the "immr" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the "immr" field.


                       Operation

                       The description of UBFM gives the operational pseudocode for this instruction.




C6-612                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.118    LSRV

                Logical shift right variable: Rd = LSR(Rn, Rm)

                This instruction is used by the alias LSR (register). The alias is always the preferred disassembly.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9               5 4             0
                  sf 0 0 1 1 0 1 0 1 1 0                    Rm         0 0 1 0 0 1              Rn              Rd
                                                                                     op2


                32-bit variant

                Applies when sf = 0.

                LSRV <Wd>, <Wn>, <Wm>


                64-bit variant

                Applies when sf = 1.

                LSRV <Xd>, <Xn>, <Xm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 ShiftType shift_type = DecodeShift(op2);


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                31 in its bottom 5 bits, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                63 in its bottom 6 bits, encoded in the "Rm" field.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand2 = X[m];

                 result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
                 X[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-613
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.119       MADD

                       Multiply-add: Rd = Ra + Rn * Rm

                       This instruction is used by the alias MUL. See the Alias conditions table for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9              5 4             0
                           sf 0 0 1 1 0 1 1 0 0 0                  Rm         0       Ra               Rn             Rd
                                                                              o0


                       32-bit variant

                       Applies when sf = 0.

                       MADD <Wd>, <Wn>, <Wm>, <Wa>


                       64-bit variant

                       Applies when sf = 1.

                       MADD <Xd>, <Xn>, <Xm>, <Xa>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);
                         integer destsize = if sf == '1' then 64 else 32;
                         integer datasize = destsize;
                         boolean sub_op = (o0 == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            MUL                       Ra == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Wa>            Is the 32-bit name of the third general-purpose source register holding the addend, encoded in the
                                       "Ra" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.




C6-614                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



                <Xa>          Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the
                              "Ra" field.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];
                 bits(destsize) operand3 = X[a];

                 integer result;

                 if sub_op then
                    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));
                 else
                    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));

                 X[d] = result<destsize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-615
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.120       MNEG

                       Multiply-negate: Rd = -(Rn * Rm)

                       This instruction is an alias of the MSUB instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of MSUB.

                       ·       The description of MSUB gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9             5 4              0
                           sf 0 0 1 1 0 1 1 0 0 0                  Rm         1 1 1 1 1 1              Rn             Rd
                                                                              o0      Ra


                       32-bit variant

                       Applies when sf = 0.

                       MNEG <Wd>, <Wn>, <Wm>

                       is equivalent to

                       MSUB <Wd>, <Wn>, <Wm>, WZR

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       MNEG <Xd>, <Xn>, <Xm>

                       is equivalent to

                       MSUB <Xd>, <Xn>, <Xm>, XZR

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.


                       Operation

                       The description of MSUB gives the operational pseudocode for this instruction.




C6-616                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.121    MOV (to/from SP)

                Move between register and stack pointer: Rd = Rn

                This instruction is an alias of the ADD (immediate) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ADD (immediate).

                ·      The description of ADD (immediate) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                                   10 9              5 4              0
                   sf 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0                                 Rn              Rd
                     op S                     shift               imm12


                32-bit variant

                Applies when sf = 0.

                MOV <Wd|WSP>, <Wn|WSP>

                is equivalent to

                ADD <Wd|WSP>, <Wn|WSP>, #0

                and is the preferred disassembly when (Rd == '11111' || Rn == '11111').

                64-bit variant

                Applies when sf = 1.

                MOV <Xd|SP>, <Xn|SP>

                is equivalent to

                ADD <Xd|SP>, <Xn|SP>, #0

                and is the preferred disassembly when (Rd == '11111' || Rn == '11111').


                Assembler symbols

                <Wd|WSP>        Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                field.

                <Wn|WSP>        Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <Xd|SP>         Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                field.

                <Xn|SP>         Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.


                Operation

                The description of ADD (immediate) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-617
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.122       MOV (inverted wide immediate)

                       Move inverted 16-bit immediate to register: Rd = imm

                       This instruction is an alias of the MOVN instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of MOVN.

                       ·       The description of MOVN gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20                                                5 4              0
                           sf 0 0 1 0 0 1 0 1            hw                       imm16                                Rd
                               opc


                       32-bit variant

                       Applies when sf = 0.

                       MOV <Wd>, #<imm>

                       is equivalent to

                       MOVN <Wd>, #<imm16>, LSL #<shift>

                       and is the preferred disassembly when ! (IsZero(imm16) && hw != '00') && ! IsOnes(imm16).

                       64-bit variant

                       Applies when sf = 1.

                       MOV <Xd>, #<imm>

                       is equivalent to

                       MOVN <Xd>, #<imm16>, LSL #<shift>

                       and is the preferred disassembly when ! (IsZero(imm16) && hw != '00').


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <imm>           For the 32-bit variant: is a 32-bit immediate, the bitwise inverse of which can be encoded in
                                       "imm16:hw", but excluding 0xffff0000 and 0x0000ffff

                                       For the 64-bit variant: is a 64-bit immediate, the bitwise inverse of which can be encoded in
                                       "imm16:hw".

                       <shift>         For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
                                       16, encoded in the "hw" field as <shift>/16.

                                       For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
                                       32 or 48, encoded in the "hw" field as <shift>/16.


                       Operation

                       The description of MOVN gives the operational pseudocode for this instruction.




C6-618                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.123    MOV (wide immediate)

                Move 16-bit immediate to register: Rd = imm

                This instruction is an alias of the MOVZ instruction. This means that:

                ·      The encodings in this description are named to match the encodings of MOVZ.

                ·      The description of MOVZ gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20                                                 5 4               0
                   sf 1 0 1 0 0 1 0 1             hw                       imm16                                Rd
                      opc


                32-bit variant

                Applies when sf = 0.

                MOV <Wd>, #<imm>

                is equivalent to

                MOVZ <Wd>, #<imm16>, LSL #<shift>

                and is the preferred disassembly when ! (IsZero(imm16) && hw != '00').

                64-bit variant

                Applies when sf = 1.

                MOV <Xd>, #<imm>

                is equivalent to

                MOVZ <Xd>, #<imm16>, LSL #<shift>

                and is the preferred disassembly when ! (IsZero(imm16) && hw != '00').


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <imm>           For the 32-bit variant: is a 32-bit immediate which can be encoded in "imm16:hw".

                                For the 64-bit variant: is a 64-bit immediate which can be encoded in "imm16:hw".

                <shift>         For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
                                16, encoded in the "hw" field as <shift>/16.

                                For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
                                32 or 48, encoded in the "hw" field as <shift>/16.


                Operation

                The description of MOVZ gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-619
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.124       MOV (bitmask immediate)

                       Move bitmask immediate to register: Rd = imm

                       This instruction is an alias of the ORR (immediate) instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of ORR (immediate).

                       ·       The description of ORR (immediate) gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21               16 15             10 9             5 4             0
                           sf 0 1 1 0 0 1 0 0 N                 immr               imms         1 1 1 1 1              Rd
                               opc                                                                    Rn


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       MOV <Wd|WSP>, #<imm>

                       is equivalent to

                       ORR <Wd|WSP>, WZR, #<imm>

                       and is the preferred disassembly when ! MoveWidePreferred(sf, N, imms, immr).

                       64-bit variant

                       Applies when sf = 1.

                       MOV <Xd|SP>, #<imm>

                       is equivalent to

                       ORR <Xd|SP>, XZR, #<imm>

                       and is the preferred disassembly when ! MoveWidePreferred(sf, N, imms, immr).


                       Assembler symbols

                       <Wd|WSP>        Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Xd|SP>         Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <imm>           Is the bitmask immediate, encoded in "N:imms:immr", but excluding values which could be
                                       encoded by MOVZ or MOVN.


                       Operation

                       The description of ORR (immediate) gives the operational pseudocode for this instruction.




C6-620                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.125    MOV (register)

                Move register to register: Rd = Rm

                This instruction is an alias of the ORR (shifted register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ORR (shifted register).

                ·      The description of ORR (shifted register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15                10 9            5 4            0
                   sf 0 1 0 1 0 1 0 0 0 0                  Rm          0 0 0 0 0 0 1 1 1 1 1                   Rd
                      opc                     shift N                        imm6               Rn


                32-bit variant

                Applies when sf = 0.

                MOV <Wd>, <Wm>

                is equivalent to

                ORR <Wd>, WZR, <Wm>

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                MOV <Xd>, <Xm>

                is equivalent to

                ORR <Xd>, XZR, <Xm>

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wm>            Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xm>            Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.


                Operation

                The description of ORR (shifted register) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-621
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.126       MOVK

                       Move 16-bit immediate into register, keeping other bits unchanged: Rd<shift+15:shift> = imm16




                           31 30 29 28 27 26 25 24 23 22 21 20                                               5 4               0
                           sf 1 1 1 0 0 1 0 1           hw                        imm16                                Rd
                               opc


                       32-bit variant

                       Applies when sf = 0.

                       MOVK <Wd>, #<imm>{, LSL #<shift>}


                       64-bit variant

                       Applies when sf = 1.

                       MOVK <Xd>, #<imm>{, LSL #<shift>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer datasize = if sf == '1' then 64 else 32;
                         bits(16) imm = imm16;
                         integer pos;
                         MoveWideOp opcode;

                         case opc of
                              when '00' opcode = MoveWideOp_N;
                              when '10' opcode = MoveWideOp_Z;
                              when '11' opcode = MoveWideOp_K;
                              otherwise UnallocatedEncoding();

                         if sf == '0' && hw<1> == '1' then UnallocatedEncoding();
                         pos = UInt(hw:'0000');


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <imm>           Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

                       <shift>         For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
                                       16, encoded in the "hw" field as <shift>/16.

                                       For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
                                       32 or 48, encoded in the "hw" field as <shift>/16.


                       Operation

                         bits(datasize) result;

                         if opcode == MoveWideOp_K then
                              result = X[d];
                         else
                              result = Zeros();

                         result<pos+15:pos> = imm;




C6-622                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                 if opcode == MoveWideOp_N then
                    result = NOT(result);
                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-623
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.127       MOVN

                       Move inverse of shifted 16-bit immediate to register: Rd = NOT (LSL (imm16, shift))

                       This instruction is used by the alias MOV (inverted wide immediate). See the Alias conditions table for details of
                       when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20                                              5 4              0
                           sf 0 0 1 0 0 1 0 1           hw                        imm16                               Rd
                               opc


                       32-bit variant

                       Applies when sf = 0.

                       MOVN <Wd>, #<imm>{, LSL #<shift>}


                       64-bit variant

                       Applies when sf = 1.

                       MOVN <Xd>, #<imm>{, LSL #<shift>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer datasize = if sf == '1' then 64 else 32;
                         bits(16) imm = imm16;
                         integer pos;
                         MoveWideOp opcode;

                         case opc of
                              when '00' opcode = MoveWideOp_N;
                              when '10' opcode = MoveWideOp_Z;
                              when '11' opcode = MoveWideOp_K;
                              otherwise UnallocatedEncoding();

                         if sf == '0' && hw<1> == '1' then UnallocatedEncoding();
                         pos = UInt(hw:'0000');


                       Alias conditions


                          Alias                  of variant         is preferred when

                          MOV (inverted wide     64-bit             ! (IsZero(imm16) && hw != '00')
                          immediate)

                          MOV (inverted wide     32-bit             ! (IsZero(imm16) && hw != '00') && ! IsOnes(imm16)
                          immediate)


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <imm>           Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.




C6-624                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



                <shift>       For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
                              16, encoded in the "hw" field as <shift>/16.

                              For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
                              32 or 48, encoded in the "hw" field as <shift>/16.


                Operation

                 bits(datasize) result;

                 if opcode == MoveWideOp_K then
                    result = X[d];
                 else
                    result = Zeros();

                 result<pos+15:pos> = imm;
                 if opcode == MoveWideOp_N then
                    result = NOT(result);
                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-625
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.128       MOVZ

                       Move shifted 16-bit immediate to register: Rd = LSL (imm16, shift)

                       This instruction is used by the alias MOV (wide immediate). See the Alias conditions table for details of when each
                       alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20                                                5 4               0
                           sf 1 0 1 0 0 1 0 1            hw                        imm16                                Rd
                               opc


                       32-bit variant

                       Applies when sf = 0.

                       MOVZ <Wd>, #<imm>{, LSL #<shift>}


                       64-bit variant

                       Applies when sf = 1.

                       MOVZ <Xd>, #<imm>{, LSL #<shift>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer datasize = if sf == '1' then 64 else 32;
                         bits(16) imm = imm16;
                         integer pos;
                         MoveWideOp opcode;

                         case opc of
                              when '00' opcode = MoveWideOp_N;
                              when '10' opcode = MoveWideOp_Z;
                              when '11' opcode = MoveWideOp_K;
                              otherwise UnallocatedEncoding();

                         if sf == '0' && hw<1> == '1' then UnallocatedEncoding();
                         pos = UInt(hw:'0000');


                       Alias conditions


                                             Alias                     is preferred when

                                             MOV (wide                 ! (IsZero(imm16) && hw != '00')
                                             immediate)


                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <imm>            Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

                       <shift>          For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
                                        16, encoded in the "hw" field as <shift>/16.

                                        For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
                                        32 or 48, encoded in the "hw" field as <shift>/16.


C6-626                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                Operation

                 bits(datasize) result;

                 if opcode == MoveWideOp_K then
                    result = X[d];
                 else
                    result = Zeros();

                 result<pos+15:pos> = imm;
                 if opcode == MoveWideOp_N then
                    result = NOT(result);
                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-627
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.129       MRS

                       Move from system register




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18     16 15       12 11         8 7      5 4              0
                           1 1 0 1 0 1 0 1 0 0 1 1 o0                op1        CRn         CRm          op2          Rt
                                                          L


                       System variant

                       MRS <Xt>, <systemreg>


                       Decode for this encoding

                         CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);

                         integer t = UInt(Rt);

                         integer sys_op0 = 2 + UInt(o0);
                         integer sys_op1 = UInt(op1);
                         integer sys_op2 = UInt(op2);
                         integer sys_crn = UInt(CRn);
                         integer sys_crm = UInt(CRm);
                         boolean read = (L == '1');


                       Assembler symbols

                       <Xt>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rt" field.

                       <systemreg>     Is a system register name, encoded in the "o0:op1:CRn:CRm:op2".


                       Operation

                         if read then
                              X[t] = System_Get(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
                         else
                              System_Put(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);




C6-628                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.130    MSR (immediate)

                Move immediate to process state field




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18     16 15 14 13 12 11        8 7       5 4 3 2 1 0
                  1 1 0 1 0 1 0 1 0 0 0 0 0                op1      0 1 0 0         CRm        op2    1 1 1 1 1




                System variant

                MSR <pstatefield>, #<imm>


                Decode for this encoding

                 CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');

                 bits(4) operand = CRm;
                 PSTATEField field;
                 case op1:op2 of
                     when '000 101' field = PSTATEField_SP;
                     when '011 110' field = PSTATEField_DAIFSet;
                     when '011 111' field = PSTATEField_DAIFClr;
                     otherwise       UnallocatedEncoding();

                 // Check that an AArch64 MSR/MRS access to the DAIF flags is permitted
                 if op1 == '011' && PSTATE.EL == EL0 && SCTLR_EL1.UMA == '0' then
                     AArch64.SystemRegisterTrap(EL1, '00', op2, op1, '0100', '11111', CRm, '0');


                Assembler symbols

                <pstatefield> Is a PSTATE field name, encoded in the "op1:op2" field. It can have the following values:

                              SPSel       when op1 = 000, op2 = 101

                              DAIFSet     when op1 = 011, op2 = 110

                              DAIFClr     when op1 = 011, op2 = 111

                              It is RESERVED when:

                              ·      op1 = 000, op2 = 0xx.

                              ·      op1 = 000, op2 = 100.

                              ·      op1 = 000, op2 = 11x.

                              ·      op1 = 001, op2 = xxx.

                              ·      op1 = 010, op2 = xxx.

                              ·      op1 = 011, op2 = 0xx.

                              ·      op1 = 011, op2 = 10x.

                              ·      op1 = 1xx, op2 = xxx.

                <imm>         Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the "CRm" field.


                Operation

                 case field of
                     when PSTATEField_SP
                        PSTATE.SP = operand<0>;
                     when PSTATEField_DAIFSet
                        PSTATE.D = PSTATE.D OR operand<3>;
                        PSTATE.A = PSTATE.A OR operand<2>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-629
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   PSTATE.I = PSTATE.I OR operand<1>;
                                   PSTATE.F = PSTATE.F OR operand<0>;
                              when PSTATEField_DAIFClr
                                   PSTATE.D = PSTATE.D AND NOT(operand<3>);
                                   PSTATE.A = PSTATE.A AND NOT(operand<2>);
                                   PSTATE.I = PSTATE.I AND NOT(operand<1>);
                                   PSTATE.F = PSTATE.F AND NOT(operand<0>);




C6-630                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



C6.6.131    MSR (register)

                Move to system register




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18     16 15       12 11         8 7      5 4             0
                  1 1 0 1 0 1 0 1 0 0 0 1 o0                op1        CRn         CRm        op2            Rt
                                                 L


                System variant

                MSR <systemreg>, <Xt>


                Decode for this encoding

                 CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);

                 integer t = UInt(Rt);

                 integer sys_op0 = 2 + UInt(o0);
                 integer sys_op1 = UInt(op1);
                 integer sys_op2 = UInt(op2);
                 integer sys_crn = UInt(CRn);
                 integer sys_crm = UInt(CRm);
                 boolean read = (L == '1');


                Assembler symbols

                <systemreg>   Is a system register name, encoded in the "o0:op1:CRn:CRm:op2".

                <Xt>          Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.


                Operation

                 if read then
                     X[t] = System_Get(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
                 else
                     System_Put(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-631
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.132       MSUB

                       Multiply-subtract: Rd = Ra - Rn * Rm

                       This instruction is used by the alias MNEG. See the Alias conditions table for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9              5 4             0
                           sf 0 0 1 1 0 1 1 0 0 0                  Rm         1       Ra               Rn              Rd
                                                                              o0


                       32-bit variant

                       Applies when sf = 0.

                       MSUB <Wd>, <Wn>, <Wm>, <Wa>


                       64-bit variant

                       Applies when sf = 1.

                       MSUB <Xd>, <Xn>, <Xm>, <Xa>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);
                         integer destsize = if sf == '1' then 64 else 32;
                         integer datasize = destsize;
                         boolean sub_op = (o0 == '1');


                       Alias conditions


                                             Alias                    is preferred when

                                             MNEG                     Ra == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Wa>            Is the 32-bit name of the third general-purpose source register holding the minuend, encoded in the
                                       "Ra" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.




C6-632                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



                <Xa>          Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the
                              "Ra" field.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];
                 bits(destsize) operand3 = X[a];

                 integer result;

                 if sub_op then
                    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));
                 else
                    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));

                 X[d] = result<destsize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-633
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.133       MUL

                       Multiply: Rd = Rn * Rm

                       This instruction is an alias of the MADD instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of MADD.

                       ·       The description of MADD gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9             5 4              0
                           sf 0 0 1 1 0 1 1 0 0 0                  Rm         0 1 1 1 1 1              Rn             Rd
                                                                              o0      Ra


                       32-bit variant

                       Applies when sf = 0.

                       MUL <Wd>, <Wn>, <Wm>

                       is equivalent to

                       MADD <Wd>, <Wn>, <Wm>, WZR

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       MUL <Xd>, <Xn>, <Xm>

                       is equivalent to

                       MADD <Xd>, <Xn>, <Xm>, XZR

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.


                       Operation

                       The description of MADD gives the operational pseudocode for this instruction.




C6-634                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.134    MVN

                Bitwise NOT (shifted register): Rd = NOT shift(Rm, amount)

                This instruction is an alias of the ORN (shifted register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ORN (shifted register).

                ·      The description of ORN (shifted register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15              10 9             5 4             0
                   sf 0 1 0 1 0 1 0 shift 1                  Rm               imm6          1 1 1 1 1             Rd
                      opc                           N                                             Rn


                32-bit variant

                Applies when sf = 0.

                MVN <Wd>, <Wm>{, <shift> #<amount>}

                is equivalent to

                ORN <Wd>, WZR, <Wm>{, <shift> #<amount>}

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                MVN <Xd>, <Xm>{, <shift> #<amount>}

                is equivalent to

                ORN <Xd>, XZR, <Xm>{, <shift> #<amount>}

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wm>            Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xm>            Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

                <shift>         Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                                field. It can have the following values:

                                LSL          when shift = 00

                                LSR          when shift = 01

                                ASR          when shift = 10

                                ROR          when shift = 11

                <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                "imm6" field.

                                For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                "imm6" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-635
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                       The description of ORN (shifted register) gives the operational pseudocode for this instruction.




C6-636                                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                             ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.135    NEG (shifted register)

                Negate: Rd = 0 - shift(Rm, amount)

                This instruction is an alias of the SUB (shifted register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SUB (shifted register).

                ·      The description of SUB (shifted register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15              10 9            5 4              0
                   sf 1 0 0 1 0 1 1 shift 0                   Rm               imm6        1 1 1 1 1              Rd
                     op S                                                                        Rn


                32-bit variant

                Applies when sf = 0.

                NEG <Wd>, <Wm>{, <shift> #<amount>}

                is equivalent to

                SUB  <Wd>, WZR, <Wm> {, <shift> #<amount>}

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                NEG <Xd>, <Xm>{, <shift> #<amount>}

                is equivalent to

                SUB  <Xd>, XZR, <Xm> {, <shift> #<amount>}

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wm>            Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xm>            Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

                <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                in the "shift" field. It can have the following values:

                                LSL          when shift = 00

                                LSR          when shift = 01

                                ASR          when shift = 10

                                It is RESERVED when shift = 11.

                <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                "imm6" field.

                                For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                "imm6" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-637
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                       The description of SUB (shifted register) gives the operational pseudocode for this instruction.




C6-638                                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                             ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.136    NEGS

                Negate, setting the condition flags: Rd = 0 - shift(Rm, amount)

                This instruction is an alias of the SUBS (shifted register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SUBS (shifted register).

                ·      The description of SUBS (shifted register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15              10 9            5 4              0
                   sf 1 1 0 1 0 1 1 shift 0                   Rm               imm6        1 1 1 1 1              Rd
                     op S                                                                        Rn


                32-bit variant

                Applies when sf = 0.

                NEGS <Wd>, <Wm>{, <shift> #<amount>}

                is equivalent to

                SUBS <Wd>, WZR, <Wm> {, <shift> #<amount>}

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                NEGS <Xd>, <Xm>{, <shift> #<amount>}

                is equivalent to

                SUBS <Xd>, XZR, <Xm> {, <shift> #<amount>}

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wm>            Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xm>            Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

                <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                in the "shift" field. It can have the following values:

                                LSL          when shift = 00

                                LSR          when shift = 01

                                ASR          when shift = 10

                                It is RESERVED when shift = 11.

                <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                "imm6" field.

                                For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                "imm6" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-639
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                       The description of SUBS (shifted register) gives the operational pseudocode for this instruction.




C6-640                                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                              ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.137    NGC

                Negate with carry: Rd = 0 - Rm - 1 + C

                This instruction is an alias of the SBC instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SBC.

                ·      The description of SBC gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9             5 4              0
                   sf 1 0 1 1 0 1 0 0 0 0                   Rm         0 0 0 0 0 0 1 1 1 1 1                   Rd
                     op S                                                                      Rn


                32-bit variant

                Applies when sf = 0.

                NGC <Wd>, <Wm>

                is equivalent to

                SBC <Wd>, WZR, <Wm>

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                NGC <Xd>, <Xm>

                is equivalent to

                SBC <Xd>, XZR, <Xm>

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wm>            Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xm>            Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.


                Operation

                The description of SBC gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-641
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.138       NGCS

                       Negate with carry, setting the condition flags: Rd = 0 - Rm - 1 + C

                       This instruction is an alias of the SBCS instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SBCS.

                       ·       The description of SBCS gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9            5 4              0
                           sf 1 1 1 1 0 1 0 0 0 0                  Rm         0 0 0 0 0 0 1 1 1 1 1                   Rd
                              op S                                                                    Rn


                       32-bit variant

                       Applies when sf = 0.

                       NGCS <Wd>, <Wm>

                       is equivalent to

                       SBCS <Wd>, WZR, <Wm>

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       NGCS <Xd>, <Xm>

                       is equivalent to

                       SBCS <Xd>, XZR, <Xm>

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wm>            Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xm>            Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.


                       Operation

                       The description of SBCS gives the operational pseudocode for this instruction.




C6-642                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.139    NOP

                No operation

                This instruction is an alias of the HINT instruction. This means that:

                ·      The encodings in this description are named to match the encodings of HINT.

                ·      The description of HINT gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11          8 7       5 4 3 2 1 0
                   1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1
                                                                                      CRm      op2


                System variant

                NOP

                is equivalent to

                HINT #0

                and is always the preferred disassembly.


                Operation

                The description of HINT gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-643
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.140       ORN (shifted register)

                       Bitwise inclusive OR NOT (shifted register): Rd = Rn OR NOT shift(Rm, amount)

                       This instruction is used by the alias MVN. See the Alias conditions table for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15             10 9              5 4             0
                           sf 0 1 0 1 0 1 0 shift 1                Rm              imm6                Rn              Rd
                               opc                         N


                       32-bit variant

                       Applies when sf = 0.

                       ORN <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                       64-bit variant

                       Applies when sf = 1.

                       ORN <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean setflags;
                         LogicalOp op;
                         case opc of
                              when '00' op = LogicalOp_AND; setflags = FALSE;
                              when '01' op = LogicalOp_ORR; setflags = FALSE;
                              when '10' op = LogicalOp_EOR; setflags = FALSE;
                              when '11' op = LogicalOp_AND; setflags = TRUE;

                         if sf == '0' && imm6<5> == '1' then ReservedValue();

                         ShiftType shift_type = DecodeShift(shift);
                         integer shift_amount = UInt(imm6);
                         boolean invert = (N == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            MVN                       Rn == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.



C6-644                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                <Xm>          Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>       Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                              field. It can have the following values:

                              LSL          when shift = 00

                              LSR          when shift = 01

                              ASR          when shift = 10

                              ROR          when shift = 11

                <amount>      For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                              "imm6" field.

                              For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                              "imm6" field.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                 if invert then operand2 = NOT(operand2);

                 case op of
                    when LogicalOp_AND result = operand1 AND operand2;
                    when LogicalOp_ORR result = operand1 OR        operand2;
                    when LogicalOp_EOR result = operand1 EOR operand2;

                 if setflags then
                    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-645
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.141       ORR (immediate)

                       Bitwise inclusive OR (immediate): Rd = Rn OR imm

                       This instruction is used by the alias MOV (bitmask immediate). See the Alias conditions table for details of when
                       each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21               16 15             10 9             5 4             0
                           sf 0 1 1 0 0 1 0 0 N                 immr               imms               Rn               Rd
                               opc


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       ORR <Wd|WSP>, <Wn>, #<imm>


                       64-bit variant

                       Applies when sf = 1.

                       ORR <Xd|SP>, <Xn>, #<imm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean setflags;
                         LogicalOp op;
                         case opc of
                              when '00' op = LogicalOp_AND; setflags = FALSE;
                              when '01' op = LogicalOp_ORR; setflags = FALSE;
                              when '10' op = LogicalOp_EOR; setflags = FALSE;
                              when '11' op = LogicalOp_AND; setflags = TRUE;

                         bits(datasize) imm;
                         if sf == '0' && N != '0' then ReservedValue();
                         (imm, -) = DecodeBitMasks(N, imms, immr, TRUE);


                       Alias conditions


                                            Alias                    is preferred when

                                            MOV (bitmask             Rn == '11111' && ! MoveWidePreferred(sf, N, imms, immr)
                                            immediate)


                       Assembler symbols

                       <Wd|WSP>        Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd|SP>         Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                                       field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.




C6-646                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                <imm>         Is the bitmask immediate, encoded in "N:imms:immr".


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = imm;

                 case op of
                    when LogicalOp_AND result = operand1 AND operand2;
                    when LogicalOp_ORR result = operand1 OR   operand2;
                    when LogicalOp_EOR result = operand1 EOR operand2;

                 if setflags then
                    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                 if d == 31 && !setflags then
                     SP[] = result;
                 else
                     X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-647
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.142       ORR (shifted register)

                       Bitwise inclusive OR (shifted register): Rd = Rn OR shift(Rm, amount)

                       This instruction is used by the alias MOV (register). See the Alias conditions table for details of when each alias is
                       preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15              10 9             5 4             0
                           sf 0 1 0 1 0 1 0 shift 0                Rm              imm6                Rn               Rd
                               opc                         N


                       32-bit variant

                       Applies when sf = 0.

                       ORR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                       64-bit variant

                       Applies when sf = 1.

                       ORR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean setflags;
                         LogicalOp op;
                         case opc of
                              when '00' op = LogicalOp_AND; setflags = FALSE;
                              when '01' op = LogicalOp_ORR; setflags = FALSE;
                              when '10' op = LogicalOp_EOR; setflags = FALSE;
                              when '11' op = LogicalOp_AND; setflags = TRUE;

                         if sf == '0' && imm6<5> == '1' then ReservedValue();

                         ShiftType shift_type = DecodeShift(shift);
                         integer shift_amount = UInt(imm6);
                         boolean invert = (N == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            MOV (register)            shift == '00' && imm6 == '000000' && Rn == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.


C6-648                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                <Xm>          Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>       Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                              field. It can have the following values:

                              LSL          when shift = 00

                              LSR          when shift = 01

                              ASR          when shift = 10

                              ROR          when shift = 11

                <amount>      For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                              "imm6" field.

                              For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                              "imm6" field.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

                 if invert then operand2 = NOT(operand2);

                 case op of
                    when LogicalOp_AND result = operand1 AND operand2;
                    when LogicalOp_ORR result = operand1 OR        operand2;
                    when LogicalOp_EOR result = operand1 EOR operand2;

                 if setflags then
                    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-649
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.143       PRFM (immediate)

                       Prefetch memory (immediate offset)




                           31 30 29 28 27 26 25 24 23 22 21                                   10 9             5 4             0
                           1 1 1 1 1 0 0 1 1 0                          imm12                           Rn               Rt
                           size                     opc


                       Unsigned offset variant

                       PRFM <prfop>, [<Xn|SP>{, #<pimm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                       Assembler symbols

                       <prfop>         Is the prefetch operation, encoded in the "Rt" field. It can have the following values:

                                       PLDL1KEEP   when Rt = 00000

                                       PLDL1STRM   when Rt = 00001

                                       PLDL2KEEP   when Rt = 00010

                                       PLDL2STRM   when Rt = 00011

                                       PLDL3KEEP   when Rt = 00100

                                       PLDL3STRM   when Rt = 00101

                                       #uimm5      when Rt = 0011x

                                       PLIL1KEEP   when Rt = 01000

                                       PLIL1STRM   when Rt = 01001

                                       PLIL2KEEP   when Rt = 01010

                                       PLIL2STRM   when Rt = 01011

                                       PLIL3KEEP   when Rt = 01100

                                       PLIL3STRM   when Rt = 01101

                                       #uimm5      when Rt = 0111x

                                       PSTL1KEEP   when Rt = 10000

                                       PSTL1STRM   when Rt = 10001

                                       PSTL2KEEP   when Rt = 10010

                                       PSTL2STRM   when Rt = 10011

                                       PSTL3KEEP   when Rt = 10100

                                       PSTL3STRM   when Rt = 10101

                                       #uimm5      when Rt = 1011x

                                       #uimm5      when Rt = 11xxx

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <pimm>          Is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to
                                       0 and encoded in the "imm12" field as <pimm>/8.



C6-650                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-651
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-652                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.144    PRFM (literal)

                Prefetch memory (PC-relative offset)




                  31 30 29 28 27 26 25 24 23                                                         5 4              0
                  1 1 0 1 1 0 0 0                                    imm19                                    Rt
                   opc


                Literal variant

                PRFM <prfop>, <label>


                Decode for this encoding

                 integer t = UInt(Rt);
                 MemOp memop = MemOp_LOAD;
                 boolean signed = FALSE;
                 integer size;
                 bits(64) offset;

                 case opc of
                     when '00'
                         size = 4;
                     when '01'
                         size = 8;
                     when '10'
                         size = 4;
                         signed = TRUE;
                     when '11'
                         memop = MemOp_PREFETCH;

                 offset = SignExtend(imm19:'00', 64);


                Assembler symbols

                <prfop>       Is the prefetch operation, encoded in the "Rt" field. It can have the following values:

                              PLDL1KEEP   when Rt = 00000

                              PLDL1STRM   when Rt = 00001

                              PLDL2KEEP   when Rt = 00010

                              PLDL2STRM   when Rt = 00011

                              PLDL3KEEP   when Rt = 00100

                              PLDL3STRM   when Rt = 00101

                              #uimm5      when Rt = 0011x

                              PLIL1KEEP   when Rt = 01000

                              PLIL1STRM   when Rt = 01001

                              PLIL2KEEP   when Rt = 01010

                              PLIL2STRM   when Rt = 01011

                              PLIL3KEEP   when Rt = 01100

                              PLIL3STRM   when Rt = 01101

                              #uimm5      when Rt = 0111x

                              PSTL1KEEP   when Rt = 10000

                              PSTL1STRM   when Rt = 10001




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-653
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                        PSTL2KEEP   when Rt = 10010

                                        PSTL2STRM   when Rt = 10011

                                        PSTL3KEEP   when Rt = 10100

                                        PSTL3STRM   when Rt = 10101

                                        #uimm5      when Rt = 1011x

                                        #uimm5      when Rt = 11xxx

                       <label>          Is the program label from which the data is to be loaded. Its offset from the address of this
                                        instruction, in the range +/-1MB, is encoded as "imm19" times 4.


                       Operation

                         bits(64) address = PC[] + offset;
                         bits(size*8) data;

                         case memop of
                              when MemOp_LOAD
                                   data = Mem[address, size, AccType_NORMAL];
                                   if signed then
                                       X[t] = SignExtend(data, 64);
                                   else
                                       X[t] = data;

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);




C6-654                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.145    PRFM (register)

                Prefetch memory (register offset)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15     13 12 11 10 9              5 4              0
                  1 1 1 1 1 0 0 0 1 0 1                   Rm         option   S 1 0           Rn              Rt
                  size                     opc


                Integer variant

                PRFM <prfop>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                 ExtendType extend_type = DecodeRegExtend(option);
                 integer shift = if S == '1' then scale else 0;


                Assembler symbols

                <prfop>       Is the prefetch operation, encoded in the "Rt" field. It can have the following values:

                              PLDL1KEEP   when Rt = 00000

                              PLDL1STRM   when Rt = 00001

                              PLDL2KEEP   when Rt = 00010

                              PLDL2STRM   when Rt = 00011

                              PLDL3KEEP   when Rt = 00100

                              PLDL3STRM   when Rt = 00101

                              #uimm5      when Rt = 0011x

                              PLIL1KEEP   when Rt = 01000

                              PLIL1STRM   when Rt = 01001

                              PLIL2KEEP   when Rt = 01010

                              PLIL2STRM   when Rt = 01011

                              PLIL3KEEP   when Rt = 01100

                              PLIL3STRM   when Rt = 01101

                              #uimm5      when Rt = 0111x

                              PSTL1KEEP   when Rt = 10000

                              PSTL1STRM   when Rt = 10001

                              PSTL2KEEP   when Rt = 10010

                              PSTL2STRM   when Rt = 10011

                              PSTL3KEEP   when Rt = 10100

                              PSTL3STRM   when Rt = 10101

                              #uimm5      when Rt = 1011x

                              #uimm5      when Rt = 11xxx

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-655
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <R>              Is the index width specifier, encoded in the "option" field. It can have the following values:

                                        W            when option = x10

                                        X            when option = x11

                                        It is RESERVED when:

                                        ·      option = 00x.

                                        ·      option = 10x.

                       <m>              Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                        field.

                       <extend>         Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                        the following values:

                                        UXTW         when option = 010

                                        LSL          when option = 011

                                        SXTW         when option = 110

                                        SXTX         when option = 111

                                        It is RESERVED when:

                                        ·      option = 00x.

                                        ·      option = 10x.

                       <amount>         Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                                        "S" field. It can have the following values:

                                        #0           when S = 0

                                        #3           when S = 1


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer m = UInt(Rm);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   memop = MemOp_PREFETCH;
                                   if opc<0> == '1' then UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation

                         bits(64) offset = ExtendReg(m, extend_type, shift);
                         bits(64) address;
                         bits(datasize) data;



C6-656                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-657
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.146       PRFUM

                       Prefetch memory (unscaled offset)




                           31 30 29 28 27 26 25 24 23 22 21 20                        12 11 10 9              5 4             0
                           1 1 1 1 1 0 0 0 1 0 0                       imm9               0 0          Rn              Rt
                           size                     opc


                       Unscaled offset variant

                       PRFUM <prfop>, [<Xn|SP>{, #<simm>}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <prfop>         Is the prefetch operation, encoded in the "Rt" field. It can have the following values:

                                       PLDL1KEEP   when Rt = 00000

                                       PLDL1STRM   when Rt = 00001

                                       PLDL2KEEP   when Rt = 00010

                                       PLDL2STRM   when Rt = 00011

                                       PLDL3KEEP   when Rt = 00100

                                       PLDL3STRM   when Rt = 00101

                                       #uimm5      when Rt = 0011x

                                       PLIL1KEEP   when Rt = 01000

                                       PLIL1STRM   when Rt = 01001

                                       PLIL2KEEP   when Rt = 01010

                                       PLIL2STRM   when Rt = 01011

                                       PLIL3KEEP   when Rt = 01100

                                       PLIL3STRM   when Rt = 01101

                                       #uimm5      when Rt = 0111x

                                       PSTL1KEEP   when Rt = 10000

                                       PSTL1STRM   when Rt = 10001

                                       PSTL2KEEP   when Rt = 10010

                                       PSTL2STRM   when Rt = 10011

                                       PSTL3KEEP   when Rt = 10100

                                       PSTL3STRM   when Rt = 10101

                                       #uimm5      when Rt = 1011x

                                       #uimm5      when Rt = 11xxx

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>          Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                       in the "imm9" field.



C6-658                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-659
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-660                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.147    RBIT

                Reverse bit order




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4              0
                  sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0                                Rn              Rd
                                                                                  opc


                32-bit variant

                Applies when sf = 0.

                RBIT <Wd>, <Wn>


                64-bit variant

                Applies when sf = 1.

                RBIT <Xd>, <Xn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer datasize = if sf == '1' then 64 else 32;

                 RevOp op;
                 case opc of
                     when '00'
                         op = RevOp_RBIT;
                     when '01'
                        op = RevOp_REV16;
                     when '10'
                        op = RevOp_REV32;
                     when '11'
                        if sf == '0' then UnallocatedEncoding();
                        op = RevOp_REV64;


                Assembler symbols

                <Wd>           Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>           Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>           Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>           Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.


                Operation

                 bits(datasize) result;
                 bits(6) V;
                 integer vbit;

                 case op of
                     when RevOp_REV16 V = '001000';
                     when RevOp_REV32 V = '011000';
                     when RevOp_REV64 V = '111000';
                     when RevOp_RBIT   V = if datasize == 64 then '111111' else '011111';




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-661
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         result = X[n];
                         for vbit = 0 to 5
                              // Swap pairs of 2^vbit bits in result
                              if V<vbit> == '1' then
                                   bits(datasize) tmp = result;
                                   integer vsize = 1 << vbit;
                                   integer base = 0;
                                   while base < datasize do
                                      result<base+vsize-1:base> = tmp<base+(2*vsize)-1:base+vsize>;
                                      result<base+(2*vsize)-1:base+vsize> = tmp<base+vsize-1:base>;
                                      base = base + (2 * vsize);
                         X[d] = result;




C6-662                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.     ARM DDI 0487A.e
                                                         Non-Confidential - Beta                            ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.148    RET

                Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine
                return.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4 3 2 1 0
                   1 1 0 1 0 1 1 0 0 1 0 1 1 1 1 1 0 0 0 0 0 0                               Rn          0 0 0 0 0
                                              op


                Integer variant

                RET {<Xn>}


                Decode for this encoding

                 integer n = UInt(Rn);
                 BranchType branch_type;

                 case op of
                     when '00' branch_type = BranchType_JMP;
                     when '01' branch_type = BranchType_CALL;
                     when '10' branch_type = BranchType_RET;
                     otherwise UnallocatedEncoding();


                Assembler symbols

                <Xn>          Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
                              the "Rn" field. Defaults to X30 if absent.


                Operation

                 bits(64) target = X[n];

                 if branch_type == BranchType_CALL then X[30] = PC[] + 4;
                 BranchTo(target, branch_type);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-663
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.149       REV

                       Reverse bytes




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9               5 4              0
                           sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 x                                Rn              Rd
                                                                                           opc


                       32-bit variant

                       Applies when sf = 0 && opc = 10.

                       REV <Wd>, <Wn>


                       64-bit variant

                       Applies when sf = 1 && opc = 11.

                       REV <Xd>, <Xn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize = if sf == '1' then 64 else 32;

                         RevOp op;
                         case opc of
                              when '00'
                                   op = RevOp_RBIT;
                              when '01'
                                   op = RevOp_REV16;
                              when '10'
                                   op = RevOp_REV32;
                              when '11'
                                   if sf == '0' then UnallocatedEncoding();
                                   op = RevOp_REV64;


                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>             Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>             Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                         bits(datasize) result;
                         bits(6) V;
                         integer vbit;

                         case op of
                              when RevOp_REV16 V = '001000';
                              when RevOp_REV32 V = '011000';
                              when RevOp_REV64 V = '111000';
                              when RevOp_RBIT   V = if datasize == 64 then '111111' else '011111';




C6-664                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                 result = X[n];
                 for vbit = 0 to 5
                     // Swap pairs of 2^vbit bits in result
                     if V<vbit> == '1' then
                        bits(datasize) tmp = result;
                        integer vsize = 1 << vbit;
                        integer base = 0;
                        while base < datasize do
                             result<base+vsize-1:base> = tmp<base+(2*vsize)-1:base+vsize>;
                             result<base+(2*vsize)-1:base+vsize> = tmp<base+vsize-1:base>;
                             base = base + (2 * vsize);
                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-665
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.150       REV16

                       Reverse bytes in 16-bit halfwords




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9               5 4              0
                           sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1                                Rn              Rd
                                                                                           opc


                       32-bit variant

                       Applies when sf = 0.

                       REV16 <Wd>, <Wn>


                       64-bit variant

                       Applies when sf = 1.

                       REV16 <Xd>, <Xn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize = if sf == '1' then 64 else 32;

                         RevOp op;
                         case opc of
                              when '00'
                                   op = RevOp_RBIT;
                              when '01'
                                   op = RevOp_REV16;
                              when '10'
                                   op = RevOp_REV32;
                              when '11'
                                   if sf == '0' then UnallocatedEncoding();
                                   op = RevOp_REV64;


                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>             Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>             Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                         bits(datasize) result;
                         bits(6) V;
                         integer vbit;

                         case op of
                              when RevOp_REV16 V = '001000';
                              when RevOp_REV32 V = '011000';
                              when RevOp_REV64 V = '111000';
                              when RevOp_RBIT   V = if datasize == 64 then '111111' else '011111';




C6-666                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                 result = X[n];
                 for vbit = 0 to 5
                     // Swap pairs of 2^vbit bits in result
                     if V<vbit> == '1' then
                        bits(datasize) tmp = result;
                        integer vsize = 1 << vbit;
                        integer base = 0;
                        while base < datasize do
                             result<base+vsize-1:base> = tmp<base+(2*vsize)-1:base+vsize>;
                             result<base+(2*vsize)-1:base+vsize> = tmp<base+vsize-1:base>;
                             base = base + (2 * vsize);
                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-667
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.151       REV32

                       Reverse bytes in 32-bit words




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9               5 4              0
                           1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0                                 Rn              Rd
                           sf                                                              opc


                       64-bit variant

                       REV32 <Xd>, <Xn>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize = if sf == '1' then 64 else 32;

                         RevOp op;
                         case opc of
                              when '00'
                                   op = RevOp_RBIT;
                              when '01'
                                   op = RevOp_REV16;
                              when '10'
                                   op = RevOp_REV32;
                              when '11'
                                   if sf == '0' then UnallocatedEncoding();
                                   op = RevOp_REV64;


                       Assembler symbols

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>             Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                         bits(datasize) result;
                         bits(6) V;
                         integer vbit;

                         case op of
                              when RevOp_REV16 V = '001000';
                              when RevOp_REV32 V = '011000';
                              when RevOp_REV64 V = '111000';
                              when RevOp_RBIT   V = if datasize == 64 then '111111' else '011111';

                         result = X[n];
                         for vbit = 0 to 5
                              // Swap pairs of 2^vbit bits in result
                              if V<vbit> == '1' then
                                   bits(datasize) tmp = result;
                                   integer vsize = 1 << vbit;
                                   integer base = 0;
                                   while base < datasize do
                                      result<base+vsize-1:base> = tmp<base+(2*vsize)-1:base+vsize>;
                                      result<base+(2*vsize)-1:base+vsize> = tmp<base+vsize-1:base>;
                                      base = base + (2 * vsize);
                         X[d] = result;



C6-668                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.152    ROR (immediate)

                Rotate right (immediate): Rd = ROR(Rs, shift)

                This instruction is an alias of the EXTR instruction. This means that:

                ·      The encodings in this description are named to match the encodings of EXTR.

                ·      The description of EXTR gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15              10 9              5 4              0
                   sf 0 0 1 0 0 1 1 1 N 0                    Rm             imms                 Rn              Rd




                32-bit variant

                Applies when sf = 0 && N = 0 && imms = 0xxxxx.

                ROR <Wd>, <Ws>, #<shift>

                is equivalent to

                EXTR <Wd>, <Ws>, <Ws>, #<shift>

                and is the preferred disassembly when Rn == Rm.

                64-bit variant

                Applies when sf = 1 && N = 1.

                ROR <Xd>, <Xs>, #<shift>

                is equivalent to

                EXTR <Xd>, <Xs>, <Xs>, #<shift>

                and is the preferred disassembly when Rn == Rm.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Ws>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xs>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

                <shift>         For the 32-bit variant: is the amount by which to rotate, in the range 0 to 31, encoded in the "imms"
                                field.

                                For the 64-bit variant: is the amount by which to rotate, in the range 0 to 63, encoded in the "imms"
                                field.


                Operation

                The description of EXTR gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-669
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.153       ROR (register)

                       Rotate right (register): Rd = ROR(Rn, Rm)

                       This instruction is an alias of the RORV instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of RORV.

                       ·       The description of RORV gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9             5 4              0
                           sf 0 0 1 1 0 1 0 1 1 0                  Rm         0 0 1 0 1 1              Rn              Rd
                                                                                          op2


                       32-bit variant

                       Applies when sf = 0.

                       ROR <Wd>, <Wn>, <Wm>

                       is equivalent to

                       RORV <Wd>, <Wn>, <Wm>

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       ROR <Xd>, <Xn>, <Xm>

                       is equivalent to

                       RORV <Xd>, <Xn>, <Xm>

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                       31 in its bottom 5 bits, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                       63 in its bottom 6 bits, encoded in the "Rm" field.


                       Operation

                       The description of RORV gives the operational pseudocode for this instruction.




C6-670                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.154    RORV

                Rotate right variable: Rd = ROR(Rn, Rm)

                This instruction is used by the alias ROR (register). The alias is always the preferred disassembly.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9              5 4              0
                  sf 0 0 1 1 0 1 0 1 1 0                    Rm         0 0 1 0 1 1              Rn              Rd
                                                                                     op2


                32-bit variant

                Applies when sf = 0.

                RORV <Wd>, <Wn>, <Wm>


                64-bit variant

                Applies when sf = 1.

                RORV <Xd>, <Xn>, <Xm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 ShiftType shift_type = DecodeShift(op2);


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
                                31 in its bottom 5 bits, encoded in the "Rm" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>            Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
                                63 in its bottom 6 bits, encoded in the "Rm" field.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand2 = X[m];

                 result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
                 X[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-671
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.155       SBC

                       Subtract with carry: Rd = Rn - Rm - 1 + C

                       This instruction is used by the alias NGC. See the Alias conditions table for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9              5 4             0
                           sf 1 0 1 1 0 1 0 0 0 0                  Rm         0 0 0 0 0 0              Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       SBC <Wd>, <Wn>, <Wm>


                       64-bit variant

                       Applies when sf = 1.

                       SBC <Xd>, <Xn>, <Xm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            NGC                       Rn == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bits(4) nzcv;

                         if sub_op then



C6-672                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    operand2 = NOT(operand2);

                 (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);

                 if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-673
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.156       SBCS

                       Subtract with carry, setting the condition flags: Rd = Rn - Rm - 1 + C

                       This instruction is used by the alias NGCS. See the Alias conditions table for details of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4            0
                           sf 1 1 1 1 0 1 0 0 0 0                  Rm         0 0 0 0 0 0              Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       SBCS <Wd>, <Wn>, <Wm>


                       64-bit variant

                       Applies when sf = 1.

                       SBCS <Xd>, <Xn>, <Xm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            NGCS                      Rn == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bits(4) nzcv;

                         if sub_op then



C6-674                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    operand2 = NOT(operand2);

                 (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);

                 if setflags then
                    PSTATE.<N,Z,C,V> = nzcv;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-675
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.157       SBFIZ

                       Signed bitfield insert in zero, with sign replication to left and zeros to right

                       This instruction is an alias of the SBFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SBFM.

                       ·       The description of SBFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21                16 15                10 9            5 4               0
                           sf 0 0 1 0 0 1 1 0 N                  immr                 imms               Rn               Rd
                               opc


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       SBFIZ <Wd>, <Wn>, #<lsb>, #<width>

                       is equivalent to

                       SBFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)

                       and is the preferred disassembly when UInt(imms) < UInt(immr).

                       64-bit variant

                       Applies when sf = 1 && N = 1.

                       SBFIZ <Xd>, <Xn>, #<lsb>, #<width>

                       is equivalent to

                       SBFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)

                       and is the preferred disassembly when UInt(imms) < UInt(immr).


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <lsb>           For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

                                       For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

                       <width>         For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

                                       For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.


                       Operation

                       The description of SBFM gives the operational pseudocode for this instruction.




C6-676                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                   ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.158    SBFM

                Signed bitfield move, with sign replication to left and zeros to right

                This instruction is used by the aliases ASR (immediate), SBFIZ, SBFX, SXTB, SXTH, and SXTW. See the Alias
                conditions on page C6-678 table for details of when each alias is preferred.




                  31 30 29 28 27 26 25 24 23 22 21                 16 15              10 9         5 4              0
                  sf 0 0 1 0 0 1 1 0 N                   immr               imms             Rn            Rd
                      opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                SBFM <Wd>, <Wn>, #<immr>, #<imms>


                64-bit variant

                Applies when sf = 1 && N = 1.

                SBFM <Xd>, <Xn>, #<immr>, #<imms>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;

                 boolean inzero;
                 boolean extend;
                 integer R;
                 integer S;
                 bits(datasize) wmask;
                 bits(datasize) tmask;

                 case opc of
                     when '00' inzero = TRUE;      extend = TRUE;      // SBFM
                     when '01' inzero = FALSE; extend = FALSE;         // BFM
                     when '10' inzero = TRUE;      extend = FALSE;     // UBFM
                     when '11' UnallocatedEncoding();

                 if sf == '1' && N != '1' then ReservedValue();
                 if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();

                 R = UInt(immr);
                 S = UInt(imms);
                 (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-677
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Alias conditions


                          Alias                  of variant            is preferred when

                          ASR (immediate)        32-bit                imms == '011111'

                          ASR (immediate)        64-bit                imms == '111111'

                          SBFIZ                  -                     UInt(imms) < UInt(immr)

                          SBFX                   -                     BFXPreferred(sf, opc<1>, imms, immr)

                          SXTB                   -                     immr == '000000' && imms == '000111'

                          SXTH                   -                     immr == '000000' && imms == '001111'

                          SXTW                   -                     immr == '000000' && imms == '011111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <immr>          For the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the "immr" field.

                                       For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the "immr" field.

                       <imms>          For the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31,
                                       encoded in the "imms" field.

                                       For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63,
                                       encoded in the "imms" field.


                       Operation

                         bits(datasize) dst = if inzero then Zeros() else X[d];
                         bits(datasize) src = X[n];

                         // perform bitfield move on low bits
                         bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);

                         // determine extension bits (sign, zero or dest register)
                         bits(datasize) top = if extend then Replicate(src<S>) else dst;

                         // combine extension bits and result bits
                         X[d] = (top AND NOT(tmask)) OR (bot AND tmask);




C6-678                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.159    SBFX

                Signed bitfield extract

                This instruction is an alias of the SBFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SBFM.

                ·      The description of SBFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                  16 15                10 9            5 4              0
                   sf 0 0 1 0 0 1 1 0 N                   immr                imms                Rn              Rd
                      opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                SBFX <Wd>, <Wn>, #<lsb>, #<width>

                is equivalent to

                SBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)

                and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).

                64-bit variant

                Applies when sf = 1 && N = 1.

                SBFX <Xd>, <Xn>, #<lsb>, #<width>

                is equivalent to

                SBFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)

                and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <lsb>           For the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.

                                For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.

                <width>         For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

                                For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.


                Operation

                The description of SBFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-679
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.160       SDIV

                       Signed Divide divides a signed integer register value by a signed integer register value, and writes the result to the
                       destination register of the same size as source registers, 32-bit or 64-bit. The condition flags are not affected. That
                       is, it performs a signed divide: Rd = Rn / Rm.




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9              5 4              0
                           sf 0 0 1 1 0 1 0 1 1 0                   Rm         0 0 0 0 1 1              Rn              Rd
                                                                                              o1


                       32-bit variant

                       Applies when sf = 0.

                       SDIV <Wd>, <Wn>, <Wm>


                       64-bit variant

                       Applies when sf = 1.

                       SDIV <Xd>, <Xn>, <Xm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean unsigned = (o1 == '0');


                       Assembler symbols

                       <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.


                       Overflow

                       When using the 32-bit form of the instruction, if the signed integer division 0x8000 0000 / 0xFFFF FFFF is performed,
                       the pseudocode produces the intermediate integer result +231, that overflows the 32-bit signed integer range. No
                       indication of this overflow case is produced, and the 32-bit result written to <Rd> must be the bottom 32 bits of the
                       binary representation of +231. So the result of the division is 0x8000 0000.

                       Similarly, when using the 64-bit form of the instruction, if the signed integer division 0x8000 0000 0000 0000 /
                       0xFFFF FFFF FFFF FFFF is performed, the result of the division is 0x8000 0000 0000 0000.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         integer result;




C6-680                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                 if IsZero(operand2) then
                    result = 0;
                 else
                    result = RoundTowardsZero (Int(operand1, unsigned) / Int(operand2, unsigned));

                 X[d] = result<datasize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-681
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.161       SEV

                       Send event

                       This instruction is an alias of the HINT instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of HINT.

                       ·       The description of HINT gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11         8 7       5 4 3 2 1 0
                           1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 0 1 1 1 1 1
                                                                                             CRm       op2


                       System variant

                       SEV

                       is equivalent to

                       HINT #4

                       and is always the preferred disassembly.


                       Operation

                       The description of HINT gives the operational pseudocode for this instruction.




C6-682                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                      ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.162    SEVL

                Send event locally

                This instruction is an alias of the HINT instruction. This means that:

                ·      The encodings in this description are named to match the encodings of HINT.

                ·      The description of HINT gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11          8 7       5 4 3 2 1 0
                   1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 1 1 1 1 1
                                                                                      CRm      op2


                System variant

                SEVL

                is equivalent to

                HINT #5

                and is always the preferred disassembly.


                Operation

                The description of HINT gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-683
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.163       SMADDL

                       Signed multiply-add long: Xd = Xa + Wn * Wm

                       This instruction is used by the alias SMULL. See the Alias conditions table for details of when each alias is
                       preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9             5 4              0
                           1 0 0 1 1 0 1 1 0 0 1                   Rm         0       Ra               Rn             Rd
                                                    U                         o0


                       64-bit variant

                       SMADDL <Xd>, <Wn>, <Wm>, <Xa>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);
                         integer destsize = 64;
                         integer datasize = 32;
                         boolean sub_op = (o0 == '1');
                         boolean unsigned = (U == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            SMULL                     Ra == '11111'



                       Assembler symbols

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Xa>            Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the
                                       "Ra" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bits(destsize) operand3 = X[a];

                         integer result;

                         if sub_op then
                              result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
                         else




C6-684                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));

                 X[d] = result<63:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-685
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.164       SMC

                       Generate exception targeting exception level 3




                           31 30 29 28 27 26 25 24 23 22 21 20                                              5 4 3 2 1 0
                           1 1 0 1 0 1 0 0 0 0 0                                 imm16                         0 0 0 1 1




                       System variant

                       SMC #<imm>


                       Decode for this encoding

                         bits(16) imm = imm16;


                       Assembler symbols

                       <imm>           Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.


                       Operation

                         if !HaveEL(EL3) || PSTATE.EL == EL0 then
                              UnallocatedEncoding();

                         AArch64.CheckForSMCTrap(imm);

                         if SCR_EL3.SMD == '1' then
                              // SMC disabled
                              AArch64.UndefinedFault();
                         else
                              AArch64.CallSecureMonitor(imm);




C6-686                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                            ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.165    SMNEGL

                Signed multiply-negate long: Xd = -(Wn * Wm)

                This instruction is an alias of the SMSUBL instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SMSUBL.

                ·      The description of SMSUBL gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14          10 9             5 4              0
                   1 0 0 1 1 0 1 1 0 0 1                    Rm         1 1 1 1 1 1              Rn             Rd
                                             U                         o0      Ra


                64-bit variant

                SMNEGL <Xd>, <Wn>, <Wm>

                is equivalent to

                SMSUBL <Xd>, <Wn>, <Wm>, XZR

                and is always the preferred disassembly.


                Assembler symbols

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                the "Rm" field.


                Operation

                The description of SMSUBL gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-687
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.166       SMSUBL

                       Signed multiply-subtract long: Xd = Xa - Wn * Wm

                       This instruction is used by the alias SMNEGL. See the Alias conditions table for details of when each alias is
                       preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9             5 4              0
                           1 0 0 1 1 0 1 1 0 0 1                   Rm         1       Ra               Rn             Rd
                                                    U                         o0


                       64-bit variant

                       SMSUBL <Xd>, <Wn>, <Wm>, <Xa>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);
                         integer destsize = 64;
                         integer datasize = 32;
                         boolean sub_op = (o0 == '1');
                         boolean unsigned = (U == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            SMNEGL                    Ra == '11111'



                       Assembler symbols

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Xa>            Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the
                                       "Ra" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bits(destsize) operand3 = X[a];

                         integer result;

                         if sub_op then
                              result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
                         else




C6-688                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));

                 X[d] = result<63:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-689
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.167       SMULH

                       Signed multiply high: Xd = bits<127:64> of Xn * Xm




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14              10 9         5 4              0
                           1 0 0 1 1 0 1 1 0 1 0                   Rm         0 (1) (1) (1) (1) (1)    Rn             Rd
                                                    U                                  Ra


                       64-bit variant

                       SMULH <Xd>, <Xn>, <Xm>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);             // ignored by UMULH/SMULH
                         integer destsize = 64;
                         integer datasize = destsize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];

                         integer result;

                         result = Int(operand1, unsigned) * Int(operand2, unsigned);

                         X[d] = result<127:64>;




C6-690                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.168    SMULL

                Signed multiply long: Xd = Wn * Wm

                This instruction is an alias of the SMADDL instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SMADDL.

                ·      The description of SMADDL gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14          10 9             5 4              0
                   1 0 0 1 1 0 1 1 0 0 1                    Rm         0 1 1 1 1 1              Rn             Rd
                                             U                         o0      Ra


                64-bit variant

                SMULL <Xd>, <Wn>, <Wm>

                is equivalent to

                SMADDL <Xd>, <Wn>, <Wm>, XZR

                and is always the preferred disassembly.


                Assembler symbols

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                the "Rm" field.


                Operation

                The description of SMADDL gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-691
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.169       STLR

                       Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The
                       instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For
                       information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4            0
                           1 x 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)             Rn              Rt
                           size                     o2 L o1        Rs        o0       Rt2


                       32-bit variant

                       Applies when size = 10.

                       STLR <Wt>, [<Xn|SP>{,#0}]


                       64-bit variant

                       Applies when size = 11.

                       STLR <Xt>, [<Xn|SP>{,#0}]


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN



C6-692                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                    if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                            when Constraint_NONE       rt_unknown = FALSE;       // store original value
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                         if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                 // This atomic write will be rejected if it does not refer
                                 // to the same physical locations after address translation.
                                 Mem[address, dbytes, acctype] = data;
                                 status = ExclusiveMonitorsStatus();
                             X[s] = ZeroExtend(status, 32);
                         else
                            // store release register (atomic)
                             Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                         if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                             AArch64.SetExclusiveMonitors(address, dbytes);

                         if pair then
                            // load exclusive pair



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-693
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      assert excl;
                                      if rt_unknown then
                                         // ConstrainedUNPREDICTABLE case
                                         X[t]   = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                         // 32-bit load exclusive pair (atomic)
                                         data = Mem[address, dbytes, acctype];
                                         if BigEndian() then
                                              X[t]  = data<datasize-1:elsize>;
                                              X[t2] = data<elsize-1:0>;
                                         else
                                              X[t]  = data<elsize-1:0>;
                                              X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                         // 64-bit load exclusive pair (not atomic),
                                         // but must be 128-bit aligned
                                         if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                         X[t]   = Mem[address + 0, 8, acctype];
                                         X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-694                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                          ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                               C6.6 Alphabetical list of instructions



C6.6.170    STLRB

                Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has
                memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For information about
                memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14             10 9           5 4             0
                  0 0 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)            Rn              Rt
                  size                    o2 L o1          Rs       o0        Rt2


                No offset variant

                STLRB <Wt>, [<Xn|SP>{,#0}]


                Decode for this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);   // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Assembler symbols

                <Wt>          Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of
                         when Constraint_UNKNOWN      rt_unknown = TRUE;       // result is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                     if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                         case c of
                             when Constraint_UNKNOWN       rt_unknown = TRUE;       // store UNKNOWN value
                             when Constraint_NONE          rt_unknown = FALSE;      // store original value



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-695
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;



C6-696                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                          ID121714

                                                                                  C6 A64 Base Instruction Descriptions
                                                                                   C6.6 Alphabetical list of instructions



                         else
                              X[t]  = data<elsize-1:0>;
                              X[t2] = data<datasize-1:elsize>;
                      else // elsize == 64
                         // 64-bit load exclusive pair (not atomic),
                         // but must be 128-bit aligned
                         if address != Align(address, dbytes) then
                              iswrite = FALSE;
                              secondstage = FALSE;
                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                         X[t]   = Mem[address + 0, 8, acctype];
                         X[t2] = Mem[address + 8, 8, acctype];
                   else
                      // load {acquire} {exclusive} single register
                      data = Mem[address, dbytes, acctype];
                      X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e          Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-697
ID121714                                Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.171       STLRH

                       Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also
                       has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For information about
                       memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14            10 9             5 4            0
                           0 1 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)             Rn              Rt
                           size                     o2 L o1        Rs        o0       Rt2


                       No offset variant

                       STLRH <Wt>, [<Xn|SP>{,#0}]


                       Decode for this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN      rt_unknown = TRUE;       // store UNKNOWN value
                                      when Constraint_NONE         rt_unknown = FALSE;      // store original value



C6-698                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                          C6 A64 Base Instruction Descriptions
                                                                                            C6.6 Alphabetical list of instructions



                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();
                    if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                        case c of
                            when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                            when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                            when Constraint_UNDEF      UnallocatedEncoding();
                            when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 elsif rn_unknown then
                    address = bits(64) UNKNOWN;
                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                        if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                // This atomic write will be rejected if it does not refer
                                // to the same physical locations after address translation.
                                Mem[address, dbytes, acctype] = data;
                                status = ExclusiveMonitorsStatus();
                            X[s] = ZeroExtend(status, 32);
                        else
                            // store release register (atomic)
                            Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                        if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                            AArch64.SetExclusiveMonitors(address, dbytes);

                        if pair then
                            // load exclusive pair
                            assert excl;
                            if rt_unknown then
                                // ConstrainedUNPREDICTABLE case
                                X[t]   = bits(datasize) UNKNOWN;
                            elsif elsize == 32 then
                                // 32-bit load exclusive pair (atomic)
                                data = Mem[address, dbytes, acctype];
                                if BigEndian() then
                                    X[t]   = data<datasize-1:elsize>;
                                    X[t2] = data<elsize-1:0>;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-699
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                         else
                                              X[t]  = data<elsize-1:0>;
                                              X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                         // 64-bit load exclusive pair (not atomic),
                                         // but must be 128-bit aligned
                                         if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                         X[t]   = Mem[address + 0, 8, acctype];
                                         X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                      X[t] = ZeroExtend(data, regsize);




C6-700                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                          ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.172    STLXP

                Store-Release Exclusive Pair Of Registers stores two 32-bit words or two 64-bit doublewords to a memory location
                if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store
                was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-103. A 32-bit
                pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit
                pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword
                granularity. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on
                page B2-88. For information about memory accesses see Load/Store addressing modes on page C1-122.




                   31 30 29 28 27 26 25 24 23 22 21 20               16 15 14         10 9              5 4              0
                    1 x 0 0 1 0 0 0 0 0 1                    Rs         1       Rt2              Rn             Rt
                    size                    o2 L o1                     o0


                32-bit variant

                Applies when size = 10.

                STLXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]


                64-bit variant

                Applies when size = 11.

                STLXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);      // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXP on page J1-5411.


                Assembler symbols

                <Ws>            Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                is written, encoded in the "Rs" field. The value returned is:

                                0            If the operation updates memory.

                                1            If the operation fails to update memory.



                <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-701
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <Xt2>            Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                        field.

                       <Wt1>            Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt2>            Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                        field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       Aborts and alignment

                       If a synchronous Data Abort exception is generated by the execution of this instruction:

                       ·       Memory is not updated.

                       ·       <Ws> is not updated.

                       Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
                       exception to be generated, subject to the following rules:

                       ·       If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

                       ·       Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

                       If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                       synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;        // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                       when Constraint_UNKNOWN      rt_unknown = TRUE;       // store UNKNOWN value
                                       when Constraint_NONE         rt_unknown = FALSE;      // store original value
                                       when Constraint_UNDEF        UnallocatedEncoding();
                                       when Constraint_NOP          EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                       when Constraint_UNKNOWN      rn_unknown = TRUE;       // address is UNKNOWN
                                       when Constraint_NONE         rn_unknown = FALSE;      // address is original base
                                       when Constraint_UNDEF        UnallocatedEncoding();
                                       when Constraint_NOP          EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;



C6-702                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                   ID121714

                                                                                        C6 A64 Base Instruction Descriptions
                                                                                         C6.6 Alphabetical list of instructions



                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                        if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                // This atomic write will be rejected if it does not refer
                                // to the same physical locations after address translation.
                                Mem[address, dbytes, acctype] = data;
                                status = ExclusiveMonitorsStatus();
                            X[s] = ZeroExtend(status, 32);
                        else
                            // store release register (atomic)
                            Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                        if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                            AArch64.SetExclusiveMonitors(address, dbytes);

                        if pair then
                            // load exclusive pair
                            assert excl;
                            if rt_unknown then
                                // ConstrainedUNPREDICTABLE case
                                X[t]  = bits(datasize) UNKNOWN;
                            elsif elsize == 32 then
                                // 32-bit load exclusive pair (atomic)
                                data = Mem[address, dbytes, acctype];
                                if BigEndian() then
                                   X[t]   = data<datasize-1:elsize>;
                                   X[t2] = data<elsize-1:0>;
                                else
                                   X[t]   = data<elsize-1:0>;
                                   X[t2] = data<datasize-1:elsize>;
                            else // elsize == 64
                                // 64-bit load exclusive pair (not atomic),
                                // but must be 128-bit aligned
                                if address != Align(address, dbytes) then
                                   iswrite = FALSE;
                                   secondstage = FALSE;
                                   AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                X[t]  = Mem[address + 0, 8, acctype];
                                X[t2] = Mem[address + 8, 8, acctype];
                        else
                            // load {acquire} {exclusive} single register
                            data = Mem[address, dbytes, acctype];
                            X[t] = ZeroExtend(data, regsize);



ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-703
ID121714                                      Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.173       STLXR

                       Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive
                       access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1
                       if no store was performed. See Synchronization and semaphores on page B2-103. The memory access is atomic.
                       The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.
                       For information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14             10 9         5 4               0
                           1 x 0 0 1 0 0 0 0 0 0                    Rs         1 (1) (1) (1) (1) (1)  Rn               Rt
                           size                    o2 L o1                     o0       Rt2


                       32-bit variant

                       Applies when size = 10.

                       STLXR <Ws>, <Wt>, [<Xn|SP>{,#0}]


                       64-bit variant

                       Applies when size = 11.

                       STLXR <Ws>, <Xt>, [<Xn|SP>{,#0}]


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXR on page J1-5409.


                       Assembler symbols

                       <Ws>            Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                       is written, encoded in the "Rs" field. The value returned is:

                                       0            If the operation updates memory.

                                       1            If the operation fails to update memory.



                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.



C6-704                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                Aborts and alignment

                If a synchronous Data Abort exception is generated by the execution of this instruction:

                ·      Memory is not updated.

                ·      <Ws> is not updated.

                Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
                exception to be generated, subject to the following rules:

                ·      If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

                ·      Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

                If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                      Constraint c = ConstrainUnpredictable();
                      assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                      case c of
                          when Constraint_UNKNOWN      rt_unknown = TRUE;         // result is UNKNOWN
                          when Constraint_UNDEF        UnallocatedEncoding();
                          when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                      if s == t || (pair && s == t2) then
                          Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of
                               when Constraint_UNKNOWN       rt_unknown = TRUE;       // store UNKNOWN value
                               when Constraint_NONE          rt_unknown = FALSE;      // store original value
                               when Constraint_UNDEF         UnallocatedEncoding();
                               when Constraint_NOP           EndOfInstruction();
                      if s == n && n != 31 then
                          Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of
                               when Constraint_UNKNOWN       rn_unknown = TRUE;       // address is UNKNOWN
                               when Constraint_NONE          rn_unknown = FALSE;      // address is original base
                               when Constraint_UNDEF         UnallocatedEncoding();
                               when Constraint_NOP           EndOfInstruction();

                 if n == 31 then
                      CheckSPAlignment();
                      address = SP[];
                 elsif rn_unknown then
                      address = bits(64) UNKNOWN;
                 else
                      address = X[n];

                 case memop of
                      when MemOp_STORE
                          if rt_unknown then
                               data = bits(datasize) UNKNOWN;
                          elsif pair then




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-705
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;
                                           else
                                               X[t]  = data<elsize-1:0>;
                                               X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                           // 64-bit load exclusive pair (not atomic),
                                           // but must be 128-bit aligned
                                           if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                           X[t]  = Mem[address + 0, 8, acctype];
                                           X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                       X[t] = ZeroExtend(data, regsize);




C6-706                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.174    STLXRB

                Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access
                to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.
                See Synchronization and semaphores on page B2-103. The memory access is atomic. The instruction also has
                memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For information about
                memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15 14             10 9          5 4              0
                   0 0 0 0 1 0 0 0 0 0 0                     Rs         1 (1) (1) (1) (1) (1)   Rn                Rt
                   size                     o2 L o1                     o0       Rt2


                No offset variant

                STLXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]


                Decode for this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);      // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXRB on page J1-5409.


                Assembler symbols

                <Ws>            Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                is written, encoded in the "Rs" field. The value returned is:

                                0            If the operation updates memory.

                                1            If the operation fails to update memory.



                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                Aborts

                If a synchronous Data Abort exception is generated by the execution of this instruction:

                ·      Memory is not updated.

                ·      <Ws> is not updated.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-707
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                       synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                                      when Constraint_NONE       rt_unknown = FALSE;       // store original value
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP        EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;



C6-708                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                            ID121714

                                                                                       C6 A64 Base Instruction Descriptions
                                                                                        C6.6 Alphabetical list of instructions



                              status = ExclusiveMonitorsStatus();
                          X[s] = ZeroExtend(status, 32);
                      else
                          // store release register (atomic)
                          Mem[address, dbytes, acctype] = data;

                   when MemOp_LOAD
                      if excl then
                          // Tell the Exclusive Monitors to record a sequence of one or more atomic
                          // memory reads from virtual address range [address, address+dbytes-1].
                          // The Exclusive Monitor will only be set if all the reads are from the
                          // same dbytes-aligned physical address, to allow for the possibility of
                          // an atomicity break if the translation is changed between reads.
                          AArch64.SetExclusiveMonitors(address, dbytes);

                      if pair then
                          // load exclusive pair
                          assert excl;
                          if rt_unknown then
                              // ConstrainedUNPREDICTABLE case
                              X[t]  = bits(datasize) UNKNOWN;
                          elsif elsize == 32 then
                              // 32-bit load exclusive pair (atomic)
                              data = Mem[address, dbytes, acctype];
                              if BigEndian() then
                                  X[t]  = data<datasize-1:elsize>;
                                  X[t2] = data<elsize-1:0>;
                              else
                                  X[t]  = data<elsize-1:0>;
                                  X[t2] = data<datasize-1:elsize>;
                          else // elsize == 64
                              // 64-bit load exclusive pair (not atomic),
                              // but must be 128-bit aligned
                              if address != Align(address, dbytes) then
                                  iswrite = FALSE;
                                  secondstage = FALSE;
                                  AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                              X[t]  = Mem[address + 0, 8, acctype];
                              X[t2] = Mem[address + 8, 8, acctype];
                      else
                          // load {acquire} {exclusive} single register
                          data = Mem[address, dbytes, acctype];
                          X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-709
ID121714                                     Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.175       STLXRH

                       Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has
                       exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store
                       was performed. See Synchronization and semaphores on page B2-103. The memory access is atomic. The
                       instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88. For
                       information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20               16 15 14             10 9         5 4               0
                           0 1 0 0 1 0 0 0 0 0 0                     Rs         1 (1) (1) (1) (1) (1)   Rn              Rt
                           size                     o2 L o1                     o0       Rt2


                       No offset variant

                       STLXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]


                       Decode for this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);      // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly STLXRH on page J1-5409.


                       Assembler symbols

                       <Ws>             Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                        is written, encoded in the "Rs" field. The value returned is:

                                        0            If the operation updates memory.

                                        1            If the operation fails to update memory.



                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       Aborts and alignment

                       If a synchronous Data Abort exception is generated by the execution of this instruction:

                       ·       Memory is not updated.

                       ·       <Ws> is not updated.




C6-710                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                                             C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



                A non halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject
                to the following rules:

                ·      If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

                ·      Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

                If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of
                          when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                          when Constraint_UNDEF       UnallocatedEncoding();
                          when Constraint_NOP         EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                     if s == t || (pair && s == t2) then
                           Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of
                              when Constraint_UNKNOWN     rt_unknown = TRUE;       // store UNKNOWN value
                              when Constraint_NONE        rt_unknown = FALSE;      // store original value
                              when Constraint_UNDEF       UnallocatedEncoding();
                              when Constraint_NOP         EndOfInstruction();
                     if s == n && n != 31 then
                           Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of
                              when Constraint_UNKNOWN     rn_unknown = TRUE;       // address is UNKNOWN
                              when Constraint_NONE        rn_unknown = FALSE;      // address is original base
                              when Constraint_UNDEF       UnallocatedEncoding();
                              when Constraint_NOP         EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                     address = SP[];
                 elsif rn_unknown then
                     address = bits(64) UNKNOWN;
                 else
                     address = X[n];

                 case memop of
                     when MemOp_STORE
                          if rt_unknown then
                              data = bits(datasize) UNKNOWN;
                          elsif pair then
                              assert excl;
                              bits(datasize DIV 2) el1 = X[t];
                              bits(datasize DIV 2) el2 = X[t2];
                              data = if BigEndian() then el1 : el2 else el2 : el1;
                          else
                              data = X[t];

                          if excl then
                              // store {release} exclusive register|pair (atomic)
                              bit status = '1';



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-711
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;
                                           else
                                               X[t]  = data<elsize-1:0>;
                                               X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                           // 64-bit load exclusive pair (not atomic),
                                           // but must be 128-bit aligned
                                           if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                           X[t]  = Mem[address + 0, 8, acctype];
                                           X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                       X[t] = ZeroExtend(data, regsize);




C6-712                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.176    STNP

                Store pair of registers, with non-temporal hint




                  31 30 29 28 27 26 25 24 23 22 21                      15 14         10 9              5 4               0
                  x 0 1 0 1 0 0 0 0 0                       imm7                Rt2              Rn              Rt
                  opc                           L


                32-bit variant

                Applies when opc = 00.

                STNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]


                64-bit variant

                Applies when opc = 10.

                STNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]


                Decode for all variants of this encoding

                 boolean wback    = FALSE;
                 boolean postindex = FALSE;


                Assembler symbols

                <Wt1>           Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                <Wt2>           Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                field.

                <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt2>           Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>           For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
                                to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                                For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
                                to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2);
                 AccType acctype = AccType_STREAM;
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 if opc<0> == '1' then UnallocatedEncoding();
                 integer scale = 2 + UInt(opc<1>);
                 integer datasize = 8 << scale;
                 bits(64) offset = LSL(SignExtend(imm7, 64), scale);




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-713
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(64) address;
                         bits(datasize) data1;
                         bits(datasize) data2;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown && t == n then
                                      data1 = bits(datasize) UNKNOWN;
                                   else
                                      data1 = X[t];
                                   if rt_unknown && t2 == n then
                                      data2 = bits(datasize) UNKNOWN;
                                   else
                                      data2 = X[t2];
                                   Mem[address + 0     , dbytes, acctype] = data1;
                                   Mem[address + dbytes, dbytes, acctype] = data2;

                              when MemOp_LOAD
                                   data1 = Mem[address + 0     , dbytes, acctype];
                                   data2 = Mem[address + dbytes, dbytes, acctype];
                                   if rt_unknown then
                                      data1 = bits(datasize) UNKNOWN;
                                      data2 = bits(datasize) UNKNOWN;
                                   X[t]  = data1;
                                   X[t2] = data2;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-714                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.            ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                   ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.177    STP

                Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two
                32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about
                memory accesses see Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21                   15 14            10 9            5 4              0
                  x 0 1 0 1 0 0 0 1 0                     imm7                Rt2             Rn              Rt
                  opc                           L


                32-bit variant

                Applies when opc = 00.

                STP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>


                64-bit variant

                Applies when opc = 10.

                STP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>


                Decode for all variants of this encoding

                 boolean wback   = TRUE;
                 boolean postindex = TRUE;


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21                   15 14            10 9            5 4              0
                  x 0 1 0 1 0 0 1 1 0                     imm7                Rt2             Rn              Rt
                  opc                           L


                32-bit variant

                Applies when opc = 00.

                STP <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!


                64-bit variant

                Applies when opc = 10.

                STP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!


                Decode for all variants of this encoding

                 boolean wback   = TRUE;
                 boolean postindex = FALSE;


                Signed offset


                  31 30 29 28 27 26 25 24 23 22 21                   15 14            10 9            5 4              0
                  x 0 1 0 1 0 0 1 0 0                     imm7                Rt2             Rn              Rt
                  opc                           L




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-715
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       32-bit variant

                       Applies when opc = 00.

                       STP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]


                       64-bit variant

                       Applies when opc = 10.

                       STP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]


                       Decode for all variants of this encoding

                         boolean wback  = FALSE;
                         boolean postindex = FALSE;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly STP on page J1-5409.


                       Assembler symbols

                       <Wt1>           Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt2>           Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                       field.

                       <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt2>           Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                       field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>           For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
                                       multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.

                                       For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
                                       the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                                       For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
                                       multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.

                                       For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
                                       the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         if L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();
                         boolean signed = (opc<0> != '0');
                         integer scale = 2 + UInt(opc<1>);
                         integer datasize = 8 << scale;
                         bits(64) offset = LSL(SignExtend(imm7, 64), scale);




C6-716                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                Operation for all encodings

                 bits(64) address;
                 bits(datasize) data1;
                 bits(datasize) data2;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean wb_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;      // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;     // value stored is pre-writeback
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_LOAD && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                         if rt_unknown && t == n then
                            data1 = bits(datasize) UNKNOWN;
                         else
                            data1 = X[t];
                         if rt_unknown && t2 == n then
                            data2 = bits(datasize) UNKNOWN;
                         else
                            data2 = X[t2];
                         Mem[address + 0     , dbytes, acctype] = data1;
                         Mem[address + dbytes, dbytes, acctype] = data2;

                    when MemOp_LOAD
                         data1 = Mem[address + 0     , dbytes, acctype];
                         data2 = Mem[address + dbytes, dbytes, acctype];
                         if rt_unknown then
                            data1 = bits(datasize) UNKNOWN;
                            data2 = bits(datasize) UNKNOWN;
                         if signed then
                             X[t]  = SignExtend(data1, 64);
                             X[t2] = SignExtend(data2, 64);
                         else
                             X[t]  = data1;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-717
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                       X[t2] = data2;

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-718                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.178    STR (immediate)

                Store Register (immediate) calculates an address from a base register value and an immediate offset, and stores a
                32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory
                accesses see Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                  1 x 1 1 1 0 0 0 0 0 0                        imm9              0 1           Rn             Rt
                  size                      opc


                32-bit variant

                Applies when size = 10.

                STR <Wt>, [<Xn|SP>], #<simm>


                64-bit variant

                Applies when size = 11.

                STR <Xt>, [<Xn|SP>], #<simm>


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                         12 11 10 9              5 4             0
                  1 x 1 1 1 0 0 0 0 0 0                        imm9              1 1           Rn             Rt
                  size                      opc


                32-bit variant

                Applies when size = 10.

                STR <Wt>, [<Xn|SP>, #<simm>]!


                64-bit variant

                Applies when size = 11.

                STR <Xt>, [<Xn|SP>, #<simm>]!


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-719
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Unsigned offset


                           31 30 29 28 27 26 25 24 23 22 21                                   10 9              5 4             0
                           1 x 1 1 1 0 0 1 0 0                             imm12                       Rn                Rt
                           size                      opc


                       32-bit variant

                       Applies when size = 10.

                       STR <Wt>, [<Xn|SP>{, #<pimm>}]


                       64-bit variant

                       Applies when size = 11.

                       STR <Xt>, [<Xn|SP>{, #<pimm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>             Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
                                        to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.

                                        For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
                                        to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;




C6-720                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                   ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                           C6.6 Alphabetical list of instructions



                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation for all encodings

                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                         when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                         when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                         address = bits(64) UNKNOWN;
                    elsif postindex then
                         address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C6-721
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.179       STR (register)

                       Store Register (register) calculates an address from a base register value and an immediate offset, and stores a 32-bit
                       word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.

                       The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base
                       register value and an immediate offset. The offset can be optionally shifted and extended.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4              0
                           1 x 1 1 1 0 0 0 0 0 1                   Rm          option   S 1 0           Rn              Rt
                           size                      opc


                       32-bit variant

                       Applies when size = 10.

                       STR <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       64-bit variant

                       Applies when size = 11.

                       STR <Xt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W            when option = x10

                                       X            when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW         when option = 010

                                       LSL          when option = 011

                                       SXTW         when option = 110



C6-722                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



                              SXTX        when option = 111

                              It is RESERVED when:

                              ·      option = 00x.

                              ·      option = 10x.

                <amount>      For the 32-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #2          when S = 1

                              For the 64-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #3          when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                        when Constraint_WBSUPPRESS wback = FALSE;            // writeback is suppressed
                        when Constraint_UNKNOWN        wb_unknown = TRUE;    // writeback is UNKNOWN
                        when Constraint_UNDEF          UnallocatedEncoding();
                        when Constraint_NOP            EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-723
ID121714                                         Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-724                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.180    STRB (immediate)

                Store Register Byte (immediate) calculates an address from a base register value and an immediate offset, and stores
                a byte from a 32-bit register to the calculated address. For information about memory accesses see Load/Store
                addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                           12 11 10 9            5 4             0
                  0 0 1 1 1 0 0 0 0 0 0                           imm9             0 1         Rn            Rt
                   size                      opc


                Post-index variant

                STRB <Wt>, [<Xn|SP>], #<simm>


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                           12 11 10 9            5 4             0
                  0 0 1 1 1 0 0 0 0 0 0                           imm9             1 1         Rn            Rt
                   size                      opc


                Pre-index variant

                STRB <Wt>, [<Xn|SP>, #<simm>]!


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                    10 9            5 4             0
                  0 0 1 1 1 0 0 1 0 0                              imm12                       Rn            Rt
                   size                      opc


                Unsigned offset variant

                STRB <Wt>, [<Xn|SP>{, #<pimm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-725
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly STRB (immediate) on page J1-5408.


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded
                                        in the "imm12" field.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;           // writeback is suppressed
                                   when Constraint_UNKNOWN      wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();
                                   when Constraint_NOP          EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE         rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN      rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();



C6-726                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-727
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.181       STRB (register)

                       Store Register Byte (register) calculates an address from a base register value and an immediate offset, and stores a
                       byte from a 32-bit register to the calculated address. For information about memory accesses see Load/Store
                       addressing modes on page C1-122.

                       The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base
                       register value and an immediate offset. The offset can be optionally shifted and extended.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           0 0 1 1 1 0 0 0 0 0 1                   Rm          option   S 1 0           Rn              Rt
                           size                     opc


                       32-bit variant

                       STRB <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W            when option = x10

                                       X            when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW         when option = 010

                                       LSL          when option = 011

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.




C6-728                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                <amount>      Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                              "S" field. It can have the following values:

                              [absent]     when S = 0

                              #0           when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN      wb_unknown = TRUE;    // writeback is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE         rt_unknown = FALSE;   // value stored is original value
                         when Constraint_UNKNOWN      rt_unknown = TRUE;    // value stored is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-729
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-730                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.182    STRH (immediate)

                Store Register Halfword (immediate) calculates an address from a base register value and an immediate offset, and
                stores a halfword from a 32-bit register to the calculated address. For information about memory accesses see
                Load/Store addressing modes on page C1-122.


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9             5 4              0
                  0 1 1 1 1 0 0 0 0 0 0                          imm9               0 1        Rn             Rt
                   size                     opc


                Post-index variant

                STRH <Wt>, [<Xn|SP>], #<simm>


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9             5 4              0
                  0 1 1 1 1 0 0 0 0 0 0                          imm9               1 1        Rn             Rt
                   size                     opc


                Pre-index variant

                STRH <Wt>, [<Xn|SP>, #<simm>]!


                Decode for this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                    10 9            5 4              0
                  0 1 1 1 1 0 0 1 0 0                              imm12                       Rn             Rt
                   size                     opc


                Unsigned offset variant

                STRH <Wt>, [<Xn|SP>{, #<pimm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-731
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly STRH (immediate) on page J1-5408.


                       Assembler symbols

                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>           Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>           Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0
                                        and encoded in the "imm12" field as <pimm>/2.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_NORMAL;
                         MemOp memop;
                         boolean signed;
                         integer regsize;

                         if opc<1> == '0' then
                              // store or zero-extending load
                              memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                              regsize = if size == '11' then 64 else 32;
                              signed = FALSE;
                         else
                              if size == '11' then
                                   UnallocatedEncoding();
                              else
                                   // sign-extending load
                                   memop = MemOp_LOAD;
                                   if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation for all encodings

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;           // writeback is suppressed
                                   when Constraint_UNKNOWN      wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();
                                   when Constraint_NOP          EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE         rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN      rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF        UnallocatedEncoding();



C6-732                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        else
                            data = X[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                        if signed then
                             X[t] = SignExtend(data, regsize);
                        else
                             X[t] = ZeroExtend(data, regsize);

                    when MemOp_PREFETCH
                         Prefetch(address, t<4:0>);

                 if wback then
                    if wb_unknown then
                        address = bits(64) UNKNOWN;
                    elsif postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-733
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.183       STRH (register)

                       Store Register Halfword (register) calculates an address from a base register value and an immediate offset, and
                       stores a halfword from a 32-bit register to the calculated address. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.

                       The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base
                       register value and an offset register value. The offset can be optionally shifted and extended.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9             5 4             0
                           0 1 1 1 1 0 0 0 0 0 1                    Rm         option   S 1 0           Rn              Rt
                           size                     opc


                       32-bit variant

                       STRH <Wt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(size);
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <R>             Is the index width specifier, encoded in the "option" field. It can have the following values:

                                       W           when option = x10

                                       X           when option = x11

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.

                       <m>             Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                       field.

                       <extend>        Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                       the following values:

                                       UXTW        when option = 010

                                       LSL         when option = 011

                                       SXTW        when option = 110

                                       SXTX        when option = 111

                                       It is RESERVED when:

                                       ·      option = 00x.

                                       ·      option = 10x.




C6-734                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                <amount>      Is the index shift amount, optional and defaulting to #0 when <extend> is not LSL, encoded in the
                              "S" field. It can have the following values:

                              #0           when S = 0

                              #1           when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                    // store or zero-extending load
                    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                    regsize = if size == '11' then 64 else 32;
                    signed = FALSE;
                 else
                    if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                    else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;


                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 bits(64) address;
                 bits(datasize) data;
                 boolean wb_unknown = FALSE;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_WBSUPPRESS wback = FALSE;          // writeback is suppressed
                         when Constraint_UNKNOWN      wb_unknown = TRUE;    // writeback is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && wback && n == t && n != 31 then
                    c = ConstrainUnpredictable();
                    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_NONE         rt_unknown = FALSE;   // value stored is original value
                         when Constraint_UNKNOWN      rt_unknown = TRUE;    // value stored is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if n == 31 then
                    if memop != MemOp_PREFETCH then CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C6-735
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-736                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                         Non-Confidential - Beta                           ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.184    STTR

                Store Register (unprivileged) calculates an address from a base register value and an immediate offset, and stores a
                32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory
                accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9              5 4             0
                  1 x 1 1 1 0 0 0 0 0 0                         imm9               1 0         Rn               Rt
                  size                       opc


                32-bit variant

                Applies when size = 10.

                STTR <Wt>, [<Xn|SP>{, #<simm>}]


                64-bit variant

                Applies when size = 11.

                STTR <Xt>, [<Xn|SP>{, #<simm>}]


                Decode for all variants of this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>          Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                in the "imm9" field.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_UNPRIV;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                         UnallocatedEncoding();
                     else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-737
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   regsize = if opc<0> == '1' then 32 else 64;
                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-738                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.185    STTRB

                Store Register Byte (unprivileged) calculates an address from a base register value and an immediate offset, and
                stores a byte from a 32-bit register to the calculated address. For information about memory accesses see Load/Store
                addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                             12 11 10 9            5 4              0
                  0 0 1 1 1 0 0 0 0 0 0                             imm9              1 0        Rn              Rt
                   size                       opc


                Unscaled offset variant

                STTRB <Wt>, [<Xn|SP>{, #<simm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>           Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                 in the "imm9" field.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_UNPRIV;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                          UnallocatedEncoding();
                     else
                          // sign-extending load
                          memop = MemOp_LOAD;
                          if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                          regsize = if opc<0> == '1' then 32 else 64;
                          signed = TRUE;

                 integer datasize = 8 << scale;




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-739
ID121714                                             Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-740                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.186    STTRH

                Store Register Halfword (unprivileged) calculates an address from a base register value and an immediate offset,
                and stores a halfword from a 32-bit register to the calculated address. For information about memory accesses see
                Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9              5 4             0
                  0 1 1 1 1 0 0 0 0 0 0                          imm9              1 0         Rn               Rt
                  size                       opc


                Unscaled offset variant

                STTRH <Wt>, [<Xn|SP>{, #<simm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>          Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                in the "imm9" field.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_UNPRIV;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                         UnallocatedEncoding();
                     else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;
                         signed = TRUE;

                 integer datasize = 8 << scale;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-741
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-742                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.187    STUR

                Store register (unscaled offset)




                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9              5 4             0
                  1 x 1 1 1 0 0 0 0 0 0                         imm9               0 0         Rn               Rt
                  size                       opc


                32-bit variant

                Applies when size = 10.

                STUR <Wt>, [<Xn|SP>{, #<simm>}]


                64-bit variant

                Applies when size = 11.

                STUR <Xt>, [<Xn|SP>{, #<simm>}]


                Decode for all variants of this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>          Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                in the "imm9" field.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                         memop = MemOp_PREFETCH;
                         if opc<0> == '1' then UnallocatedEncoding();
                     else
                         // sign-extending load
                         memop = MemOp_LOAD;
                         if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                         regsize = if opc<0> == '1' then 32 else 64;



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-743
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                   signed = TRUE;

                         integer datasize = 8 << scale;


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-744                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.188    STURB

                Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores
                a byte to the calculated address, from a 32-bit register. For information about memory accesses see Load/Store
                addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                            12 11 10 9            5 4             0
                  0 0 1 1 1 0 0 0 0 0 0                          imm9               0 0         Rn              Rt
                   size                      opc


                Unscaled offset variant

                STURB <Wt>, [<Xn|SP>{, #<simm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>          Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                in the "imm9" field.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                          memop = MemOp_PREFETCH;
                          if opc<0> == '1' then UnallocatedEncoding();
                     else
                          // sign-extending load
                          memop = MemOp_LOAD;
                          if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                          regsize = if opc<0> == '1' then 32 else 64;
                          signed = TRUE;

                 integer datasize = 8 << scale;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-745
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-746                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.189    STURH

                Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and
                stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses see
                Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9             5 4              0
                  0 1 1 1 1 0 0 0 0 0 0                         imm9                0 0        Rn              Rt
                   size                      opc


                Unscaled offset variant

                STURH <Wt>, [<Xn|SP>{, #<simm>}]


                Decode for this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(size);
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Wt>           Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>        Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>         Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                               in the "imm9" field.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_NORMAL;
                 MemOp memop;
                 boolean signed;
                 integer regsize;

                 if opc<1> == '0' then
                     // store or zero-extending load
                     memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                     regsize = if size == '11' then 64 else 32;
                     signed = FALSE;
                 else
                     if size == '11' then
                          memop = MemOp_PREFETCH;
                          if opc<0> == '1' then UnallocatedEncoding();
                     else
                          // sign-extending load
                          memop = MemOp_LOAD;
                          if size == '10' && opc<0> == '1' then UnallocatedEncoding();
                          regsize = if opc<0> == '1' then 32 else 64;
                          signed = TRUE;

                 integer datasize = 8 << scale;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-747
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         boolean wb_unknown = FALSE;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_WBSUPPRESS wback = FALSE;         // writeback is suppressed
                                   when Constraint_UNKNOWN    wb_unknown = TRUE;     // writeback is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && wback && n == t && n != 31 then
                              c = ConstrainUnpredictable();
                              assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_NONE       rt_unknown = FALSE;    // value stored is original value
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;     // value stored is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              if memop != MemOp_PREFETCH then CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   else
                                      data = X[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   if signed then
                                       X[t] = SignExtend(data, regsize);
                                   else
                                       X[t] = ZeroExtend(data, regsize);

                              when MemOp_PREFETCH
                                   Prefetch(address, t<4:0>);

                         if wback then
                              if wb_unknown then
                                   address = bits(64) UNKNOWN;
                              elsif postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C6-748                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



C6.6.190    STXP

                Store Exclusive Pair Of Registers stores two 32-bit words or two 64-bit doublewords from two registers to a
                memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store
                was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-103. A 32-bit
                pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit
                pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword
                granularity. For information about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15 14         10 9              5 4              0
                  1 x 0 0 1 0 0 0 0 0 1                      Rs         0       Rt2              Rn             Rt
                  size                      o2 L o1                     o0


                32-bit variant

                Applies when size = 10.

                STXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]


                64-bit variant

                Applies when size = 11.

                STXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);      // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXP on page J1-5411.


                Assembler symbols

                <Ws>            Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                is written, encoded in the "Rs" field. The value returned is:

                                0            If the operation updates memory.

                                1            If the operation fails to update memory.



                <Xt1>           Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-749
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <Xt2>            Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                        field.

                       <Wt1>            Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt2>            Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
                                        field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       Aborts and alignment

                       If a synchronous Data Abort exception is generated by the execution of this instruction:

                       ·       Memory is not updated.

                       ·       <Ws> is not updated.

                       Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
                       exception to be generated, subject to the following rules:

                       ·       If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

                       ·       Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

                       If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                       synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;        // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                       when Constraint_UNKNOWN      rt_unknown = TRUE;       // store UNKNOWN value
                                       when Constraint_NONE         rt_unknown = FALSE;      // store original value
                                       when Constraint_UNDEF        UnallocatedEncoding();
                                       when Constraint_NOP          EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                       when Constraint_UNKNOWN      rn_unknown = TRUE;       // address is UNKNOWN
                                       when Constraint_NONE         rn_unknown = FALSE;      // address is original base
                                       when Constraint_UNDEF        UnallocatedEncoding();
                                       when Constraint_NOP          EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;



C6-750                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                   ID121714

                                                                                        C6 A64 Base Instruction Descriptions
                                                                                         C6.6 Alphabetical list of instructions



                 else
                    address = X[n];

                 case memop of
                    when MemOp_STORE
                        if rt_unknown then
                            data = bits(datasize) UNKNOWN;
                        elsif pair then
                            assert excl;
                            bits(datasize DIV 2) el1 = X[t];
                            bits(datasize DIV 2) el2 = X[t2];
                            data = if BigEndian() then el1 : el2 else el2 : el1;
                        else
                            data = X[t];

                        if excl then
                            // store {release} exclusive register|pair (atomic)
                            bit status = '1';
                            // Check whether the Exclusive Monitors are set to include the
                            // physical memory locations corresponding to virtual address
                            // range [address, address+dbytes-1].
                            if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                // This atomic write will be rejected if it does not refer
                                // to the same physical locations after address translation.
                                Mem[address, dbytes, acctype] = data;
                                status = ExclusiveMonitorsStatus();
                            X[s] = ZeroExtend(status, 32);
                        else
                            // store release register (atomic)
                            Mem[address, dbytes, acctype] = data;

                    when MemOp_LOAD
                        if excl then
                            // Tell the Exclusive Monitors to record a sequence of one or more atomic
                            // memory reads from virtual address range [address, address+dbytes-1].
                            // The Exclusive Monitor will only be set if all the reads are from the
                            // same dbytes-aligned physical address, to allow for the possibility of
                            // an atomicity break if the translation is changed between reads.
                            AArch64.SetExclusiveMonitors(address, dbytes);

                        if pair then
                            // load exclusive pair
                            assert excl;
                            if rt_unknown then
                                // ConstrainedUNPREDICTABLE case
                                X[t]  = bits(datasize) UNKNOWN;
                            elsif elsize == 32 then
                                // 32-bit load exclusive pair (atomic)
                                data = Mem[address, dbytes, acctype];
                                if BigEndian() then
                                   X[t]   = data<datasize-1:elsize>;
                                   X[t2] = data<elsize-1:0>;
                                else
                                   X[t]   = data<elsize-1:0>;
                                   X[t2] = data<datasize-1:elsize>;
                            else // elsize == 64
                                // 64-bit load exclusive pair (not atomic),
                                // but must be 128-bit aligned
                                if address != Align(address, dbytes) then
                                   iswrite = FALSE;
                                   secondstage = FALSE;
                                   AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                X[t]  = Mem[address + 0, 8, acctype];
                                X[t2] = Mem[address + 8, 8, acctype];
                        else
                            // load {acquire} {exclusive} single register
                            data = Mem[address, dbytes, acctype];
                            X[t] = ZeroExtend(data, regsize);



ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-751
ID121714                                      Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.191       STXR

                       Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has
                       exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store
                       was performed. See Synchronization and semaphores on page B2-103. For information about memory accesses see
                       Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14             10 9         5 4               0
                           1 x 0 0 1 0 0 0 0 0 0                    Rs         0 (1) (1) (1) (1) (1)    Rn             Rt
                           size                    o2 L o1                     o0       Rt2


                       32-bit variant

                       Applies when size = 10.

                       STXR <Ws>, <Wt>, [<Xn|SP>{,#0}]


                       64-bit variant

                       Applies when size = 11.

                       STXR <Ws>, <Xt>, [<Xn|SP>{,#0}]


                       Decode for all variants of this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);     // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Notes for all encodings

                       For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                       Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXR on page J1-5410.


                       Assembler symbols

                       <Ws>            Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                       is written, encoded in the "Rs" field. The value returned is:

                                       0            If the operation updates memory.

                                       1            If the operation fails to update memory.



                       <Xt>            Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.



C6-752                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                   ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                  C6.6 Alphabetical list of instructions



                Aborts and alignment

                If a synchronous Data Abort exception is generated by the execution of this instruction:

                ·      Memory is not updated.

                ·      <Ws> is not updated.

                Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
                exception to be generated, subject to the following rules:

                ·      If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

                ·      Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

                If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                      Constraint c = ConstrainUnpredictable();
                      assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                      case c of
                          when Constraint_UNKNOWN      rt_unknown = TRUE;         // result is UNKNOWN
                          when Constraint_UNDEF        UnallocatedEncoding();
                          when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                      if s == t || (pair && s == t2) then
                          Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of
                               when Constraint_UNKNOWN       rt_unknown = TRUE;       // store UNKNOWN value
                               when Constraint_NONE          rt_unknown = FALSE;      // store original value
                               when Constraint_UNDEF         UnallocatedEncoding();
                               when Constraint_NOP           EndOfInstruction();
                      if s == n && n != 31 then
                          Constraint c = ConstrainUnpredictable();
                          assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                          case c of
                               when Constraint_UNKNOWN       rn_unknown = TRUE;       // address is UNKNOWN
                               when Constraint_NONE          rn_unknown = FALSE;      // address is original base
                               when Constraint_UNDEF         UnallocatedEncoding();
                               when Constraint_NOP           EndOfInstruction();

                 if n == 31 then
                      CheckSPAlignment();
                      address = SP[];
                 elsif rn_unknown then
                      address = bits(64) UNKNOWN;
                 else
                      address = X[n];

                 case memop of
                      when MemOp_STORE
                          if rt_unknown then
                               data = bits(datasize) UNKNOWN;
                          elsif pair then
                               assert excl;
                               bits(datasize DIV 2) el1 = X[t];



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-753
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;
                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;
                                           else
                                               X[t]  = data<elsize-1:0>;
                                               X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                           // 64-bit load exclusive pair (not atomic),
                                           // but must be 128-bit aligned
                                           if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                           X[t]  = Mem[address + 0, 8, acctype];
                                           X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                       X[t] = ZeroExtend(data, regsize);




C6-754                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                    C6.6 Alphabetical list of instructions



C6.6.192    STXRB

                Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory
                address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See
                Synchronization and semaphores on page B2-103. The memory access is atomic.

                For information about memory accesses see Load/Store addressing modes on page C1-122.




                  31 30 29 28 27 26 25 24 23 22 21 20                16 15 14             10 9            5 4             0
                   0 0 0 0 1 0 0 0 0 0 0                     Rs         0 (1) (1) (1) (1) (1)     Rn              Rt
                   size                     o2 L o1                     o0       Rt2


                No offset variant

                STXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]


                Decode for this encoding

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2); // ignored by load/store single register
                 integer s = UInt(Rs);      // ignored by all loads and store-release

                 if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                 if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                 AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                 boolean excl = (o2 == '0');
                 boolean pair = (o1 == '1');
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer elsize = 8 << UInt(size);
                 integer regsize = if elsize == 64 then 64 else 32;
                 integer datasize = if pair then elsize * 2 else elsize;


                Notes for all encodings

                For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix J1
                Architectural Constraints on UNPREDICTABLE behaviors, and particularly STXRB on page J1-5410.


                Assembler symbols

                <Ws>            Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                is written, encoded in the "Rs" field. The value returned is:

                                0            If the operation updates memory.

                                1            If the operation fails to update memory.



                <Wt>            Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                Aborts

                If a synchronous Data Abort exception is generated by the execution of this instruction:

                ·      Memory is not updated.

                ·      <Ws> is not updated.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                        C6-755
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                       synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                       Operation

                         bits(64) address;
                         bits(datasize) data;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;
                         boolean rn_unknown = FALSE;

                         if memop == MemOp_LOAD && pair && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF      UnallocatedEncoding();
                                   when Constraint_NOP        EndOfInstruction();

                         if memop == MemOp_STORE && excl then
                              if s == t || (pair && s == t2) then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rt_unknown = TRUE;        // store UNKNOWN value
                                      when Constraint_NONE       rt_unknown = FALSE;       // store original value
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP        EndOfInstruction();
                              if s == n && n != 31 then
                                   Constraint c = ConstrainUnpredictable();
                                   assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                                   case c of
                                      when Constraint_UNKNOWN    rn_unknown = TRUE;        // address is UNKNOWN
                                      when Constraint_NONE       rn_unknown = FALSE;       // address is original base
                                      when Constraint_UNDEF      UnallocatedEncoding();
                                      when Constraint_NOP        EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         elsif rn_unknown then
                              address = bits(64) UNKNOWN;
                         else
                              address = X[n];

                         case memop of
                              when MemOp_STORE
                                   if rt_unknown then
                                      data = bits(datasize) UNKNOWN;
                                   elsif pair then
                                      assert excl;
                                      bits(datasize DIV 2) el1 = X[t];
                                      bits(datasize DIV 2) el2 = X[t2];
                                      data = if BigEndian() then el1 : el2 else el2 : el1;
                                   else
                                      data = X[t];

                                   if excl then
                                      // store {release} exclusive register|pair (atomic)
                                      bit status = '1';
                                      // Check whether the Exclusive Monitors are set to include the
                                      // physical memory locations corresponding to virtual address
                                      // range [address, address+dbytes-1].
                                      if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                           // This atomic write will be rejected if it does not refer
                                           // to the same physical locations after address translation.
                                           Mem[address, dbytes, acctype] = data;



C6-756                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                            ID121714

                                                                                       C6 A64 Base Instruction Descriptions
                                                                                        C6.6 Alphabetical list of instructions



                              status = ExclusiveMonitorsStatus();
                          X[s] = ZeroExtend(status, 32);
                      else
                          // store release register (atomic)
                          Mem[address, dbytes, acctype] = data;

                   when MemOp_LOAD
                      if excl then
                          // Tell the Exclusive Monitors to record a sequence of one or more atomic
                          // memory reads from virtual address range [address, address+dbytes-1].
                          // The Exclusive Monitor will only be set if all the reads are from the
                          // same dbytes-aligned physical address, to allow for the possibility of
                          // an atomicity break if the translation is changed between reads.
                          AArch64.SetExclusiveMonitors(address, dbytes);

                      if pair then
                          // load exclusive pair
                          assert excl;
                          if rt_unknown then
                              // ConstrainedUNPREDICTABLE case
                              X[t]  = bits(datasize) UNKNOWN;
                          elsif elsize == 32 then
                              // 32-bit load exclusive pair (atomic)
                              data = Mem[address, dbytes, acctype];
                              if BigEndian() then
                                  X[t]  = data<datasize-1:elsize>;
                                  X[t2] = data<elsize-1:0>;
                              else
                                  X[t]  = data<elsize-1:0>;
                                  X[t2] = data<datasize-1:elsize>;
                          else // elsize == 64
                              // 64-bit load exclusive pair (not atomic),
                              // but must be 128-bit aligned
                              if address != Align(address, dbytes) then
                                  iswrite = FALSE;
                                  secondstage = FALSE;
                                  AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                              X[t]  = Mem[address + 0, 8, acctype];
                              X[t2] = Mem[address + 8, 8, acctype];
                      else
                          // load {acquire} {exclusive} single register
                          data = Mem[address, dbytes, acctype];
                          X[t] = ZeroExtend(data, regsize);




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-757
ID121714                                     Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.193       STXRH

                       Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to
                       the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.
                       See Synchronization and semaphores on page B2-103. The memory access is atomic.

                       For information about memory accesses see Load/Store addressing modes on page C1-122.




                           31 30 29 28 27 26 25 24 23 22 21 20               16 15 14             10 9         5 4               0
                           0 1 0 0 1 0 0 0 0 0 0                     Rs         0 (1) (1) (1) (1) (1)  Rn               Rt
                           size                     o2 L o1                     o0       Rt2


                       No offset variant

                       STXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]


                       Decode for this encoding

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2); // ignored by load/store single register
                         integer s = UInt(Rs);      // ignored by all loads and store-release

                         if o2:o1:o0 == '100' || o2:o1:o0 == '11x' then UnallocatedEncoding();
                         if o1 == '1' && size<1> == '0' then UnallocatedEncoding();

                         AccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;
                         boolean excl = (o2 == '0');
                         boolean pair = (o1 == '1');
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer elsize = 8 << UInt(size);
                         integer regsize = if elsize == 64 then 64 else 32;
                         integer datasize = if pair then elsize * 2 else elsize;


                       Assembler symbols

                       <Ws>             Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
                                        is written, encoded in the "Rs" field. The value returned is:

                                        0            If the operation updates memory.

                                        1            If the operation fails to update memory.



                       <Wt>             Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>          Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       Aborts and alignment

                       If a synchronous Data Abort exception is generated by the execution of this instruction:

                       ·       Memory is not updated.

                       ·       <Ws> is not updated.

                       A non halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject
                       to the following rules:

                       ·       If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

                       ·       Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.



C6-758                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                                           C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
                synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.


                Operation

                 bits(64) address;
                 bits(datasize) data;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;
                 boolean rn_unknown = FALSE;

                 if memop == MemOp_LOAD && pair && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                     assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                     case c of
                         when Constraint_UNKNOWN      rt_unknown = TRUE;     // result is UNKNOWN
                         when Constraint_UNDEF        UnallocatedEncoding();
                         when Constraint_NOP          EndOfInstruction();

                 if memop == MemOp_STORE && excl then
                     if s == t || (pair && s == t2) then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                         case c of
                             when Constraint_UNKNOWN      rt_unknown = TRUE;      // store UNKNOWN value
                             when Constraint_NONE         rt_unknown = FALSE;     // store original value
                             when Constraint_UNDEF        UnallocatedEncoding();
                             when Constraint_NOP          EndOfInstruction();
                     if s == n && n != 31 then
                         Constraint c = ConstrainUnpredictable();
                         assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
                         case c of
                             when Constraint_UNKNOWN      rn_unknown = TRUE;      // address is UNKNOWN
                             when Constraint_NONE         rn_unknown = FALSE;     // address is original base
                             when Constraint_UNDEF        UnallocatedEncoding();
                             when Constraint_NOP          EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                     address = SP[];
                 elsif rn_unknown then
                     address = bits(64) UNKNOWN;
                 else
                     address = X[n];

                 case memop of
                     when MemOp_STORE
                         if rt_unknown then
                             data = bits(datasize) UNKNOWN;
                         elsif pair then
                             assert excl;
                             bits(datasize DIV 2) el1 = X[t];
                             bits(datasize DIV 2) el2 = X[t2];
                             data = if BigEndian() then el1 : el2 else el2 : el1;
                         else
                             data = X[t];

                         if excl then
                             // store {release} exclusive register|pair (atomic)
                             bit status = '1';
                             // Check whether the Exclusive Monitors are set to include the
                             // physical memory locations corresponding to virtual address
                             // range [address, address+dbytes-1].
                             if AArch64.ExclusiveMonitorsPass(address, dbytes) then
                                 // This atomic write will be rejected if it does not refer
                                 // to the same physical locations after address translation.
                                 Mem[address, dbytes, acctype] = data;



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-759
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                           status = ExclusiveMonitorsStatus();
                                       X[s] = ZeroExtend(status, 32);
                                   else
                                      // store release register (atomic)
                                       Mem[address, dbytes, acctype] = data;

                              when MemOp_LOAD
                                   if excl then
                                      // Tell the Exclusive Monitors to record a sequence of one or more atomic
                                      // memory reads from virtual address range [address, address+dbytes-1].
                                      // The Exclusive Monitor will only be set if all the reads are from the
                                      // same dbytes-aligned physical address, to allow for the possibility of
                                      // an atomicity break if the translation is changed between reads.
                                       AArch64.SetExclusiveMonitors(address, dbytes);

                                   if pair then
                                      // load exclusive pair
                                      assert excl;
                                      if rt_unknown then
                                           // ConstrainedUNPREDICTABLE case
                                           X[t]  = bits(datasize) UNKNOWN;
                                      elsif elsize == 32 then
                                           // 32-bit load exclusive pair (atomic)
                                           data = Mem[address, dbytes, acctype];
                                           if BigEndian() then
                                               X[t]  = data<datasize-1:elsize>;
                                               X[t2] = data<elsize-1:0>;
                                           else
                                               X[t]  = data<elsize-1:0>;
                                               X[t2] = data<datasize-1:elsize>;
                                      else // elsize == 64
                                           // 64-bit load exclusive pair (not atomic),
                                           // but must be 128-bit aligned
                                           if address != Align(address, dbytes) then
                                              iswrite = FALSE;
                                              secondstage = FALSE;
                                              AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                                           X[t]  = Mem[address + 0, 8, acctype];
                                           X[t2] = Mem[address + 8, 8, acctype];
                                   else
                                      // load {acquire} {exclusive} single register
                                      data = Mem[address, dbytes, acctype];
                                       X[t] = ZeroExtend(data, regsize);




C6-760                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                         Non-Confidential - Beta                                         ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.194    SUB (extended register)

                Subtract (extended register): Rd = Rn - LSL(extend(Rm), amount)




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15     13 12      10 9            5 4             0
                  sf 1 0 0 1 0 1 1 0 0 1                   Rm          option    imm3           Rn              Rd
                     op S


                32-bit variant

                Applies when sf = 0.

                SUB <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}


                64-bit variant

                Applies when sf = 1.

                SUB <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');
                 ExtendType extend_type = DecodeRegExtend(option);
                 integer shift = UInt(imm3);
                 if shift > 4 then ReservedValue();


                Assembler symbols

                <Wd|WSP>       Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                               field.

                <Wn|WSP>       Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                               field.

                <Wm>           Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd|SP>        Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                               field.

                <Xn|SP>        Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                               field.

                <R>            Is a width specifier, encoded in the "option" field. It can have the following values:

                               W           when option = 00x

                               W           when option = 010

                               X           when option = x11

                               W           when option = 10x

                               W           when option = 110

                <m>            Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
                               the "Rm" field.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-761
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <extend>        For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
                                       "option" field. It can have the following values:

                                       UXTB         when option = 000

                                       UXTH         when option = 001

                                       LSL|UXTW     when option = 010

                                       UXTX         when option = 011

                                       SXTB         when option = 100

                                       SXTH         when option = 101

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       If "Rd" or "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted
                                       when "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is
                                       '010'.

                                       For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
                                       "option" field. It can have the following values:

                                       UXTB         when option = 000

                                       UXTH         when option = 001

                                       UXTW         when option = 010

                                       LSL|UXTX     when option = 011

                                       SXTB         when option = 100

                                       SXTH         when option = 101

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       If "Rd" or "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when
                                       "imm3" is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.

                       <amount>        Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
                                       the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
                                       and is optional when <extend> is present but not LSL.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                         bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
                         bits(4) nzcv;
                         bit carry_in;

                         if sub_op then
                              operand2 = NOT(operand2);
                              carry_in = '1';
                         else
                              carry_in = '0';

                         (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                         if setflags then
                              PSTATE.<N,Z,C,V> = nzcv;

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-762                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                   ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.195    SUB (immediate)

                Subtract (immediate): Rd = Rn - shift(imm)




                  31 30 29 28 27 26 25 24 23 22 21                                   10 9             5 4              0
                  sf 1 0 1 0 0 0 1 shift                          imm12                        Rn             Rd
                     op S


                32-bit variant

                Applies when sf = 0.

                SUB <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}


                64-bit variant

                Applies when sf = 1.

                SUB <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');
                 bits(datasize) imm;

                 case shift of
                     when '00' imm = ZeroExtend(imm12, datasize);
                     when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);
                     when '1x' ReservedValue();


                Assembler symbols

                <Wd|WSP>      Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                              field.

                <Wn|WSP>      Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <Xd|SP>       Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
                              field.

                <Xn|SP>       Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                <imm>         Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

                <shift>       Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "shift"
                              field. It can have the following values:

                              LSL #0       when shift = 00

                              LSL #12      when shift = 01

                              It is RESERVED when shift = 1x.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                 bits(datasize) operand2 = imm;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-763
ID121714                                          Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                         bits(4) nzcv;
                         bit carry_in;

                         if sub_op then
                              operand2 = NOT(operand2);
                              carry_in = '1';
                         else
                              carry_in = '0';

                         (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                         if setflags then
                              PSTATE.<N,Z,C,V> = nzcv;

                         if d == 31 && !setflags then
                              SP[] = result;
                         else
                              X[d] = result;




C6-764                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                        Non-Confidential - Beta                           ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.196    SUB (shifted register)

                Subtract (shifted register): Rd = Rn - shift(Rm, amount)

                This instruction is used by the alias NEG (shifted register). See the Alias conditions table for details of when each
                alias is preferred.




                  31 30 29 28 27 26 25 24 23 22 21 20               16 15             10 9              5 4              0
                   sf 1 0 0 1 0 1 1 shift 0                  Rm              imm6                Rn              Rd
                      op S


                32-bit variant

                Applies when sf = 0.

                SUB <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                64-bit variant

                Applies when sf = 1.

                SUB <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');

                 if shift == '11' then ReservedValue();
                 if sf == '0' && imm6<5> == '1' then ReservedValue();

                 ShiftType shift_type = DecodeShift(shift);
                 integer shift_amount = UInt(imm6);


                Alias conditions


                                      Alias                     is preferred when

                                      NEG (shifted              Rn == '11111'
                                      register)


                Assembler symbols

                <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-765
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       <shift>         Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                                       in the "shift" field. It can have the following values:

                                       LSL          when shift = 00

                                       LSR          when shift = 01

                                       ASR          when shift = 10

                                       It is RESERVED when shift = 11.

                       <amount>        For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                       "imm6" field.

                                       For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                       "imm6" field.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
                         bits(4) nzcv;
                         bit carry_in;

                         if sub_op then
                              operand2 = NOT(operand2);
                              carry_in = '1';
                         else
                              carry_in = '0';

                         (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                         if setflags then
                              PSTATE.<N,Z,C,V> = nzcv;

                         X[d] = result;




C6-766                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                                                 C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.197    SUBS (extended register)

                Subtract (extended register), setting the condition flags: Rd = Rn - LSL(extend(Rm), amount)

                This instruction is used by the alias CMP (extended register). See the Alias conditions table for details of when each
                alias is preferred.




                  31 30 29 28 27 26 25 24 23 22 21 20               16 15     13 12      10 9            5 4             0
                   sf 1 1 0 1 0 1 1 0 0 1                    Rm          option    imm3           Rn              Rd
                      op S


                32-bit variant

                Applies when sf = 0.

                SUBS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}


                64-bit variant

                Applies when sf = 1.

                SUBS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer datasize = if sf == '1' then 64 else 32;
                 boolean sub_op = (op == '1');
                 boolean setflags = (S == '1');
                 ExtendType extend_type = DecodeRegExtend(option);
                 integer shift = UInt(imm3);
                 if shift > 4 then ReservedValue();


                Alias conditions


                                      Alias                     is preferred when

                                      CMP (extended             Rd == '11111'
                                      register)


                Assembler symbols

                <Wd>             Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn|WSP>         Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                 field.

                <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <Xd>             Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn|SP>          Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
                                 field.

                <R>              Is a width specifier, encoded in the "option" field. It can have the following values:

                                 W           when option = 00x



ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C6-767
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                       W            when option = 010

                                       X            when option = x11

                                       W            when option = 10x

                                       W            when option = 110

                       <m>             Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
                                       the "Rm" field.

                       <extend>        For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
                                       "option" field. It can have the following values:

                                       UXTB         when option = 000

                                       UXTH         when option = 001

                                       LSL|UXTW     when option = 010

                                       UXTX         when option = 011

                                       SXTB         when option = 100

                                       SXTH         when option = 101

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
                                       "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.

                                       For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
                                       "option" field. It can have the following values:

                                       UXTB         when option = 000

                                       UXTH         when option = 001

                                       UXTW         when option = 010

                                       LSL|UXTX     when option = 011

                                       SXTB         when option = 100

                                       SXTH         when option = 101

                                       SXTW         when option = 110

                                       SXTX         when option = 111

                                       If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
                                       is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.

                       <amount>        Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
                                       the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
                                       and is optional when <extend> is present but not LSL.


                       Operation

                         bits(datasize) result;
                         bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                         bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
                         bits(4) nzcv;
                         bit carry_in;

                         if sub_op then
                              operand2 = NOT(operand2);
                              carry_in = '1';
                         else
                              carry_in = '0';

                         (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                         if setflags then



C6-768                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    PSTATE.<N,Z,C,V> = nzcv;

                 if d == 31 && !setflags then
                     SP[] = result;
                 else
                     X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-769
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.198       SUBS (immediate)

                       Subtract (immediate), setting the condition flags: Rd = Rn - shift(imm)

                       This instruction is used by the alias CMP (immediate). See the Alias conditions table for details of when each alias
                       is preferred.




                           31 30 29 28 27 26 25 24 23 22 21                                   10 9             5 4             0
                           sf 1 1 1 0 0 0 1 shift                          imm12                        Rn             Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       SUBS <Wd>, <Wn|WSP>, #<imm>{, <shift>}


                       64-bit variant

                       Applies when sf = 1.

                       SUBS <Xd>, <Xn|SP>, #<imm>{, <shift>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');
                         bits(datasize) imm;

                         case shift of
                              when '00' imm = ZeroExtend(imm12, datasize);
                              when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);
                              when '1x' ReservedValue();


                       Alias conditions


                                            Alias                      is preferred when

                                            CMP (immediate)            Rd == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn|WSP>        Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn|SP>         Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

                       <imm>           Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

                       <shift>         Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "shift"
                                       field. It can have the following values:

                                       LSL #0       when shift = 00




C6-770                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                              LSL #12    when shift = 01

                              It is RESERVED when shift = 1x.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = if n == 31 then SP[] else X[n];
                 bits(datasize) operand2 = imm;
                 bits(4) nzcv;
                 bit carry_in;

                 if sub_op then
                     operand2 = NOT(operand2);
                     carry_in = '1';
                 else
                     carry_in = '0';

                 (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                 if setflags then
                     PSTATE.<N,Z,C,V> = nzcv;

                 if d == 31 && !setflags then
                     SP[] = result;
                 else
                     X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-771
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.199       SUBS (shifted register)

                       Subtract (shifted register), setting the condition flags: Rd = Rn - shift(Rm, amount)

                       This instruction is used by the aliases CMP (shifted register) and NEGS. See the Alias conditions table for details
                       of when each alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15             10 9           5 4              0
                           sf 1 1 0 1 0 1 1 shift 0                 Rm               imm6              Rn              Rd
                              op S


                       32-bit variant

                       Applies when sf = 0.

                       SUBS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}


                       64-bit variant

                       Applies when sf = 1.

                       SUBS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean sub_op = (op == '1');
                         boolean setflags = (S == '1');

                         if shift == '11' then ReservedValue();
                         if sf == '0' && imm6<5> == '1' then ReservedValue();

                         ShiftType shift_type = DecodeShift(shift);
                         integer shift_amount = UInt(imm6);


                       Alias conditions


                                            Alias                      is preferred when

                                            CMP (shifted               Rd == '11111'
                                            register)

                                            NEGS                       Rn == '11111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.




C6-772                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                               ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



                <Xm>          Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                <shift>       Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
                              in the "shift" field. It can have the following values:

                              LSL          when shift = 00

                              LSR          when shift = 01

                              ASR          when shift = 10

                              It is RESERVED when shift = 11.

                <amount>      For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                              "imm6" field.

                              For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                              "imm6" field.


                Operation

                 bits(datasize) result;
                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
                 bits(4) nzcv;
                 bit carry_in;

                 if sub_op then
                     operand2 = NOT(operand2);
                     carry_in = '1';
                 else
                     carry_in = '0';

                 (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

                 if setflags then
                     PSTATE.<N,Z,C,V> = nzcv;

                 X[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-773
ID121714                                           Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.200       SVC

                       Generate exception targeting exception level 1




                           31 30 29 28 27 26 25 24 23 22 21 20                                              5 4 3 2 1 0
                           1 1 0 1 0 1 0 0 0 0 0                                 imm16                         0 0 0 0 1




                       System variant

                       SVC #<imm>


                       Decode for this encoding

                         bits(16) imm = imm16;


                       Assembler symbols

                       <imm>           Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.


                       Operation

                         AArch64.CallSupervisor(imm);




C6-774                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                            ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.201    SXTB

                Signed extend byte: Rd = SignExtend(Wn<7:0>)

                This instruction is an alias of the SBFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SBFM.

                ·      The description of SBFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                16 15              10 9             5 4              0
                   sf 0 0 1 0 0 1 1 0 N 0 0 0 0 0 0 0 0 0 1 1 1                                Rn              Rd
                      opc                                immr              imms


                32-bit variant

                Applies when sf = 0 && N = 0.

                SXTB <Wd>, <Wn>

                is equivalent to

                SBFM <Wd>, <Wn>, #0, #7

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1 && N = 1.

                SXTB <Xd>, <Wn>

                is equivalent to

                SBFM <Xd>, <Xn>, #0, #7

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                Operation

                The description of SBFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-775
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.202       SXTH

                       Signed extend halfword: Rd = SignExtend(Wn<15:0>)

                       This instruction is an alias of the SBFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of SBFM.

                       ·       The description of SBFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21              16 15              10 9            5 4              0
                           sf 0 0 1 0 0 1 1 0 N 0 0 0 0 0 0 0 0 1 1 1 1                               Rn              Rd
                               opc                              immr              imms


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       SXTH <Wd>, <Wn>

                       is equivalent to

                       SBFM <Wd>, <Wn>, #0, #15

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1 && N = 1.

                       SXTH <Xd>, <Wn>

                       is equivalent to

                       SBFM <Xd>, <Xn>, #0, #15

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                       The description of SBFM gives the operational pseudocode for this instruction.




C6-776                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.203    SXTW

                Signed extend word: Xd = SignExtend(Wn<31:0>)

                This instruction is an alias of the SBFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SBFM.

                ·      The description of SBFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                16 15              10 9             5 4              0
                   1 0 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 1 1                                 Rn              Rd
                   sf opc                        N       immr              imms


                64-bit variant

                SXTW <Xd>, <Wn>

                is equivalent to

                SBFM <Xd>, <Xn>, #0, #31

                and is always the preferred disassembly.


                Assembler symbols

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                Operation

                The description of SBFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-777
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.204       SYS

                       System instruction

                       This instruction is used by the aliases AT, DC, IC, and TLBI. See the Alias conditions table for details of when each
                       alias is preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18       16 15         12 11        8 7      5 4             0
                           1 1 0 1 0 1 0 1 0 0 0 0 1                    op1        CRn         CRm        op2           Rt
                                                           L


                       System variant

                       SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}


                       Decode for this encoding

                         CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);

                         integer t = UInt(Rt);

                         integer sys_op0 = 1;
                         integer sys_op1 = UInt(op1);
                         integer sys_op2 = UInt(op2);
                         integer sys_crn = UInt(CRn);
                         integer sys_crm = UInt(CRm);
                         boolean has_result = (L == '1');


                       Alias conditions


                                             Alias                     is preferred when

                                             AT                        CRn == '0111' && CRm == '1000' &&
                                                                       SysOp(op1,'0111','1000',op2) == Sys_AT

                                             DC                        CRn == '0111' && SysOp(op1,'0111',CRm,op2) == Sys_DC

                                             IC                        CRn == '0111' && SysOp(op1,'0111',CRm,op2) == Sys_IC

                                             TLBI                      CRn == '1000' && SysOp(op1,'1000',CRm,op2) == Sys_TLBI



                       Assembler symbols

                       <op1>            Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

                       <Cn>             Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the "CRn" field.

                       <Cm>             Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

                       <op2>            Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

                       <Xt>             Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in
                                        the "Rt" field.




C6-778                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                  ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                Operation

                 if has_result then
                     X[t] = SysOp_R(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
                 else
                     SysOp_W(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-779
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.205       SYSL

                       System instruction with result




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15         12 11        8 7      5 4            0
                           1 1 0 1 0 1 0 1 0 0 1 0 1                   op1        CRn         CRm        op2          Rt
                                                          L


                       System variant

                       SYSL <Xt>, #<op1>, <Cn>, <Cm>, #<op2>


                       Decode for this encoding

                         CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);

                         integer t = UInt(Rt);

                         integer sys_op0 = 1;
                         integer sys_op1 = UInt(op1);
                         integer sys_op2 = UInt(op2);
                         integer sys_crn = UInt(CRn);
                         integer sys_crm = UInt(CRm);
                         boolean has_result = (L == '1');


                       Assembler symbols

                       <Xt>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rt" field.

                       <op1>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

                       <Cn>            Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the "CRn" field.

                       <Cm>            Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

                       <op2>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.


                       Operation

                         if has_result then
                              X[t] = SysOp_R(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
                         else
                              SysOp_W(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);




C6-780                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                ID121714

                                                                                                   C6 A64 Base Instruction Descriptions
                                                                                                     C6.6 Alphabetical list of instructions



C6.6.206    TBNZ

                Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally
                branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine
                call or return. This instruction does not affect condition flags.




                  31 30 29 28 27 26 25 24 23              19 18                                            5 4                0
                  b5 0 1 1 0 1 1 1                 b40                           imm14                                Rt
                                          op


                14-bit signed PC-relative branch offset variant

                TBNZ <R><t>, #<imm>, <label>


                Decode for this encoding

                 integer t = UInt(Rt);

                 integer datasize = if b5 == '1' then 64 else 32;
                 integer bit_pos = UInt(b5:b40);
                 bit bit_val = op;
                 bits(64) offset = SignExtend(imm14:'00', 64);


                Assembler symbols

                <R>              Is a width specifier, encoded in the "b5" field. It can have the following values:

                                 W            when b5 = 0

                                 X            when b5 = 1

                                 In assembler source code an 'X' specifier is always permitted, but a 'W' specifier is only permitted
                                 when the bit number is less than 32.

                <t>              Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in
                                 the "Rt" field.

                <imm>            Is the bit number to be tested, in the range 0 to 63, encoded in "b5:b40".

                <label>          Is the program label to be conditionally branched to. Its offset from the address of this instruction,
                                 in the range +/-32KB, is encoded as "imm14" times 4.


                Operation

                 bits(datasize) operand = X[t];

                 if operand<bit_pos> == bit_val then
                     BranchTo(PC[] + offset, BranchType_JMP);




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                          C6-781
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.207       TBZ

                       Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a
                       PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This
                       instruction does not affect condition flags.




                           31 30 29 28 27 26 25 24 23           19 18                                           5 4               0
                           b5 0 1 1 0 1 1 0              b40                           imm14                              Rt
                                                 op


                       14-bit signed PC-relative branch offset variant

                       TBZ <R><t>, #<imm>, <label>


                       Decode for this encoding

                         integer t = UInt(Rt);

                         integer datasize = if b5 == '1' then 64 else 32;
                         integer bit_pos = UInt(b5:b40);
                         bit bit_val = op;
                         bits(64) offset = SignExtend(imm14:'00', 64);


                       Assembler symbols

                       <R>             Is a width specifier, encoded in the "b5" field. It can have the following values:

                                       W           when b5 = 0

                                       X           when b5 = 1

                                       In assembler source code an 'X' specifier is always permitted, but a 'W' specifier is only permitted
                                       when the bit number is less than 32.

                       <t>             Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in
                                       the "Rt" field.

                       <imm>           Is the bit number to be tested, in the range 0 to 63, encoded in "b5:b40".

                       <label>         Is the program label to be conditionally branched to. Its offset from the address of this instruction,
                                       in the range +/-32KB, is encoded as "imm14" times 4.


                       Operation

                         bits(datasize) operand = X[t];

                         if operand<bit_pos> == bit_val then
                              BranchTo(PC[] + offset, BranchType_JMP);




C6-782                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                     ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.208    TLBI

                TLB invalidate operation

                This instruction is an alias of the SYS instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SYS.

                ·      The description of SYS gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18        16 15        12 11       8 7      5 4              0
                   1 1 0 1 0 1 0 1 0 0 0 0 1                   op1     1 0 0 0        CRm        op2           Rt
                                                    L                     CRn


                System variant

                TLBI <tlbi_op>{, <Xt>}

                is equivalent to

                SYS #<op1>, C8, <Cm>, #<op2>{, <Xt>}

                and is the preferred disassembly when SysOp(op1,'1000',CRm,op2) == Sys_TLBI.


                Assembler symbols

                <op1>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

                <Cm>            Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

                <op2>           Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

                <tlbi_op>       Is a TLBI operation name, as listed for the TLBI system operation group, encoded in the
                                "op1:CRm:op2" field. It can have the following values:

                                VMALLE1IS    when op1 = 000, CRm = 0011, op2 = 000

                                VAE1IS       when op1 = 000, CRm = 0011, op2 = 001

                                ASIDE1IS     when op1 = 000, CRm = 0011, op2 = 010

                                VAAE1IS      when op1 = 000, CRm = 0011, op2 = 011

                                VALE1IS      when op1 = 000, CRm = 0011, op2 = 101

                                VAALE1IS     when op1 = 000, CRm = 0011, op2 = 111

                                VMALLE1      when op1 = 000, CRm = 0111, op2 = 000

                                VAE1         when op1 = 000, CRm = 0111, op2 = 001

                                ASIDE1       when op1 = 000, CRm = 0111, op2 = 010

                                VAAE1        when op1 = 000, CRm = 0111, op2 = 011

                                VALE1        when op1 = 000, CRm = 0111, op2 = 101

                                VAALE1       when op1 = 000, CRm = 0111, op2 = 111

                                IPAS2E1IS    when op1 = 100, CRm = 0000, op2 = 001

                                IPAS2LE1IS when op1 = 100, CRm = 0000, op2 = 101

                                ALLE2IS      when op1 = 100, CRm = 0011, op2 = 000

                                VAE2IS       when op1 = 100, CRm = 0011, op2 = 001

                                ALLE1IS      when op1 = 100, CRm = 0011, op2 = 100

                                VALE2IS      when op1 = 100, CRm = 0011, op2 = 101



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-783
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                                       VMALLS12E1ISwhen op1 = 100, CRm = 0011, op2 = 110

                                       IPAS2E1     when op1 = 100, CRm = 0100, op2 = 001

                                       IPAS2LE1    when op1 = 100, CRm = 0100, op2 = 101

                                       ALLE2       when op1 = 100, CRm = 0111, op2 = 000

                                       VAE2        when op1 = 100, CRm = 0111, op2 = 001

                                       ALLE1       when op1 = 100, CRm = 0111, op2 = 100

                                       VALE2       when op1 = 100, CRm = 0111, op2 = 101

                                       VMALLS12E1 when op1 = 100, CRm = 0111, op2 = 110

                                       ALLE3IS     when op1 = 110, CRm = 0011, op2 = 000

                                       VAE3IS      when op1 = 110, CRm = 0011, op2 = 001

                                       VALE3IS     when op1 = 110, CRm = 0011, op2 = 101

                                       ALLE3       when op1 = 110, CRm = 0111, op2 = 000

                                       VAE3        when op1 = 110, CRm = 0111, op2 = 001

                                       VALE3       when op1 = 110, CRm = 0111, op2 = 101

                       <Xt>            Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in
                                       the "Rt" field.


                       Operation

                       The description of SYS gives the operational pseudocode for this instruction.




C6-784                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.209    TST (immediate)

                Test bits (immediate), setting the condition flags and discarding the result: Rn AND imm

                This instruction is an alias of the ANDS (immediate) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ANDS (immediate).

                ·      The description of ANDS (immediate) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                 16 15              10 9             5 4             0
                   sf 1 1 1 0 0 1 0 0 N                  immr               imms                Rn       1 1 1 1 1
                      opc                                                                                     Rd


                32-bit variant

                Applies when sf = 0 && N = 0.

                TST <Wn>, #<imm>

                is equivalent to

                ANDS WZR, <Wn>, #<imm>

                and is always the preferred disassembly.

                64-bit variant

                Applies when sf = 1.

                TST <Xn>, #<imm>

                is equivalent to

                ANDS XZR, <Xn>, #<imm>

                and is always the preferred disassembly.


                Assembler symbols

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <imm>           Is the bitmask immediate, encoded in "N:imms:immr".


                Operation

                The description of ANDS (immediate) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-785
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.210       TST (shifted register)

                       Test bits (shifted register), setting the condition flags and discarding the result: Rn AND shift(Rm, amount)

                       This instruction is an alias of the ANDS (shifted register) instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of ANDS (shifted register).

                       ·       The description of ANDS (shifted register) gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20               16 15              10 9             5 4            0
                           sf 1 1 0 1 0 1 0 shift 0                  Rm               imm6                Rn        1 1 1 1 1
                               opc                          N                                                             Rd


                       32-bit variant

                       Applies when sf = 0.

                       TST <Wn>, <Wm>{, <shift> #<amount>}

                       is equivalent to

                       ANDS WZR, <Wn>, <Wm>{, <shift> #<amount>}

                       and is always the preferred disassembly.

                       64-bit variant

                       Applies when sf = 1.

                       TST <Xn>, <Xm>{, <shift> #<amount>}

                       is equivalent to

                       ANDS XZR, <Xn>, <Xm>{, <shift> #<amount>}

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wn>             Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>             Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xn>             Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>             Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <shift>          Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
                                        field. It can have the following values:

                                        LSL          when shift = 00

                                        LSR          when shift = 01

                                        ASR          when shift = 10

                                        ROR          when shift = 11

                       <amount>         For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
                                        "imm6" field.

                                        For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
                                        "imm6" field.




C6-786                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                             C6.6 Alphabetical list of instructions



                Operation

                The description of ANDS (shifted register) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-787
ID121714                                        Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.211       UBFIZ

                       Unsigned bitfield insert in zero, with zeros to left and right

                       This instruction is an alias of the UBFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of UBFM.

                       ·       The description of UBFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21                16 15                10 9            5 4               0
                           sf 1 0 1 0 0 1 1 0 N                  immr                imms                Rn               Rd
                               opc


                       32-bit variant

                       Applies when sf = 0 && N = 0.

                       UBFIZ <Wd>, <Wn>, #<lsb>, #<width>

                       is equivalent to

                       UBFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)

                       and is the preferred disassembly when UInt(imms) < UInt(immr).

                       64-bit variant

                       Applies when sf = 1 && N = 1.

                       UBFIZ <Xd>, <Xn>, #<lsb>, #<width>

                       is equivalent to

                       UBFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)

                       and is the preferred disassembly when UInt(imms) < UInt(immr).


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <lsb>           For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.

                                       For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.

                       <width>         For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

                                       For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.


                       Operation

                       The description of UBFM gives the operational pseudocode for this instruction.




C6-788                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                   ID121714

                                                                                              C6 A64 Base Instruction Descriptions
                                                                                                C6.6 Alphabetical list of instructions



C6.6.212    UBFM

                Unsigned bitfield move, with zeros to left and right

                This instruction is used by the aliases LSL (immediate), LSR (immediate), UBFIZ, UBFX, UXTB, and UXTH. See
                the Alias conditions on page C6-790 table for details of when each alias is preferred.




                  31 30 29 28 27 26 25 24 23 22 21                16 15             10 9              5 4             0
                  sf 1 0 1 0 0 1 1 0 N                    immr              imms              Rn             Rd
                      opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                UBFM <Wd>, <Wn>, #<immr>, #<imms>


                64-bit variant

                Applies when sf = 1 && N = 1.

                UBFM <Xd>, <Xn>, #<immr>, #<imms>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer datasize = if sf == '1' then 64 else 32;

                 boolean inzero;
                 boolean extend;
                 integer R;
                 integer S;
                 bits(datasize) wmask;
                 bits(datasize) tmask;

                 case opc of
                     when '00' inzero = TRUE;      extend = TRUE;      // SBFM
                     when '01' inzero = FALSE; extend = FALSE;         // BFM
                     when '10' inzero = TRUE;      extend = FALSE;     // UBFM
                     when '11' UnallocatedEncoding();

                 if sf == '1' && N != '1' then ReservedValue();
                 if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();

                 R = UInt(immr);
                 S = UInt(imms);
                 (wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C6-789
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                       Alias conditions


                          Alias                  of variant            is preferred when

                          LSL (immediate)        32-bit                imms != '011111' && imms + 1 == immr

                          LSL (immediate)        64-bit                imms != '111111' && imms + 1 == immr

                          LSR (immediate)        32-bit                imms == '011111'

                          LSR (immediate)        64-bit                imms == '111111'

                          UBFIZ                  -                     UInt(imms) < UInt(immr)

                          UBFX                   -                     BFXPreferred(sf, opc<1>, imms, immr)

                          UXTB                   -                     immr == '000000' && imms == '000111'

                          UXTH                   -                     immr == '000000' && imms == '001111'



                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <immr>          For the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the "immr" field.

                                       For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the "immr" field.

                       <imms>          For the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31,
                                       encoded in the "imms" field.

                                       For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63,
                                       encoded in the "imms" field.


                       Operation

                         bits(datasize) dst = if inzero then Zeros() else X[d];
                         bits(datasize) src = X[n];

                         // perform bitfield move on low bits
                         bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);

                         // determine extension bits (sign, zero or dest register)
                         bits(datasize) top = if extend then Replicate(src<S>) else dst;

                         // combine extension bits and result bits
                         X[d] = (top AND NOT(tmask)) OR (bot AND tmask);




C6-790                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                  ID121714

                                                                                                  C6 A64 Base Instruction Descriptions
                                                                                                   C6.6 Alphabetical list of instructions



C6.6.213    UBFX

                Unsigned bitfield extract

                This instruction is an alias of the UBFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of UBFM.

                ·      The description of UBFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                  16 15                10 9            5 4              0
                   sf 1 0 1 0 0 1 1 0 N                   immr                imms                Rn              Rd
                      opc


                32-bit variant

                Applies when sf = 0 && N = 0.

                UBFX <Wd>, <Wn>, #<lsb>, #<width>

                is equivalent to

                UBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)

                and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).

                64-bit variant

                Applies when sf = 1 && N = 1.

                UBFX <Xd>, <Xn>, #<lsb>, #<width>

                is equivalent to

                UBFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)

                and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xn>            Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <lsb>           For the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.

                                For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.

                <width>         For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

                                For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.


                Operation

                The description of UBFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C6-791
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.214       UDIV

                       Unsigned Divide divides an unsigned integer register value by an unsigned integer register value, and writes the
                       result to the destination register of the same size as source registers, 32-bit or 64-bit. The condition flags are not
                       affected. That is, it performs n unsigned divide: Rd = Rn / Rm.




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                           sf 0 0 1 1 0 1 0 1 1 0                   Rm         0 0 0 0 1 0                Rn             Rd
                                                                                                o1


                       32-bit variant

                       Applies when sf = 0.

                       UDIV <Wd>, <Wn>, <Wm>


                       64-bit variant

                       Applies when sf = 1.

                       UDIV <Xd>, <Xn>, <Xm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer datasize = if sf == '1' then 64 else 32;
                         boolean unsigned = (o1 == '0');


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         integer result;

                         if IsZero(operand2) then
                              result = 0;
                         else
                              result = RoundTowardsZero (Int(operand1, unsigned) / Int(operand2, unsigned));

                         X[d] = result<datasize-1:0>;




C6-792                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.215    UMADDL

                Unsigned multiply-add long: Xd = Xa + Wn * Wm

                This instruction is used by the alias UMULL. See the Alias conditions table for details of when each alias is
                preferred.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14          10 9             5 4              0
                  1 0 0 1 1 0 1 1 1 0 1                     Rm         0       Ra               Rn             Rd
                                             U                         o0


                64-bit variant

                UMADDL <Xd>, <Wn>, <Wm>, <Xa>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer a = UInt(Ra);
                 integer destsize = 64;
                 integer datasize = 32;
                 boolean sub_op = (o0 == '1');
                 boolean unsigned = (U == '1');


                Alias conditions


                                     Alias                     is preferred when

                                     UMULL                     Ra == '11111'



                Assembler symbols

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                the "Rm" field.

                <Xa>            Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the
                                "Ra" field.


                Operation

                 bits(datasize) operand1 = X[n];
                 bits(datasize) operand2 = X[m];
                 bits(destsize) operand3 = X[a];

                 integer result;

                 if sub_op then
                     result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
                 else




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-793
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



                              result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));

                         X[d] = result<63:0>;




C6-794                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                ARM DDI 0487A.e
                                                        Non-Confidential - Beta                                        ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.216    UMNEGL

                Unsigned multiply-negate long: Xd = -(Wn * Wm)

                This instruction is an alias of the UMSUBL instruction. This means that:

                ·      The encodings in this description are named to match the encodings of UMSUBL.

                ·      The description of UMSUBL gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14          10 9             5 4              0
                   1 0 0 1 1 0 1 1 1 0 1                    Rm         1 1 1 1 1 1              Rn             Rd
                                             U                         o0      Ra


                64-bit variant

                UMNEGL <Xd>, <Wn>, <Wm>

                is equivalent to

                UMSUBL <Xd>, <Wn>, <Wm>, XZR

                and is always the preferred disassembly.


                Assembler symbols

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                the "Rm" field.


                Operation

                The description of UMSUBL gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-795
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.217       UMSUBL

                       Unsigned multiply-subtract long: Xd = Xa - Wn * Wm

                       This instruction is used by the alias UMNEGL. See the Alias conditions table for details of when each alias is
                       preferred.




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14          10 9             5 4              0
                           1 0 0 1 1 0 1 1 1 0 1                   Rm         1       Ra               Rn             Rd
                                                    U                         o0


                       64-bit variant

                       UMSUBL <Xd>, <Wn>, <Wm>, <Xa>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);
                         integer destsize = 64;
                         integer datasize = 32;
                         boolean sub_op = (o0 == '1');
                         boolean unsigned = (U == '1');


                       Alias conditions


                                            Alias                     is preferred when

                                            UMNEGL                    Ra == '11111'



                       Assembler symbols

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.

                       <Xa>            Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the
                                       "Ra" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];
                         bits(destsize) operand3 = X[a];

                         integer result;

                         if sub_op then
                              result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
                         else




C6-796                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                ID121714

                                                                                         C6 A64 Base Instruction Descriptions
                                                                                          C6.6 Alphabetical list of instructions



                    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));

                 X[d] = result<63:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C6-797
ID121714                                       Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.218       UMULH

                       Unsigned multiply high: Xd = bits<127:64> of Xn * Xm




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14              10 9         5 4              0
                           1 0 0 1 1 0 1 1 1 1 0                   Rm         0 (1) (1) (1) (1) (1)    Rn             Rd
                                                    U                                  Ra


                       64-bit variant

                       UMULH <Xd>, <Xn>, <Xm>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer a = UInt(Ra);             // ignored by UMULH/SMULH
                         integer destsize = 64;
                         integer datasize = destsize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xn>            Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                       the "Rn" field.

                       <Xm>            Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
                                       the "Rm" field.


                       Operation

                         bits(datasize) operand1 = X[n];
                         bits(datasize) operand2 = X[m];

                         integer result;

                         result = Int(operand1, unsigned) * Int(operand2, unsigned);

                         X[d] = result<127:64>;




C6-798                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                                 ID121714

                                                                                                C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.219    UMULL

                Unsigned multiply long: Xd = Wn * Wm

                This instruction is an alias of the UMADDL instruction. This means that:

                ·      The encodings in this description are named to match the encodings of UMADDL.

                ·      The description of UMADDL gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14          10 9             5 4              0
                   1 0 0 1 1 0 1 1 1 0 1                    Rm         0 1 1 1 1 1              Rn             Rd
                                             U                         o0      Ra


                64-bit variant

                UMULL <Xd>, <Wn>, <Wm>

                is equivalent to

                UMADDL <Xd>, <Wn>, <Wm>, XZR

                and is always the preferred disassembly.


                Assembler symbols

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
                                the "Rn" field.

                <Wm>            Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
                                the "Rm" field.


                Operation

                The description of UMADDL gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-799
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.220       UXTB

                       Unsigned extend byte: Wd = ZeroExtend(Wn<7:0>)

                       This instruction is an alias of the UBFM instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of UBFM.

                       ·       The description of UBFM gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21              16 15             10 9             5 4              0
                           0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1                                Rn              Rd
                           sf opc                       N       immr              imms


                       32-bit variant

                       UXTB <Wd>, <Wn>

                       is equivalent to

                       UBFM <Wd>, <Wn>, #0, #7

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                       The description of UBFM gives the operational pseudocode for this instruction.




C6-800                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                               ID121714

                                                                                               C6 A64 Base Instruction Descriptions
                                                                                                 C6.6 Alphabetical list of instructions



C6.6.221    UXTH

                Unsigned extend halfword: Wd = ZeroExtend(Wn<15:0>)

                This instruction is an alias of the UBFM instruction. This means that:

                ·      The encodings in this description are named to match the encodings of UBFM.

                ·      The description of UBFM gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21                16 15             10 9              5 4              0
                   0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 1                                 Rn              Rd
                   sf opc                        N       immr              imms


                32-bit variant

                UXTH <Wd>, <Wn>

                is equivalent to

                UBFM <Wd>, <Wn>, #0, #15

                and is always the preferred disassembly.


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Wn>            Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                Operation

                The description of UBFM gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C6-801
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.222       WFE

                       Wait for event

                       This instruction is an alias of the HINT instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of HINT.

                       ·       The description of HINT gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11         8 7       5 4 3 2 1 0
                           1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 0 1 1 1 1 1
                                                                                             CRm       op2


                       System variant

                       WFE

                       is equivalent to

                       HINT #2

                       and is always the preferred disassembly.


                       Operation

                       The description of HINT gives the operational pseudocode for this instruction.




C6-802                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                      ID121714

                                                                                            C6 A64 Base Instruction Descriptions
                                                                                              C6.6 Alphabetical list of instructions



C6.6.223    WFI

                Wait for interrupt

                This instruction is an alias of the HINT instruction. This means that:

                ·      The encodings in this description are named to match the encodings of HINT.

                ·      The description of HINT gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11          8 7       5 4 3 2 1 0
                   1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 1 1 1 1 1
                                                                                      CRm      op2


                System variant

                WFI

                is equivalent to

                HINT #3

                and is always the preferred disassembly.


                Operation

                The description of HINT gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C6-803
ID121714                                            Non-Confidential - Beta

C6 A64 Base Instruction Descriptions
C6.6 Alphabetical list of instructions



C6.6.224       YIELD

                       Yield hint

                       This instruction is an alias of the HINT instruction. This means that:

                       ·       The encodings in this description are named to match the encodings of HINT.

                       ·       The description of HINT gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11         8 7       5 4 3 2 1 0
                           1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 1 1 1 1 1 1
                                                                                             CRm       op2


                       System variant

                       YIELD

                       is equivalent to

                       HINT #1

                       and is always the preferred disassembly.


                       Operation

                       The description of HINT gives the operational pseudocode for this instruction.




C6-804                                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                      ID121714

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.1         ABS

                       Absolute value (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                            0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0                                  Rn             Rd
                                  U


                       Scalar variant

                       ABS <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size != '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;

                         boolean neg = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0                                  Rn             Rd
                                  U


                       Vector variant

                       ABS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean neg = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.


C7-810                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 integer element;

                 for e = 0 to elements-1
                     element = SInt(Elem[operand, e, esize]);
                     if neg then
                         element = -element;
                     else
                         element = Abs(element);
                     Elem[result, e, esize] = element<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-811
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.2         ADD (vector)

                       Add (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 0 1 1 1 1 0 size 1                   Rm         1 0 0 0 0 1               Rn             Rd
                                  U


                       Scalar variant

                       ADD <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size != '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean sub_op = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 0 0 1 1 1 0 size 1                   Rm         1 0 0 0 0 1               Rn             Rd
                                  U


                       Vector variant

                       ADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean sub_op = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.


C7-812                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     if sub_op then
                         Elem[result, e, esize] = element1 - element2;
                     else
                         Elem[result, e, esize] = element1 + element2;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-813
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.3         ADDHN, ADDHN2

                       Add returning high narrow




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          0 1 0 0 0 0               Rn               Rd
                                  U                                                    o1


                       Three registers, not all the same type variant

                       ADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o1 == '1');
                         boolean round = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.




C7-814                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand1 = V[n];
                 bits(2*datasize) operand2 = V[m];
                 bits(datasize)   result;
                 integer round_const = if round then 1 << (esize - 1) else 0;
                 bits(2*esize) element1;
                 bits(2*esize) element2;
                 bits(2*esize) sum;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, 2*esize];
                     element2 = Elem[operand2, e, 2*esize];
                     if sub_op then
                         sum = element1 - element2;
                     else
                         sum = element1 + element2;
                     sum = sum + round_const;
                     Elem[result, e, esize] = sum<2*esize-1:esize>;

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-815
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.4         ADDP (scalar)

                       Add pair of elements (scalar)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4            0
                            0 1 0 1 1 1 1 0 size 1 1 0 0 0 1 1 0 1 1 1 0                                  Rn               Rd




                       Advanced SIMD variant

                       ADDP <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size != '11' then ReservedValue();

                         integer esize = 8 << UInt(size);
                         integer datasize = esize * 2;
                         integer elements = 2;

                         ReduceOp op = ReduceOp_ADD;


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is the source arrangement specifier, encoded in the "size" field. It can have the following values:

                                         2D          when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         V[d] = Reduce(op, operand, esize);




C7-816                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.5      ADDP (vector)

                Add pairwise (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 1                 Rm         1 0 1 1 1 1               Rn              Rd




                Three registers of the same type variant

                ADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[concat, 2*e, esize];
                     element2 = Elem[concat, (2*e)+1, esize];
                     Elem[result, e, esize] = element1 + element2;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-817
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.6         ADDV

                       Add across vector




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4            0
                            0 Q 0 0 1 1 1 0 size 1 1 0 0 0 1 1 0 1 1 1 0                                  Rn               Rd




                       Advanced SIMD variant

                       ADDV <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size:Q == '100' then ReservedValue();
                         if size == '11' then ReservedValue();

                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         ReduceOp op = ReduceOp_ADD;


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 10, Q = 0.

                                         ·      size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         V[d] = Reduce(op, operand, esize);




C7-818                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.7      AESD

                AES single round decryption




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 1 0                                Rn             Rd
                                                                           D


                Advanced SIMD variant

                AESD <Vd>.16B, <Vn>.16B


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 if ! HaveCryptoExt() then UnallocatedEncoding();
                 boolean decrypt = (D == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the second SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(128) operand1 = V[d];
                 bits(128) operand2 = V[n];
                 bits(128) result;
                 result = operand1 EOR operand2;
                 if decrypt then
                     result = AESInvSubBytes(AESInvShiftRows(result));
                 else
                     result = AESSubBytes(AESShiftRows(result));

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-819
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.8         AESE

                       AES single round encryption




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             5 4             0
                            0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0                              Rn             Rd
                                                                                      D


                       Advanced SIMD variant

                       AESE <Vd>.16B, <Vn>.16B


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         if ! HaveCryptoExt() then UnallocatedEncoding();
                         boolean decrypt = (D == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the second SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) operand1 = V[d];
                         bits(128) operand2 = V[n];
                         bits(128) result;
                         result = operand1 EOR operand2;
                         if decrypt then
                              result = AESInvSubBytes(AESInvShiftRows(result));
                         else
                              result = AESSubBytes(AESShiftRows(result));

                         V[d] = result;




C7-820                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                            ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.9      AESIMC

                AES inverse mix columns




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0                                Rn             Rd
                                                                           D


                Advanced SIMD variant

                AESIMC <Vd>.16B, <Vn>.16B


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 if ! HaveCryptoExt() then UnallocatedEncoding();
                 boolean decrypt = (D == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(128) operand = V[n];
                 bits(128) result;
                 if decrypt then
                     result = AESInvMixColumns(operand);
                 else
                     result = AESMixColumns(operand);
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-821
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.10        AESMC

                       AES mix columns




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             5 4         0
                            0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 1 0 1 0                              Rn             Rd
                                                                                      D


                       Advanced SIMD variant

                       AESMC <Vd>.16B, <Vn>.16B


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         if ! HaveCryptoExt() then UnallocatedEncoding();
                         boolean decrypt = (D == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) operand = V[n];
                         bits(128) result;
                         if decrypt then
                              result = AESInvMixColumns(operand);
                         else
                              result = AESMixColumns(operand);
                         V[d] = result;




C7-822                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                       ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.11     AND (vector)

                Bitwise AND (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 0 0 1 1 1 0 0 0 1                  Rm         0 0 0 1 1 1               Rn             Rd
                                          size


                Three registers of the same type variant

                AND <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean invert = (size<0> == '1');
                 LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                              8B          when Q = 0

                              16B         when Q = 1

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;

                 if invert then operand2 = NOT(operand2);

                 case op of
                     when LogicalOp_AND
                        result = operand1 AND operand2;
                     when LogicalOp_ORR
                        result = operand1 OR operand2;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-823
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.12        BIC (vector, immediate)

                       Bitwise bit clear (vector, immediate)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15           12 11 10 9 8 7 6 5 4                    0
                            0 Q 1 0 1 1 1 1 0 0 0 0 0 a b c x x x 1 0 1 d e f g h                                        Rd
                                 op                                             cmode


                       16-bit variant

                       Applies when cmode = 10x1.

                       BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}


                       32-bit variant

                       Applies when cmode = 0xx1.

                       BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}


                       Decode for all variants of this encoding

                         integer rd = UInt(Rd);

                         integer datasize = if Q == '1' then 128 else 64;
                         bits(datasize) imm;
                         bits(64) imm64;

                         ImmediateOp operation;
                         case cmode:op of
                              when '0xx00' operation = ImmediateOp_MOVI;
                              when '0xx01' operation = ImmediateOp_MVNI;
                              when '0xx10' operation = ImmediateOp_ORR;
                              when '0xx11' operation = ImmediateOp_BIC;
                              when '10x00' operation = ImmediateOp_MOVI;
                              when '10x01' operation = ImmediateOp_MVNI;
                              when '10x10' operation = ImmediateOp_ORR;
                              when '10x11' operation = ImmediateOp_BIC;
                              when '110x0' operation = ImmediateOp_MOVI;
                              when '110x1' operation = ImmediateOp_MVNI;
                              when '1110x' operation = ImmediateOp_MOVI;
                              when '11110' operation = ImmediateOp_MOVI;
                              when '11111'
                                   // FMOV Dn,#imm is in main FP instruction set
                                   if Q == '0' then UnallocatedEncoding();
                                   operation = ImmediateOp_MOVI;

                         imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
                         imm = Replicate(imm64, datasize DIV 64);


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP register, encoded in the "Rd" field.

                       <T>               For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                                         following values:

                                         4H         when Q = 0

                                         8H         when Q = 1




C7-824                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                              following values:

                              2S           when Q = 0

                              4S           when Q = 1

                <imm8>        Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

                <amount>      For the 16-bit variant: is the shift amount encoded in the "cmode<1>" field. It can have the
                              following values:

                              0            when cmode<1> = 0

                              8            when cmode<1> = 1

                              defaulting to 0 if LSL is omitted.

                              For the 32-bit variant: is the shift amount encoded in the "cmode<2:1>" field. It can have the
                              following values:

                              0            when cmode<2:1> = 00

                              8            when cmode<2:1> = 01

                              16           when cmode<2:1> = 10

                              24           when cmode<2:1> = 11

                              defaulting to 0 if LSL is omitted.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand;
                 bits(datasize) result;

                 case operation of
                    when ImmediateOp_MOVI
                         result = imm;
                    when ImmediateOp_MVNI
                         result = NOT(imm);
                    when ImmediateOp_ORR
                         operand = V[rd];
                         result = operand OR imm;
                    when ImmediateOp_BIC
                        operand = V[rd];
                        result = operand AND NOT(imm);

                 V[rd] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-825
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.13        BIC (vector, register)

                       Bitwise bit clear (vector, register)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4            0
                            0 Q 0 0 1 1 1 0 0 1 1                   Rm         0 0 0 1 1 1              Rn              Rd
                                                     size


                       Three registers of the same type variant

                       BIC <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean invert = (size<0> == '1');
                         LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                         8B          when Q = 0

                                         16B         when Q = 1

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND
                                   result = operand1 AND operand2;
                              when LogicalOp_ORR
                                   result = operand1 OR operand2;

                         V[d] = result;




C7-826                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.14     BIF

                Bitwise insert if false




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 1 0 1 1 1 0 1 1 1                    Rm         0 0 0 1 1 1               Rn             Rd
                                             opc2


                Three registers of the same type variant

                BIF <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 VBitOp op;

                 case opc2 of
                     when '00' op = VBitOp_VEOR;
                     when '01' op = VBitOp_VBSL;
                     when '10' op = VBitOp_VBIT;
                     when '11' op = VBitOp_VBIF;


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                8B          when Q = 0

                                16B         when Q = 1

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>            Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1;
                 bits(datasize) operand2;
                 bits(datasize) operand3;
                 bits(datasize) operand4 = V[n];

                 case op of
                     when VBitOp_VEOR
                         operand1 = V[m];
                         operand2 = Zeros();
                         operand3 = Ones();
                     when VBitOp_VBSL
                         operand1 = V[m];
                         operand2 = operand1;
                         operand3 = V[d];
                     when VBitOp_VBIT
                         operand1 = V[d];



ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-827
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   operand2 = operand1;
                                   operand3 = V[m];
                              when VBitOp_VBIF
                                   operand1 = V[d];
                                   operand2 = operand1;
                                   operand3 = NOT(V[m]);

                         V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);




C7-828                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.15     BIT

                Bitwise insert if true




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 1 0 1 1 1 0 1 0 1                    Rm         0 0 0 1 1 1               Rn             Rd
                                             opc2


                Three registers of the same type variant

                BIT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 VBitOp op;

                 case opc2 of
                     when '00' op = VBitOp_VEOR;
                     when '01' op = VBitOp_VBSL;
                     when '10' op = VBitOp_VBIT;
                     when '11' op = VBitOp_VBIF;


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                8B          when Q = 0

                                16B         when Q = 1

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>            Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1;
                 bits(datasize) operand2;
                 bits(datasize) operand3;
                 bits(datasize) operand4 = V[n];

                 case op of
                     when VBitOp_VEOR
                         operand1 = V[m];
                         operand2 = Zeros();
                         operand3 = Ones();
                     when VBitOp_VBSL
                         operand1 = V[m];
                         operand2 = operand1;
                         operand3 = V[d];
                     when VBitOp_VBIT
                         operand1 = V[d];



ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-829
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   operand2 = operand1;
                                   operand3 = V[m];
                              when VBitOp_VBIF
                                   operand1 = V[d];
                                   operand2 = operand1;
                                   operand3 = NOT(V[m]);

                         V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);




C7-830                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.16     BSL

                Bitwise select




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 1 0 1 1 1 0 0 1 1                  Rm         0 0 0 1 1 1               Rn             Rd
                                          opc2


                Three registers of the same type variant

                BSL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 VBitOp op;

                 case opc2 of
                     when '00' op = VBitOp_VEOR;
                     when '01' op = VBitOp_VBSL;
                     when '10' op = VBitOp_VBIT;
                     when '11' op = VBitOp_VBIF;


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                              8B          when Q = 0

                              16B         when Q = 1

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1;
                 bits(datasize) operand2;
                 bits(datasize) operand3;
                 bits(datasize) operand4 = V[n];

                 case op of
                     when VBitOp_VEOR
                         operand1 = V[m];
                         operand2 = Zeros();
                         operand3 = Ones();
                     when VBitOp_VBSL
                         operand1 = V[m];
                         operand2 = operand1;
                         operand3 = V[d];
                     when VBitOp_VBIT
                         operand1 = V[d];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-831
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   operand2 = operand1;
                                   operand3 = V[m];
                              when VBitOp_VBIF
                                   operand1 = V[d];
                                   operand2 = operand1;
                                   operand3 = NOT(V[m]);

                         V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);




C7-832                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.17     CLS (vector)

                Count leading sign bits (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4           0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 0 0 1 0                                 Rn              Rd
                        U


                Vector variant

                CLS <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1

                               It is RESERVED when size = 11, Q = x.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;

                 integer count;
                 for e = 0 to elements-1
                     if countop == CountOp_CLS then
                         count = CountLeadingSignBits(Elem[operand, e, esize]);
                     else
                         count = CountLeadingZeroBits(Elem[operand, e, esize]);
                     Elem[result, e, esize] = count<esize-1:0>;
                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-833
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.18        CLZ (vector)

                       Count leading zero bits (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4             0
                            0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 1 0 0 1 0                                 Rn              Rd
                                  U


                       Vector variant

                       CLZ <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;

                         integer count;
                         for e = 0 to elements-1
                              if countop == CountOp_CLS then
                                   count = CountLeadingSignBits(Elem[operand, e, esize]);
                              else
                                   count = CountLeadingZeroBits(Elem[operand, e, esize]);
                              Elem[result, e, esize] = count<esize-1:0>;
                         V[d] = result;




C7-834                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.19     CMEQ (register)

                Compare bitwise equal (vector), setting destination vector element to all ones if the condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4           0
                  0 1 1 1 1 1 1 0 size 1                  Rm         1 0 0 0 1 1                Rn             Rd
                        U


                Scalar variant

                CMEQ <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean and_test = (U == '0');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                  Rm         1 0 0 0 1 1                Rn             Rd
                        U


                Vector variant

                CMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean and_test = (U == '0');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D           when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-835
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if and_test then
                                   test_passed = !IsZero(element1 AND element2);
                              else
                                   test_passed = (element1 == element2);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-836                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.20     CMEQ (zero)

                Compare bitwise equal to zero (vector), setting destination vector element to all ones if the condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4              0
                  0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0                                  Rn               Rd
                        U                                                      op


                Scalar variant

                CMEQ <V><d>, <V><n>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4              0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0                                  Rn               Rd
                        U                                                      op


                Vector variant

                CMEQ <Vd>.<T>, <Vn>.<T>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                        C7-837
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              case comparison of
                                   when CompareOp_GT test_passed = element > 0;
                                   when CompareOp_GE test_passed = element >= 0;
                                   when CompareOp_EQ test_passed = element == 0;
                                   when CompareOp_LE test_passed = element <= 0;
                                   when CompareOp_LT test_passed = element < 0;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-838                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.21     CMGE (register)

                Compare signed greater than or equal (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 size 1                  Rm         0 0 1 1 1 1               Rn             Rd
                        U                                                          eq


                Scalar variant

                CMGE <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 0 size 1                  Rm         0 0 1 1 1 1               Rn             Rd
                        U                                                          eq


                Vector variant

                CMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D           when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-839
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-840                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.22     CMGE (zero)

                Compare signed greater than or equal to zero (vector), setting destination vector element to all ones if the condition
                holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4              0
                  0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0                                 Rn               Rd
                         U                                                     op


                Scalar variant

                CMGE <V><d>, <V><n>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4              0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0                                 Rn               Rd
                         U                                                     op


                Vector variant

                CMGE <Vd>.<T>, <Vn>.<T>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C7-841
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              case comparison of
                                   when CompareOp_GT test_passed = element > 0;
                                   when CompareOp_GE test_passed = element >= 0;
                                   when CompareOp_EQ test_passed = element == 0;
                                   when CompareOp_LE test_passed = element <= 0;
                                   when CompareOp_LT test_passed = element < 0;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-842                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.23     CMGT (register)

                Compare signed greater than (vector), setting destination vector element to all ones if the condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 1 0 1 1 1 1 0 size 1                   Rm        0 0 1 1 0 1               Rn              Rd
                        U                                                          eq


                Scalar variant

                CMGT <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 size 1                   Rm        0 0 1 1 0 1               Rn              Rd
                        U                                                          eq


                Vector variant

                CMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D           when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-843
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-844                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.24     CMGT (zero)

                Compare signed greater than zero (vector), setting destination vector element to all ones if the condition holds, else
                zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4              0
                  0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0                                 Rn                Rd
                        U                                                      op


                Scalar variant

                CMGT <V><d>, <V><n>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4              0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0                                 Rn                Rd
                        U                                                      op


                Vector variant

                CMGT <Vd>.<T>, <Vn>.<T>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-845
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              case comparison of
                                   when CompareOp_GT test_passed = element > 0;
                                   when CompareOp_GE test_passed = element >= 0;
                                   when CompareOp_EQ test_passed = element == 0;
                                   when CompareOp_LE test_passed = element <= 0;
                                   when CompareOp_LT test_passed = element < 0;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-846                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.25     CMHI (register)

                Compare unsigned higher (vector), setting destination vector element to all ones if the condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4            0
                  0 1 1 1 1 1 1 0 size 1                  Rm         0 0 1 1 0 1               Rn             Rd
                        U                                                          eq


                Scalar variant

                CMHI <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4            0
                  0 Q 1 0 1 1 1 0 size 1                  Rm         0 0 1 1 0 1               Rn             Rd
                        U                                                          eq


                Vector variant

                CMHI <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D           when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-847
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-848                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.26     CMHS (register)

                Compare unsigned higher or same (vector), setting destination vector element to all ones if the condition holds, else
                zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4              0
                  0 1 1 1 1 1 1 0 size 1                 Rm          0 0 1 1 1 1               Rn               Rd
                        U                                                          eq


                Scalar variant

                CMHS <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4              0
                  0 Q 1 0 1 1 1 0 size 1                 Rm          0 0 1 1 1 1               Rn               Rd
                        U                                                          eq


                Vector variant

                CMHS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean cmp_eq = (eq == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D           when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-849
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-850                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.27     CMLE (zero)

                Compare signed less than or equal to zero (vector), setting destination vector element to all ones if the condition
                holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0                                 Rn              Rd
                         U                                                    op


                Scalar variant

                CMLE <V><d>, <V><n>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0                                 Rn              Rd
                         U                                                    op


                Vector variant

                CMLE <Vd>.<T>, <Vn>.<T>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-851
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              case comparison of
                                   when CompareOp_GT test_passed = element > 0;
                                   when CompareOp_GE test_passed = element >= 0;
                                   when CompareOp_EQ test_passed = element == 0;
                                   when CompareOp_LE test_passed = element <= 0;
                                   when CompareOp_LT test_passed = element < 0;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-852                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.28     CMLT (zero)

                Compare signed less than zero (vector), setting destination vector element to all ones if the condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4              0
                  0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 1 0 1 0                                  Rn               Rd




                Scalar variant

                CMLT <V><d>, <V><n>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison = CompareOp_LT;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4              0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 1 0 1 0                                  Rn               Rd




                Vector variant

                CMLT <Vd>.<T>, <Vn>.<T>, #0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison = CompareOp_LT;


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D           when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                        C7-853
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              case comparison of
                                   when CompareOp_GT test_passed = element > 0;
                                   when CompareOp_GE test_passed = element >= 0;
                                   when CompareOp_EQ test_passed = element == 0;
                                   when CompareOp_LE test_passed = element <= 0;
                                   when CompareOp_LT test_passed = element < 0;
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-854                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.29     CMTST

                Compare bitwise test bits nonzero (vector), setting destination vector element to all ones if the condition holds, else
                zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4              0
                  0 1 0 1 1 1 1 0 size 1                   Rm         1 0 0 0 1 1               Rn                Rd
                        U


                Scalar variant

                CMTST <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean and_test = (U == '0');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4              0
                  0 Q 0 0 1 1 1 0 size 1                   Rm         1 0 0 0 1 1               Rn                Rd
                        U


                Vector variant

                CMTST <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean and_test = (U == '0');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D            when size = 11

                              It is RESERVED when:

                              ·      size = 0x.

                              ·      size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C7-855
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if and_test then
                                   test_passed = !IsZero(element1 AND element2);
                              else
                                   test_passed = (element1 == element2);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-856                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.30     CNT

                Population count per byte




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 0 1 1 0                                Rn              Rd




                Vector variant

                CNT <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '00' then ReservedValue();
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV 8;


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              It is RESERVED when:

                              ·      size = 01, Q = x.

                              ·      size = 1x, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;

                 integer count;
                 for e = 0 to elements-1
                     count = BitCount(Elem[operand, e, esize]);
                     Elem[result, e, esize] = count<esize-1:0>;
                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-857
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.31        DUP (element)

                       Duplicate vector element to vector or scalar

                       This instruction is used by the alias MOV (scalar). The alias is always the preferred disassembly.


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9              5 4          0
                            0 1 0 1 1 1 1 0 0 0 0                imm5         0 0 0 0 0 1             Rn             Rd




                       Scalar variant

                       DUP <V><d>, <Vn>.<T>[<index>]


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer size = LowestSetBit(imm5);
                         if size > 3 then UnallocatedEncoding();

                         integer index = UInt(imm5<4:size+1>);
                         integer idxdsize = if imm5<4> == '1' then 128 else 64;

                         integer esize = 8 << size;
                         integer datasize = esize;
                         integer elements = 1;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9              5 4          0
                            0 Q 0 0 1 1 1 0 0 0 0                imm5         0 0 0 0 0 1             Rn             Rd




                       Vector variant

                       DUP <Vd>.<T>, <Vn>.<Ts>[<index>]


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer size = LowestSetBit(imm5);
                         if size > 3 then UnallocatedEncoding();

                         integer index = UInt(imm5<4:size+1>);
                         integer idxdsize = if imm5<4> == '1' then 128 else 64;

                         if size == 3 && Q == '0' then ReservedValue();
                         integer esize = 8 << size;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;




C7-858                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                          ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <T>       For the scalar variant: is the element width specifier, encoded in the "imm5" field. It can have the
                          following values:

                          B           when imm5 = xxxx1

                          H           when imm5 = xxx10

                          S           when imm5 = xx100

                          D           when imm5 = x1000

                          It is RESERVED when imm5 = x0000.

                          For the vector variant: is an arrangement specifier, encoded in the "imm5:Q" field. It can have the
                          following values:

                          8B          when imm5 = xxxx1, Q = 0

                          16B         when imm5 = xxxx1, Q = 1

                          4H          when imm5 = xxx10, Q = 0

                          8H          when imm5 = xxx10, Q = 1

                          2S          when imm5 = xx100, Q = 0

                          4S          when imm5 = xx100, Q = 1

                          2D          when imm5 = x1000, Q = 1

                          It is RESERVED when:

                          ·      imm5 = x0000, Q = x.

                          ·      imm5 = x1000, Q = 0.

                <Ts>      Is an element size specifier, encoded in the "imm5" field. It can have the following values:

                          B           when imm5 = xxxx1

                          H           when imm5 = xxx10

                          S           when imm5 = xx100

                          D           when imm5 = x1000

                          It is RESERVED when imm5 = x0000.

                <V>       Is the destination width specifier, encoded in the "imm5" field. It can have the following values:

                          B           when imm5 = xxxx1

                          H           when imm5 = xxx10

                          S           when imm5 = xx100

                          D           when imm5 = x1000

                          It is RESERVED when imm5 = x0000.

                <Vn>      Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <index>   Is the element index encoded in the "imm5" field. It can have the following values:

                          imm5<4:1>   when imm5 = xxxx1

                          imm5<4:2>   when imm5 = xxx10

                          imm5<4:3>   when imm5 = xx100

                          imm5<4>     when imm5 = x1000

                          It is RESERVED when imm5 = x0000.

                <d>       Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vd>      Is the name of the SIMD&FP destination register, encoded in the "Rd" field.




ARM DDI 0487A.e             Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-859
ID121714                                     Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(idxdsize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         element = Elem[operand, index, esize];
                         for e = 0 to elements-1
                              Elem[result, e, esize] = element;
                         V[d] = result;




C7-860                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.32     DUP (general)

                Duplicate general-purpose register to vector




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 0 0 1 1 1 0 0 0 0                   imm5       0 0 0 0 1 1                Rn             Rd




                Advanced SIMD variant

                DUP <Vd>.<T>, <R><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer size = LowestSetBit(imm5);
                 if size > 3 then UnallocatedEncoding();

                 // imm5<4:size+1> is IGNORED

                 if size == 3 && Q == '0' then ReservedValue();
                 integer esize = 8 << size;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "imm5:Q" field. It can have the following values:

                              8B          when imm5 = xxxx1, Q = 0

                              16B         when imm5 = xxxx1, Q = 1

                              4H          when imm5 = xxx10, Q = 0

                              8H          when imm5 = xxx10, Q = 1

                              2S          when imm5 = xx100, Q = 0

                              4S          when imm5 = xx100, Q = 1

                              2D          when imm5 = x1000, Q = 1

                              It is RESERVED when:

                              ·      imm5 = x0000, Q = x.

                              ·      imm5 = x1000, Q = 0.

                <R>           Is the width specifier for the general-purpose source register, encoded in the "imm5" field. It can
                              have the following values:

                              W           when imm5 = xxxx1

                              W           when imm5 = xxx10

                              W           when imm5 = xx100

                              X           when imm5 = x1000

                              It is RESERVED when imm5 = x0000.

                              Unspecified bits in "imm5" are ignored but should be set to zero by an assembler.

                <n>           Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the "Rn" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-861
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(esize) element = X[n];
                         bits(datasize) result;

                         for e = 0 to elements-1
                              Elem[result, e, esize] = element;
                         V[d] = result;




C7-862                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.33     EOR (vector)

                Bitwise exclusive OR (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 1 0 1 1 1 0 0 0 1                   Rm         0 0 0 1 1 1               Rn             Rd
                                           opc2


                Three registers of the same type variant

                EOR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 VBitOp op;

                 case opc2 of
                     when '00' op = VBitOp_VEOR;
                     when '01' op = VBitOp_VBSL;
                     when '10' op = VBitOp_VBIT;
                     when '11' op = VBitOp_VBIF;


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                               8B          when Q = 0

                               16B         when Q = 1

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1;
                 bits(datasize) operand2;
                 bits(datasize) operand3;
                 bits(datasize) operand4 = V[n];

                 case op of
                     when VBitOp_VEOR
                         operand1 = V[m];
                         operand2 = Zeros();
                         operand3 = Ones();
                     when VBitOp_VBSL
                         operand1 = V[m];
                         operand2 = operand1;
                         operand3 = V[d];
                     when VBitOp_VBIT
                         operand1 = V[d];



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-863
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   operand2 = operand1;
                                   operand3 = V[m];
                              when VBitOp_VBIF
                                   operand1 = V[d];
                                   operand2 = operand1;
                                   operand3 = NOT(V[m]);

                         V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);




C7-864                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.34     EXT

                Extract vector from pair of vectors




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14         11 10 9               5 4          0
                  0 Q 1 0 1 1 1 0 0 0 0                    Rm         0    imm4        0        Rn             Rd




                Advanced SIMD variant

                EXT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if Q == '0' && imm4<3> == '1' then UnallocatedEncoding();

                 integer datasize = if Q == '1' then 128 else 64;
                 integer position = UInt(imm4) << 3;


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                8B          when Q = 0

                                16B         when Q = 1

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>            Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                <index>         Is the lowest numbered byte element to be extracted, encoded in the "Q:imm4" field. It can have the
                                following values:

                                imm4<2:0>   when Q = 0, imm4<3> = 0

                                imm4        when Q = 1, imm4<3> = x

                                It is RESERVED when Q = 0, imm4<3> = 1.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) hi = V[m];
                 bits(datasize) lo = V[n];
                 bits(datasize*2) concat = hi : lo;

                 V[d] = concat<position+datasize-1:position>;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-865
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.35        FABD

                       Floating-point absolute difference (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4         0
                            0 1 1 1 1 1 1 0 1 sz 1                   Rm         1 1 0 1 0 1               Rn             Rd




                       Scalar variant

                       FABD <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean abs = TRUE;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4         0
                            0 Q 1 0 1 1 1 0 1 sz 1                   Rm         1 1 0 1 0 1               Rn             Rd
                                  U


                       Vector variant

                       FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean abs = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.




C7-866                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;
                 bits(esize) diff;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     diff = FPSub(element1, element2, FPCR);
                     Elem[result, e, esize] = if abs then FPAbs(diff) else diff;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-867
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.36        FABS (vector)

                       Floating-point absolute value (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                            0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 1 1 0                                Rn              Rd
                                  U


                       Vector variant

                       FABS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean neg = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              if neg then
                                   element = FPNeg(element);
                              else
                                   element = FPAbs(element);
                              Elem[result, e, esize] = element;

                         V[d] = result;




C7-868                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.37     FABS (scalar)

                Floating-point absolute value (scalar): Vd = abs(Vn)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                  0 0 0 1 1 1 1 0 0 x 1 0 0 0 0 0 1 1 0 0 0 0                                   Rn             Rd
                                            type                  opc


                Single-precision variant

                Applies when type = 00.

                FABS <Sd>, <Sn>


                Double-precision variant

                Applies when type = 01.

                FABS <Dd>, <Dn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 FPUnaryOp fpop;
                 case opc of
                     when '00' fpop = FPUnaryOp_MOV;
                     when '01' fpop = FPUnaryOp_ABS;
                     when '10' fpop = FPUnaryOp_NEG;
                     when '11' fpop = FPUnaryOp_SQRT;


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(datasize) result;
                 bits(datasize) operand = V[n];

                 case fpop of
                     when FPUnaryOp_MOV    result = operand;
                     when FPUnaryOp_ABS    result = FPAbs(operand);
                     when FPUnaryOp_NEG    result = FPNeg(operand);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-869
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);

                         V[d] = result;




C7-870                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.38     FACGE

                Floating-point absolute compare greater than or equal (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4          0
                  0 1 1 1 1 1 1 0 0 sz 1                  Rm        1 1 1 0 1 1               Rn             Rd
                        U                  E                                    ac


                Scalar variant

                FACGE <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4          0
                  0 Q 1 0 1 1 1 0 0 sz 1                  Rm        1 1 1 0 1 1               Rn             Rd
                        U                  E                                    ac


                Vector variant

                FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-871
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if abs then
                                   element1 = FPAbs(element1);
                                   element2 = FPAbs(element2);
                              case cmp of
                                   when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                                   when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-872                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.39     FACGT

                Floating-point absolute compare greater than (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 0 1 sz 1                  Rm        1 1 1 0 1 1               Rn             Rd
                        U                  E                                    ac


                Scalar variant

                FACGT <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 0 1 sz 1                  Rm        1 1 1 0 1 1               Rn             Rd
                        U                  E                                    ac


                Vector variant

                FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-873
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if abs then
                                   element1 = FPAbs(element1);
                                   element2 = FPAbs(element2);
                              case cmp of
                                   when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                                   when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-874                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.40     FADD (vector)

                Floating-point add (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 0 sz 1                  Rm         1 1 0 1 0 1               Rn             Rd
                        U


                Three registers of the same type variant

                FADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean pair = (U == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     if pair then
                         element1 = Elem[concat, 2*e, esize];
                         element2 = Elem[concat, (2*e)+1, esize];
                     else
                         element1 = Elem[operand1, e, esize];
                         element2 = Elem[operand2, e, esize];
                     Elem[result, e, esize] = FPAdd(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-875
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.41        FADD (scalar)

                       Floating-point add (scalar): Vd = Vn + Vm




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1                    Rm       0 0 1 0 1 0             Rn             Rd
                                                      type                             op


                       Single-precision variant

                       Applies when type = 00.

                       FADD <Sd>, <Sn>, <Sm>


                       Double-precision variant

                       Applies when type = 01.

                       FADD <Dd>, <Dn>, <Dm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean sub_op = (op == '1');


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         if sub_op then
                              result = FPSub(operand1, operand2, FPCR);
                         else
                              result = FPAdd(operand1, operand2, FPCR);

                         V[d] = result;




C7-876                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.42     FADDP (scalar)

                Floating-point add pair of elements (scalar)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 1 1 1 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 0 1 1 0                                   Rn              Rd




                Advanced SIMD variant

                FADDP <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize * 2;
                 integer elements = 2;

                 ReduceOp op = ReduceOp_FADD;


                Assembler symbols

                <V>            Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                               S            when sz = 0

                               D            when sz = 1

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>            Is the source arrangement specifier, encoded in the "sz" field. It can have the following values:

                               2S           when sz = 0

                               2D           when sz = 1


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 V[d] = Reduce(op, operand, esize);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-877
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.43        FADDP (vector)

                       Floating-point add pairwise (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 1 0 1 1 1 0 0 sz 1                  Rm         1 1 0 1 0 1              Rn              Rd
                                  U


                       Three registers of the same type variant

                       FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean pair = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              if pair then
                                   element1 = Elem[concat, 2*e, esize];
                                   element2 = Elem[concat, (2*e)+1, esize];
                              else
                                   element1 = Elem[operand1, e, esize];
                                   element2 = Elem[operand2, e, esize];
                              Elem[result, e, esize] = FPAdd(element1, element2, FPCR);

                         V[d] = result;




C7-878                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.44     FCCMP

                Floating-point conditional quiet compare (scalar), setting condition flags to result of comparison or an immediate
                value: flags = if cond then compareQuiet(Vn,Vm) else #nzcv




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15         12 11 10 9               5 4 3          0
                  0 0 0 1 1 1 1 0 0 x 1                      Rm           cond      0 1          Rn         0    nzcv
                                            type                                                           op


                Single-precision variant

                Applies when type = 00.

                FCCMP <Sn>, <Sm>, #<nzcv>, <cond>


                Double-precision variant

                Applies when type = 01.

                FCCMP <Dn>, <Dm>, #<nzcv>, <cond>


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean signal_all_nans = (op == '1');
                 bits(4) condition = cond;
                 bits(4) flags = nzcv;


                Assembler symbols

                <Dn>           Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <nzcv>         Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
                               NZCV condition flags, encoded in the "nzcv" field.

                <cond>         Is one of the standard conditions, encoded in the "cond" field in the standard way.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2;

                 operand2 = V[m];




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C7-879
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         if ConditionHolds(condition) then
                              flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
                         PSTATE.<N,Z,C,V> = flags;




C7-880                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.45     FCCMPE

                Floating-point conditional signaling compare (scalar), setting condition flags to result of comparison or an
                immediate value: flags = if cond then compareSignaling(Vn,Vm) else #nzcv




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15         12 11 10 9               5 4 3          0
                  0 0 0 1 1 1 1 0 0 x 1                      Rm           cond      0 1          Rn         1    nzcv
                                            type                                                           op


                Single-precision variant

                Applies when type = 00.

                FCCMPE <Sn>, <Sm>, #<nzcv>, <cond>


                Double-precision variant

                Applies when type = 01.

                FCCMPE <Dn>, <Dm>, #<nzcv>, <cond>


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean signal_all_nans = (op == '1');
                 bits(4) condition = cond;
                 bits(4) flags = nzcv;


                Assembler symbols

                <Dn>           Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <nzcv>         Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
                               NZCV condition flags, encoded in the "nzcv" field.

                <cond>         Is one of the standard conditions, encoded in the "cond" field in the standard way.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2;

                 operand2 = V[m];




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                       C7-881
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         if ConditionHolds(condition) then
                              flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
                         PSTATE.<N,Z,C,V> = flags;




C7-882                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.46     FCMEQ (register)

                Floating-point compare equal (vector), setting destination vector element to all ones if the condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                  0 1 0 1 1 1 1 0 0 sz 1                   Rm         1 1 1 0 0 1               Rn              Rd
                        U                  E                                      ac


                Scalar variant

                FCMEQ <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 0 sz 1                   Rm         1 1 1 0 0 1               Rn              Rd
                        U                  E                                      ac


                Vector variant

                FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-883
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if abs then
                                   element1 = FPAbs(element1);
                                   element2 = FPAbs(element2);
                              case cmp of
                                   when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                                   when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-884                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.47     FCMEQ (zero)

                Floating-point compare equal to zero (vector), setting destination vector element to all ones if the condition holds,
                else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                   0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0                                Rn               Rd
                         U                                                     op


                Scalar variant

                FCMEQ <V><d>, <V><n>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                   0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0                                Rn               Rd
                         U                                                     op


                Vector variant

                FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-885
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) zero = FPZero('0');
                         bits(esize) element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              case comparison of
                                   when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                                   when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                                   when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                                   when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-886                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.48     FCMGE (register)

                Floating-point compare greater than or equal (vector), setting destination vector element to all ones if the condition
                holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4              0
                  0 1 1 1 1 1 1 0 0 sz 1                  Rm         1 1 1 0 0 1               Rn               Rd
                         U                 E                                       ac


                Scalar variant

                FCMGE <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4              0
                  0 Q 1 0 1 1 1 0 0 sz 1                  Rm         1 1 1 0 0 1               Rn               Rd
                         U                 E                                       ac


                Vector variant

                FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-887
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when '110' cmp = CompareOp_GT; abs = FALSE;
                              when '111' cmp = CompareOp_GT; abs = TRUE;
                              otherwise    UnallocatedEncoding();


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if abs then
                                   element1 = FPAbs(element1);
                                   element2 = FPAbs(element2);
                              case cmp of
                                   when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                                   when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-888                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.49     FCMGE (zero)

                Floating-point compare greater than or equal to zero (vector), setting destination vector element to all ones if the
                condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                  0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0                                 Rn             Rd
                        U                                                      op


                Scalar variant

                FCMGE <V><d>, <V><n>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                  0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0                                 Rn             Rd
                        U                                                      op


                Vector variant

                FCMGE <Vd>.<T>, <Vn>.<T>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-889
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) zero = FPZero('0');
                         bits(esize) element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              case comparison of
                                   when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                                   when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                                   when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                                   when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-890                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.50     FCMGT (register)

                Floating-point compare greater than (vector), setting destination vector element to all ones if the condition holds,
                else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9               5 4             0
                   0 1 1 1 1 1 1 0 1 sz 1                Rm           1 1 1 0 0 1              Rn               Rd
                         U                 E                                      ac


                Scalar variant

                FCMGT <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;
                     when '110' cmp = CompareOp_GT; abs = FALSE;
                     when '111' cmp = CompareOp_GT; abs = TRUE;
                     otherwise   UnallocatedEncoding();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9               5 4             0
                   0 Q 1 0 1 1 1 0 1 sz 1                Rm           1 1 1 0 0 1              Rn               Rd
                         U                 E                                      ac


                Vector variant

                FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 CompareOp cmp;
                 boolean abs;

                 case E:U:ac of
                     when '000' cmp = CompareOp_EQ; abs = FALSE;
                     when '010' cmp = CompareOp_GE; abs = FALSE;
                     when '011' cmp = CompareOp_GE; abs = TRUE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-891
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when '110' cmp = CompareOp_GT; abs = FALSE;
                              when '111' cmp = CompareOp_GT; abs = TRUE;
                              otherwise    UnallocatedEncoding();


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if abs then
                                   element1 = FPAbs(element1);
                                   element2 = FPAbs(element2);
                              case cmp of
                                   when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
                                   when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-892                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.51     FCMGT (zero)

                Floating-point compare greater than zero (vector), setting destination vector element to all ones if the condition
                holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0                                 Rn              Rd
                         U                                                     op


                Scalar variant

                FCMGT <V><d>, <V><n>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0                                 Rn              Rd
                         U                                                     op


                Vector variant

                FCMGT <Vd>.<T>, <Vn>.<T>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-893
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) zero = FPZero('0');
                         bits(esize) element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              case comparison of
                                   when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                                   when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                                   when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                                   when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-894                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.52     FCMLE (zero)

                Floating-point compare less than or equal to zero (vector), setting destination vector element to all ones if the
                condition holds, else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4            0
                  0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0                                  Rn             Rd
                        U                                                      op


                Scalar variant

                FCMLE <V><d>, <V><n>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4            0
                  0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0                                  Rn             Rd
                        U                                                      op


                Vector variant

                FCMLE <Vd>.<T>, <Vn>.<T>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison;
                 case op:U of
                     when '00' comparison = CompareOp_GT;
                     when '01' comparison = CompareOp_GE;
                     when '10' comparison = CompareOp_EQ;
                     when '11' comparison = CompareOp_LE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-895
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) zero = FPZero('0');
                         bits(esize) element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              case comparison of
                                   when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                                   when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                                   when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                                   when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-896                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.53     FCMLT (zero)

                Floating-point compare less than zero (vector), setting destination vector element to all ones if the condition holds,
                else zero


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4              0
                   0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 0 1 0                                 Rn              Rd




                Scalar variant

                FCMLT <V><d>, <V><n>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 CompareOp comparison = CompareOp_LT;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4              0
                   0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 0 1 0                                 Rn              Rd




                Vector variant

                FCMLT <Vd>.<T>, <Vn>.<T>, #0.0


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 CompareOp comparison = CompareOp_LT;


                Assembler symbols

                <V>            Is a width specifier, encoded in the "sz" field. It can have the following values:

                               S           when sz = 0

                               D           when sz = 1

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>            Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-897
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) zero = FPZero('0');
                         bits(esize) element;
                         boolean test_passed;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              case comparison of
                                   when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
                                   when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
                                   when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
                                   when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
                                   when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
                              Elem[result, e, esize] = if test_passed then Ones() else Zeros();

                         V[d] = result;




C7-898                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.54     FCMP

                Floating-point quiet compare (scalar): flags = compareQuiet(Vn, Vm) // with register




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9               5 4 3 2 1 0
                  0 0 0 1 1 1 1 0 0 x 1                   Rm          0 0 1 0 0 0               Rn        0 x 0 0 0
                                            type                                                          opc


                Single-precision variant

                Applies when type = 00 && opc = 00.

                FCMP <Sn>, <Sm>


                Single-precision, zero variant

                Applies when type = 00 && Rm = (00000) && opc = 01.

                FCMP <Sn>, #0.0


                Double-precision variant

                Applies when type = 01 && opc = 00.

                FCMP <Dn>, <Dm>


                Double-precision, zero variant

                Applies when type = 01 && Rm = (00000) && opc = 01.

                FCMP <Dn>, #0.0


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer m = UInt(Rm);    // ignored when opc<0> == '1'

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean signal_all_nans = (opc<1> == '1');
                 boolean cmp_with_zero = (opc<0> == '1');


                Assembler symbols

                <Dn>           For the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded
                               in the "Rn" field.

                               For the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded
                               in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sn>           For the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded
                               in the "Rn" field.

                               For the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded
                               in the "Rn" field.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-899
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2;

                         operand2 = if cmp_with_zero then FPZero('0') else V[m];

                         PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);




C7-900                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.55     FCMPE

                Floating-point signaling compare (scalar): flags = compareSignaling(Vn, Vm) // with register




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9               5 4 3 2 1 0
                  0 0 0 1 1 1 1 0 0 x 1                   Rm          0 0 1 0 0 0               Rn        1 x 0 0 0
                                            type                                                          opc


                Single-precision variant

                Applies when type = 00 && opc = 10.

                FCMPE <Sn>, <Sm>


                Single-precision, zero variant

                Applies when type = 00 && Rm = (00000) && opc = 11.

                FCMPE <Sn>, #0.0


                Double-precision variant

                Applies when type = 01 && opc = 10.

                FCMPE <Dn>, <Dm>


                Double-precision, zero variant

                Applies when type = 01 && Rm = (00000) && opc = 11.

                FCMPE <Dn>, #0.0


                Decode for all variants of this encoding

                 integer n = UInt(Rn);
                 integer m = UInt(Rm);    // ignored when opc<0> == '1'

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean signal_all_nans = (opc<1> == '1');
                 boolean cmp_with_zero = (opc<0> == '1');


                Assembler symbols

                <Dn>           For the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded
                               in the "Rn" field.

                               For the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded
                               in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sn>           For the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded
                               in the "Rn" field.

                               For the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded
                               in the "Rn" field.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-901
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2;

                         operand2 = if cmp_with_zero then FPZero('0') else V[m];

                         PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);




C7-902                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.56     FCSEL

                Floating-point conditional select (scalar): Vd = if cond then Vn else Vm




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15       12 11 10 9                 5 4          0
                  0 0 0 1 1 1 1 0 0 x 1                     Rm           cond       1 1          Rn             Rd
                                            type


                Single-precision variant

                Applies when type = 00.

                FCSEL <Sd>, <Sn>, <Sm>, <cond>


                Double-precision variant

                Applies when type = 01.

                FCSEL <Dd>, <Dn>, <Dm>, <cond>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 bits(4) condition = cond;


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <cond>         Is one of the standard conditions, encoded in the "cond" field in the standard way.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) result;

                 result = if ConditionHolds(condition) then V[n] else V[m];

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-903
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.57        FCVT

                       Floating-point convert precision (scalar): Vd = convertFormat(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9         5 4    0
                            0 0 0 1 1 1 1 0 type 1 0 0 0 1 opc 1 0 0 0 0                            Rn     Rd




                       Half-precision to single-precision variant

                       Applies when type = 11 && opc = 00.

                       FCVT <Sd>, <Hn>


                       Half-precision to double-precision variant

                       Applies when type = 11 && opc = 01.

                       FCVT <Dd>, <Hn>


                       Single-precision to half-precision variant

                       Applies when type = 00 && opc = 11.

                       FCVT <Hd>, <Sn>


                       Single-precision to double-precision variant

                       Applies when type = 00 && opc = 01.

                       FCVT <Dd>, <Sn>


                       Double-precision to half-precision variant

                       Applies when type = 01 && opc = 11.

                       FCVT <Hd>, <Dn>


                       Double-precision to single-precision variant

                       Applies when type = 01 && opc = 00.

                       FCVT <Sd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if type == opc then UnallocatedEncoding();

                         integer srcsize;
                         case type of
                              when '00' srcsize = 32;
                              when '01' srcsize = 64;
                              when '10' UnallocatedEncoding();
                              when '11' srcsize = 16;
                         integer dstsize;
                         case opc of
                              when '00' dstsize = 32;
                              when '01' dstsize = 64;
                              when '10' UnallocatedEncoding();
                              when '11' dstsize = 16;



C7-904                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <Dd>          Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Hd>          Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Sd>          Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Hn>          Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(dstsize) result;
                 bits(srcsize) operand = V[n];

                 result = FPConvert(operand, FPCR);
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-905
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.58        FCVTAS (vector)

                       Floating-point convert to signed integer, rounding to nearest with ties to away (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0                                  Rn             Rd
                                  U


                       Scalar variant

                       FCVTAS <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPRounding_TIEAWAY;
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0                                  Rn             Rd
                                  U


                       Vector variant

                       FCVTAS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPRounding_TIEAWAY;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-906                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-907
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.59        FCVTAS (scalar)

                       Floating-point convert to signed integer, rounding to nearest with ties to away (scalar): Rd =
                       signed_convertToIntegerExactTiesToAway(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9               5 4        0
                            sf 0 0 1 1 1 1 0 0 x 1 0 0 1 0 0 0 0 0 0 0 0                             Rn              Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTAS <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTAS <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTAS <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTAS <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-908                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                          ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-909
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.60        FCVTAU (vector)

                       Floating-point convert to unsigned integer, rounding to nearest with ties to away (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0                                  Rn             Rd
                                  U


                       Scalar variant

                       FCVTAU <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPRounding_TIEAWAY;
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0                                  Rn             Rd
                                  U


                       Vector variant

                       FCVTAU <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPRounding_TIEAWAY;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-910                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-911
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.61        FCVTAU (scalar)

                       Floating-point convert to unsigned integer, rounding to nearest with ties to away (scalar): Rd =
                       unsigned_convertToIntegerExactTiesToAway(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9              5 4          0
                            sf 0 0 1 1 1 1 0 0 x 1 0 0 1 0 1 0 0 0 0 0 0                             Rn               Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTAU <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTAU <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTAU <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTAU <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-912                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-913
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.62        FCVTL, FCVTL2

                       Floating-point convert to higher precision long (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 1 1 0                                   Rn               Rd




                       Vector variant

                       FCVTL{2} <Vd>.<Ta>, <Vn>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 16 << UInt(sz);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "sz" field. It can have the following values:

                                         4S          when sz = 0

                                         2D          when sz = 1

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         4H          when sz = 0, Q = 0

                                         8H          when sz = 0, Q = 1

                                         2S          when sz = 1, Q = 0

                                         4S          when sz = 1, Q = 1


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = Vpart[n, part];
                         bits(2*datasize) result;

                         for e = 0 to elements-1
                              Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);

                         V[d] = result;




C7-914                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.63     FCVTMS (vector)

                Floating-point convert to signed integer, rounding toward minus infinity (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                  0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                        U                   o2                                  o1


                Scalar variant

                FCVTMS <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 FPRounding rounding = FPDecodeRounding(o1:o2);
                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                  0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                        U                   o2                                  o1


                Vector variant

                FCVTMS <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 FPRounding rounding = FPDecodeRounding(o1:o2);
                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "sz" field. It can have the following values:

                               S            when sz = 0

                               D            when sz = 1

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>            Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-915
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                         V[d] = result;




C7-916                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.64     FCVTMS (scalar)

                Floating-point convert to signed integer, rounding toward minus infinity (scalar): Rd =
                signed_convertToIntegerExactTowardNegative(Vn)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15 14 13 12 11 10 9                 5 4          0
                  sf 0 0 1 1 1 1 0 0 x 1 1 0 0 0 0 0 0 0 0 0 0                                  Rn             Rd
                                            type     rmode opcode


                Single-precision to 32-bit variant

                Applies when sf = 0 && type = 00.

                FCVTMS <Wd>, <Sn>


                Single-precision to 64-bit variant

                Applies when sf = 1 && type = 00.

                FCVTMS <Xd>, <Sn>


                Double-precision to 32-bit variant

                Applies when sf = 0 && type = 01.

                FCVTMS <Wd>, <Dn>


                Double-precision to 64-bit variant

                Applies when sf = 1 && type = 01.

                FCVTMS <Xd>, <Dn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer intsize = if sf == '1' then 64 else 32;
                 integer fltsize;
                 FPConvOp op;
                 FPRounding rounding;
                 boolean unsigned;
                 integer part;

                 case type of
                     when '00'
                         fltsize = 32;
                     when '01'
                         fltsize = 64;
                     when '10'
                         if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                         fltsize = 128;
                     when '11'
                         UnallocatedEncoding();

                 case opcode<2:1>:rmode of
                     when '00 xx'          // FCVT[NPMZ][US]
                         rounding = FPDecodeRounding(rmode);
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                     when '01 00'          // [US]CVTF
                         rounding = FPRoundingMode(FPCR);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-917
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_ItoF;
                              when '10 00'          // FCVTA[US]
                                   rounding = FPRounding_TIEAWAY;
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '11 00'          // FMOV
                                   if fltsize != intsize then UnallocatedEncoding();
                                   op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                                   part = 0;
                              when '11 01'          // FMOV D[1]
                                   if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                                   op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                                   part = 1;
                              otherwise
                                   UnallocatedEncoding();


                       Assembler symbols

                       <Wd>              Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>              Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(fltsize) fltval;
                         bits(intsize) intval;

                         case op of
                              when FPConvOp_CVT_FtoI
                                   fltval = V[n];
                                   intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                                   X[d] = intval;
                              when FPConvOp_CVT_ItoF
                                   intval = X[n];
                                   fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                                   V[d] = fltval;
                              when FPConvOp_MOV_FtoI
                                   intval = Vpart[n,part];
                                   X[d] = intval;
                              when FPConvOp_MOV_ItoF
                                   intval = X[n];
                                   Vpart[d,part] = intval;




C7-918                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.65     FCVTMU (vector)

                Floating-point convert to unsigned integer, rounding toward minus infinity (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                  0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                        U                  o2                                   o1


                Scalar variant

                FCVTMU <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;

                 FPRounding rounding = FPDecodeRounding(o1:o2);
                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                  0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                        U                  o2                                   o1


                Vector variant

                FCVTMU <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 FPRounding rounding = FPDecodeRounding(o1:o2);
                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "sz" field. It can have the following values:

                               S           when sz = 0

                               D           when sz = 1

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>            Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-919
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                         V[d] = result;




C7-920                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.66     FCVTMU (scalar)

                Floating-point convert to unsigned integer, rounding toward minus infinity (scalar): Rd =
                unsigned_convertToIntegerExactTowardNegative(Vn)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15 14 13 12 11 10 9                 5 4          0
                  sf 0 0 1 1 1 1 0 0 x 1 1 0 0 0 1 0 0 0 0 0 0                                  Rn             Rd
                                            type    rmode opcode


                Single-precision to 32-bit variant

                Applies when sf = 0 && type = 00.

                FCVTMU <Wd>, <Sn>


                Single-precision to 64-bit variant

                Applies when sf = 1 && type = 00.

                FCVTMU <Xd>, <Sn>


                Double-precision to 32-bit variant

                Applies when sf = 0 && type = 01.

                FCVTMU <Wd>, <Dn>


                Double-precision to 64-bit variant

                Applies when sf = 1 && type = 01.

                FCVTMU <Xd>, <Dn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer intsize = if sf == '1' then 64 else 32;
                 integer fltsize;
                 FPConvOp op;
                 FPRounding rounding;
                 boolean unsigned;
                 integer part;

                 case type of
                     when '00'
                         fltsize = 32;
                     when '01'
                         fltsize = 64;
                     when '10'
                         if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                         fltsize = 128;
                     when '11'
                         UnallocatedEncoding();

                 case opcode<2:1>:rmode of
                     when '00 xx'          // FCVT[NPMZ][US]
                         rounding = FPDecodeRounding(rmode);
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                     when '01 00'          // [US]CVTF
                         rounding = FPRoundingMode(FPCR);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-921
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_ItoF;
                              when '10 00'          // FCVTA[US]
                                   rounding = FPRounding_TIEAWAY;
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '11 00'          // FMOV
                                   if fltsize != intsize then UnallocatedEncoding();
                                   op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                                   part = 0;
                              when '11 01'          // FMOV D[1]
                                   if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                                   op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                                   part = 1;
                              otherwise
                                   UnallocatedEncoding();


                       Assembler symbols

                       <Wd>              Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>              Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(fltsize) fltval;
                         bits(intsize) intval;

                         case op of
                              when FPConvOp_CVT_FtoI
                                   fltval = V[n];
                                   intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                                   X[d] = intval;
                              when FPConvOp_CVT_ItoF
                                   intval = X[n];
                                   fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                                   V[d] = fltval;
                              when FPConvOp_MOV_FtoI
                                   intval = Vpart[n,part];
                                   X[d] = intval;
                              when FPConvOp_MOV_ItoF
                                   intval = X[n];
                                   Vpart[d,part] = intval;




C7-922                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.67     FCVTN, FCVTN2

                Floating-point convert to lower precision narrow (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4             0
                  0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 0 1 0                                   Rn               Rd




                Vector variant

                FCVTN{2} <Vd>.<Tb>, <Vn>.<Ta>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 16 << UInt(sz);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;


                Assembler symbols

                2              Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                               64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                               the following values:

                               [absent]     when Q = 0

                               [present]    when Q = 1

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               4H           when sz = 0, Q = 0

                               8H           when sz = 0, Q = 1

                               2S           when sz = 1, Q = 0

                               4S           when sz = 1, Q = 1

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>           Is an arrangement specifier, encoded in the "sz" field. It can have the following values:

                               4S           when sz = 0

                               2D           when sz = 1


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand = V[n];
                 bits(datasize) result;

                 for e = 0 to elements-1
                     Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);

                 Vpart[d, part] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-923
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.68        FCVTNS (vector)

                       Floating-point convert to signed integer, rounding to nearest with ties to even (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Scalar variant

                       FCVTNS <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Vector variant

                       FCVTNS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-924                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-925
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.69        FCVTNS (scalar)

                       Floating-point convert to signed integer, rounding to nearest with ties to even (scalar): Rd =
                       signed_convertToIntegerExactTiesToEven(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9                5 4        0
                            sf 0 0 1 1 1 1 0 0 x 1 0 0 0 0 0 0 0 0 0 0 0                              Rn             Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTNS <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTNS <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTNS <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTNS <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-926                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-927
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.70        FCVTNU (vector)

                       Floating-point convert to unsigned integer, rounding to nearest with ties to even (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Scalar variant

                       FCVTNU <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Vector variant

                       FCVTNU <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-928                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-929
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.71        FCVTNU (scalar)

                       Floating-point convert to unsigned integer, rounding to nearest with ties to even (scalar): Rd =
                       unsigned_convertToIntegerExactTiesToEven(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9               5 4          0
                            sf 0 0 1 1 1 1 0 0 x 1 0 0 0 0 1 0 0 0 0 0 0                              Rn              Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTNU <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTNU <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTNU <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTNU <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-930                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                            ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-931
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.72        FCVTPS (vector)

                       Floating-point convert to signed integer, rounding toward positive infinity (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Scalar variant

                       FCVTPS <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Vector variant

                       FCVTPS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-932                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-933
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.73        FCVTPS (scalar)

                       Floating-point convert to signed integer, rounding toward positive infinity (scalar): Rd =
                       signed_convertToIntegerExactTowardPositive(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9                5 4     0
                            sf 0 0 1 1 1 1 0 0 x 1 0 1 0 0 0 0 0 0 0 0 0                              Rn           Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTPS <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTPS <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTPS <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTPS <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-934                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                 ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                        ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-935
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.74        FCVTPU (vector)

                       Floating-point convert to unsigned integer, rounding toward positive infinity (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Scalar variant

                       FCVTPU <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Vector variant

                       FCVTPU <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-936                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-937
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.75        FCVTPU (scalar)

                       Floating-point convert to unsigned integer, rounding toward positive infinity (scalar): Rd =
                       unsigned_convertToIntegerExactTowardPositive(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9               5 4       0
                            sf 0 0 1 1 1 1 0 0 x 1 0 1 0 0 1 0 0 0 0 0 0                             Rn             Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTPU <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTPU <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTPU <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTPU <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-938                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                         ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-939
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.76        FCVTXN, FCVTXN2

                       Floating-point convert to lower precision narrow, rounding to odd (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 0 1 0                                   Rn               Rd




                       Scalar variant

                       FCVTXN <Vb><d>, <Va><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz == '0' then ReservedValue();
                         integer esize = 32;
                         integer datasize = esize;
                         integer elements = 1;
                         integer part = 0;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 0 1 0                                   Rn               Rd




                       Vector variant

                       FCVTXN{2} <Vd>.<Tb>, <Vn>.<Ta>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz == '0' then ReservedValue();
                         integer esize = 32;
                         integer datasize = 64;
                         integer elements = 2;
                         integer part = UInt(Q);


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 1, Q = 0




C7-940                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              4S          when sz = 1, Q = 1

                              It is RESERVED when sz = 0, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>          Is an arrangement specifier, encoded in the "sz" field. It can have the following values:

                              2D          when sz = 1

                              It is RESERVED when sz = 0.

                <Vb>          Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                              S           when sz = 1

                              It is RESERVED when sz = 0.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Va>          Is the source width specifier, encoded in the "sz" field. It can have the following values:

                              D           when sz = 1

                              It is RESERVED when sz = 0.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand = V[n];
                 bits(datasize) result;

                 for e = 0 to elements-1
                     Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-941
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.77        FCVTZS (vector, fixed-point)

                       Floating-point convert to signed fixed-point, rounding toward zero (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 1 0 1 1 1 1 1 0              !=0000     immb      1 1 1 1 1 1             Rn             Rd
                                  U                         immh


                       Scalar variant

                       FCVTZS <V><d>, <V><n>, #<fbits>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '00xx' then ReservedValue();
                         integer esize = 32 << UInt(immh<3>);
                         integer datasize = esize;
                         integer elements = 1;

                         integer fracbits = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         FPRounding rounding = FPRounding_ZERO;


                       Vector


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 Q 0 0 1 1 1 1 0              !=0000     immb      1 1 1 1 1 1             Rn             Rd
                                  U                         immh


                       Vector variant

                       FCVTZS <Vd>.<T>, <Vn>.<T>, #<fbits>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh == '00xx' then ReservedValue();
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(immh<3>);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer fracbits = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         FPRounding rounding = FPRounding_ZERO;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "immh" field. It can have the following values:

                                         S           when immh = 01xx

                                         D           when immh = 1xxx



C7-942                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when immh = 00xx.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              2S          when immh = 01xx, Q = 0

                              4S          when immh = 01xx, Q = 1

                              2D          when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when:

                              ·      immh = 0001, Q = x.

                              ·      immh = 001x, Q = x.

                              ·      immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <fbits>       For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
                              in the "immh:immb" field. It can have the following values:

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              It is RESERVED when immh = 00xx.

                              For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
                              in the "immh:immb" field. It can have the following values:

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when:

                              ·      immh = 0001.

                              ·      immh = 001x.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand  = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-943
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.78        FCVTZS (vector, integer)

                       Floating-point convert to signed integer, rounding toward zero (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Scalar variant

                       FCVTZS <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Vector variant

                       FCVTZS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-944                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-945
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.79        FCVTZS (scalar, fixed-point)

                       Floating-point convert to signed fixed-point, rounding toward zero (scalar): Rd =
                       signed_convertToIntegerExactTowardZero(Vn*(2^fbits))




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15                10 9        5 4    0
                            sf 0 0 1 1 1 1 0 0 x 0 1 1 0 0 0                       scale             Rn      Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTZS <Wd>, <Sn>, #<fbits>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTZS <Xd>, <Sn>, #<fbits>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTZS <Wd>, <Dn>, #<fbits>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTZS <Xd>, <Dn>, #<fbits>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;

                         case type of
                              when '00' fltsize = 32;
                              when '01' fltsize = 64;
                              when '1x' UnallocatedEncoding();

                         if sf == '0' && scale<5> == '0' then UnallocatedEncoding();
                         integer fracbits = 64 - UInt(scale);

                         case opcode<2:1>:rmode of
                              when '00 11'         // FCVTZ
                                   rounding = FPRounding_ZERO;
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_ItoF;
                              otherwise
                                   UnallocatedEncoding();



C7-946                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <fbits>       For the double-precision to 32-bit and single-precision to 32-bit variant: is the number of bits after
                              the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus "scale".

                              For the double-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after
                              the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus "scale".


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                         V[d] = fltval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-947
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.80        FCVTZS (scalar, integer)

                       Floating-point convert to signed integer, rounding toward zero (scalar): Rd =
                       signed_convertToIntegerExactTowardZero(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9         5 4    0
                            sf 0 0 1 1 1 1 0 0 x 1 1 1 0 0 0 0 0 0 0 0 0                            Rn     Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTZS <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTZS <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTZS <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTZS <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-948                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-949
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.81        FCVTZU (vector, fixed-point)

                       Floating-point convert to unsigned fixed-point, rounding toward zero (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 1 1 1 1 1 1 1 0              !=0000     immb      1 1 1 1 1 1             Rn             Rd
                                  U                         immh


                       Scalar variant

                       FCVTZU <V><d>, <V><n>, #<fbits>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '00xx' then ReservedValue();
                         integer esize = 32 << UInt(immh<3>);
                         integer datasize = esize;
                         integer elements = 1;

                         integer fracbits = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         FPRounding rounding = FPRounding_ZERO;


                       Vector


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 Q 1 0 1 1 1 1 0              !=0000     immb      1 1 1 1 1 1             Rn             Rd
                                  U                         immh


                       Vector variant

                       FCVTZU <Vd>.<T>, <Vn>.<T>, #<fbits>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh == '00xx' then ReservedValue();
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(immh<3>);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer fracbits = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         FPRounding rounding = FPRounding_ZERO;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "immh" field. It can have the following values:

                                         S           when immh = 01xx

                                         D           when immh = 1xxx



C7-950                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when immh = 00xx.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              2S          when immh = 01xx, Q = 0

                              4S          when immh = 01xx, Q = 1

                              2D          when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when:

                              ·      immh = 0001, Q = x.

                              ·      immh = 001x, Q = x.

                              ·      immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <fbits>       For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
                              in the "immh:immb" field. It can have the following values:

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              It is RESERVED when immh = 00xx.

                              For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
                              in the "immh:immb" field. It can have the following values:

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when:

                              ·      immh = 0001.

                              ·      immh = 001x.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand  = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-951
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.82        FCVTZU (vector, integer)

                       Floating-point convert to unsigned integer, rounding toward zero (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Scalar variant

                       FCVTZU <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0                                  Rn             Rd
                                  U                  o2                                   o1


                       Vector variant

                       FCVTZU <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         FPRounding rounding = FPDecodeRounding(o1:o2);
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-952                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0

                              4S          when sz = 0, Q = 1

                              2D          when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-953
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.83        FCVTZU (scalar, fixed-point)

                       Floating-point convert to unsigned fixed-point, rounding toward zero (scalar): Rd =
                       unsigned_convertToIntegerExactTowardZero(Vn*(2^fbits))




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15                10 9         5 4    0
                            sf 0 0 1 1 1 1 0 0 x 0 1 1 0 0 1                       scale            Rn        Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTZU <Wd>, <Sn>, #<fbits>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTZU <Xd>, <Sn>, #<fbits>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTZU <Wd>, <Dn>, #<fbits>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTZU <Xd>, <Dn>, #<fbits>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;

                         case type of
                              when '00' fltsize = 32;
                              when '01' fltsize = 64;
                              when '1x' UnallocatedEncoding();

                         if sf == '0' && scale<5> == '0' then UnallocatedEncoding();
                         integer fracbits = 64 - UInt(scale);

                         case opcode<2:1>:rmode of
                              when '00 11'         // FCVTZ
                                   rounding = FPRounding_ZERO;
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_ItoF;
                              otherwise
                                   UnallocatedEncoding();



C7-954                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.            ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                   ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <fbits>       For the double-precision to 32-bit and single-precision to 32-bit variant: is the number of bits after
                              the binary point in the fixed-point destination, in the range 1 to 32, encoded as 64 minus "scale".

                              For the double-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after
                              the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus "scale".


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                         V[d] = fltval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-955
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.84        FCVTZU (scalar, integer)

                       Floating-point convert to unsigned integer, rounding toward zero (scalar): Rd =
                       unsigned_convertToIntegerExactTowardZero(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9          5 4    0
                            sf 0 0 1 1 1 1 0 0 x 1 1 1 0 0 1 0 0 0 0 0 0                             Rn     Rd
                                                     type    rmode opcode


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00.

                       FCVTZU <Wd>, <Sn>


                       Single-precision to 64-bit variant

                       Applies when sf = 1 && type = 00.

                       FCVTZU <Xd>, <Sn>


                       Double-precision to 32-bit variant

                       Applies when sf = 0 && type = 01.

                       FCVTZU <Wd>, <Dn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01.

                       FCVTZU <Xd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);



C7-956                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-957
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.85        FDIV (vector)

                       Floating-point divide (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 1 0 1 1 1 0 0 sz 1                  Rm         1 1 1 1 1 1              Rn              Rd




                       Three registers of the same type variant

                       FDIV <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              Elem[result, e, esize] = FPDiv(element1, element2, FPCR);

                         V[d] = result;




C7-958                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.86     FDIV (scalar)

                Floating-point divide (scalar): Vd = Vn / Vm




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4          0
                  0 0 0 1 1 1 1 0 0 x 1                    Rm         0 0 0 1 1 0               Rn             Rd
                                            type


                Single-precision variant

                Applies when type = 00.

                FDIV <Sd>, <Sn>, <Sm>


                Double-precision variant

                Applies when type = 01.

                FDIV <Dd>, <Dn>, <Dm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) result;
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];

                 result = FPDiv(operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-959
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.87        FMADD

                       Floating-point fused multiply-add (scalar): Vd = Va + Vn*Vm




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14          10 9            5 4            0
                            0 0 0 1 1 1 1 1 0 x 0                    Rm       0       Ra              Rn              Rd
                                                      type o1                 o0


                       Single-precision variant

                       Applies when type = 00.

                       FMADD <Sd>, <Sn>, <Sm>, <Sa>


                       Double-precision variant

                       Applies when type = 01.

                       FMADD <Dd>, <Dn>, <Dm>, <Da>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer a = UInt(Ra);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean opa_neg = (o1 == '1');
                         boolean op1_neg = (o0 != o1);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                                         "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                                         "Rm" field.

                       <Da>              Is the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
                                         field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                                         "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                                         "Rm" field.

                       <Sa>              Is the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
                                         field.




C7-960                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                              ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) result;
                 bits(datasize) operanda = V[a];
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];

                 if opa_neg then operanda = FPNeg(operanda);
                 if op1_neg then operand1 = FPNeg(operand1);
                 result = FPMulAdd(operanda, operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-961
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.88        FMAX (vector)

                       Floating-point maximum (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 0 0 1 1 1 0 0 sz 1                  Rm         1 1 1 1 0 1              Rn              Rd
                                  U                 o1


                       Three registers of the same type variant

                       FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean pair = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              if pair then
                                   element1 = Elem[concat, 2*e, esize];
                                   element2 = Elem[concat, (2*e)+1, esize];
                              else
                                   element1 = Elem[operand1, e, esize];
                                   element2 = Elem[operand2, e, esize];

                              if minimum then
                                   Elem[result, e, esize] = FPMin(element1, element2, FPCR);



C7-962                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    else
                         Elem[result, e, esize] = FPMax(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-963
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.89        FMAX (scalar)

                       Floating-point maximum (scalar): Vd = max(Vn, Vm)




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1                    Rm       0 1 0 0 1 0             Rn             Rd
                                                      type                           op


                       Single-precision variant

                       Applies when type = 00.

                       FMAX <Sd>, <Sn>, <Sm>


                       Double-precision variant

                       Applies when type = 01.

                       FMAX <Dd>, <Dn>, <Dm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         FPMaxMinOp operation;
                         case op of
                              when '00' operation = FPMaxMinOp_MAX;
                              when '01' operation = FPMaxMinOp_MIN;
                              when '10' operation = FPMaxMinOp_MAXNUM;
                              when '11' operation = FPMaxMinOp_MINNUM;


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         case operation of




C7-964                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
                    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
                    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
                    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-965
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.90        FMAXNM (vector)

                       Floating-point maximum number (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 0 0 1 1 1 0 0 sz 1                  Rm         1 1 0 0 0 1              Rn              Rd
                                  U                 o1


                       Three registers of the same type variant

                       FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean pair = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              if pair then
                                   element1 = Elem[concat, 2*e, esize];
                                   element2 = Elem[concat, (2*e)+1, esize];
                              else
                                   element1 = Elem[operand1, e, esize];
                                   element2 = Elem[operand2, e, esize];

                              if minimum then
                                   Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);



C7-966                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    else
                         Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-967
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.91        FMAXNM (scalar)

                       Floating-point maximum number (scalar): Vd = maxNum(Vn, Vm)




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1                    Rm       0 1 1 0 1 0             Rn             Rd
                                                      type                           op


                       Single-precision variant

                       Applies when type = 00.

                       FMAXNM <Sd>, <Sn>, <Sm>


                       Double-precision variant

                       Applies when type = 01.

                       FMAXNM <Dd>, <Dn>, <Dm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         FPMaxMinOp operation;
                         case op of
                              when '00' operation = FPMaxMinOp_MAX;
                              when '01' operation = FPMaxMinOp_MIN;
                              when '10' operation = FPMaxMinOp_MAXNUM;
                              when '11' operation = FPMaxMinOp_MINNUM;


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         case operation of




C7-968                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
                    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
                    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
                    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-969
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.92        FMAXNMP (scalar)

                       Floating-point maximum number of pair of elements (scalar)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4             0
                            0 1 1 1 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 0 0 1 0                                   Rn              Rd
                                                     o1


                       Advanced SIMD variant

                       FMAXNMP <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize * 2;
                         integer elements = 2;

                         ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is the source arrangement specifier, encoded in the "sz" field. It can have the following values:

                                         2S          when sz = 0

                                         2D          when sz = 1


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         V[d] = Reduce(op, operand, esize);




C7-970                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.93     FMAXNMP (vector)

                Floating-point maximum number pairwise (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 0 sz 1                  Rm         1 1 0 0 0 1               Rn             Rd
                        U                 o1


                Three registers of the same type variant

                FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean pair = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     if pair then
                         element1 = Elem[concat, 2*e, esize];
                         element2 = Elem[concat, (2*e)+1, esize];
                     else
                         element1 = Elem[operand1, e, esize];
                         element2 = Elem[operand2, e, esize];

                     if minimum then
                         Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-971
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              else
                                   Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);

                         V[d] = result;




C7-972                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.94     FMAXNMV

                Floating-point maximum number across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 1 0 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 0 0 1 0                                   Rn              Rd
                                           o1


                Advanced SIMD variant

                FMAXNMV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q != '01' then ReservedValue();      // .4S only

                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;


                Assembler symbols

                <V>            Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                               S           when sz = 0

                               It is RESERVED when sz = 1.

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>            Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                               4S          when Q = 1, sz = 0

                               It is RESERVED when:

                               ·      Q = 0, sz = x.

                               ·      Q = 1, sz = 1.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 V[d] = Reduce(op, operand, esize);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-973
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.95        FMAXP (scalar)

                       Floating-point maximum of pair of elements (scalar)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4             0
                            0 1 1 1 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 1 1 1 0                                   Rn              Rd
                                                     o1


                       Advanced SIMD variant

                       FMAXP <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize * 2;
                         integer elements = 2;

                         ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is the source arrangement specifier, encoded in the "sz" field. It can have the following values:

                                         2S          when sz = 0

                                         2D          when sz = 1


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         V[d] = Reduce(op, operand, esize);




C7-974                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.96     FMAXP (vector)

                Floating-point maximum pairwise (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 0 sz 1                  Rm         1 1 1 1 0 1               Rn             Rd
                        U                 o1


                Three registers of the same type variant

                FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean pair = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     if pair then
                         element1 = Elem[concat, 2*e, esize];
                         element2 = Elem[concat, (2*e)+1, esize];
                     else
                         element1 = Elem[operand1, e, esize];
                         element2 = Elem[operand2, e, esize];

                     if minimum then
                         Elem[result, e, esize] = FPMin(element1, element2, FPCR);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-975
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              else
                                   Elem[result, e, esize] = FPMax(element1, element2, FPCR);

                         V[d] = result;




C7-976                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.97     FMAXV

                Floating-point maximum across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 1 0 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 1 1 1 0                                   Rn              Rd
                                           o1


                Advanced SIMD variant

                FMAXV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q != '01' then ReservedValue();

                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;


                Assembler symbols

                <V>            Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                               S           when sz = 0

                               It is RESERVED when sz = 1.

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>            Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                               4S          when Q = 1, sz = 0

                               It is RESERVED when:

                               ·      Q = 0, sz = x.

                               ·      Q = 1, sz = 1.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 V[d] = Reduce(op, operand, esize);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-977
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.98        FMIN (vector)

                       Floating-point minimum (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 0 0 1 1 1 0 1 sz 1                  Rm         1 1 1 1 0 1              Rn              Rd
                                  U                 o1


                       Three registers of the same type variant

                       FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean pair = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              if pair then
                                   element1 = Elem[concat, 2*e, esize];
                                   element2 = Elem[concat, (2*e)+1, esize];
                              else
                                   element1 = Elem[operand1, e, esize];
                                   element2 = Elem[operand2, e, esize];

                              if minimum then
                                   Elem[result, e, esize] = FPMin(element1, element2, FPCR);



C7-978                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    else
                         Elem[result, e, esize] = FPMax(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-979
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.99        FMIN (scalar)

                       Floating-point minimum (scalar): Vd = min(Vn, Vm)




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1                    Rm       0 1 0 1 1 0             Rn             Rd
                                                      type                           op


                       Single-precision variant

                       Applies when type = 00.

                       FMIN <Sd>, <Sn>, <Sm>


                       Double-precision variant

                       Applies when type = 01.

                       FMIN <Dd>, <Dn>, <Dm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         FPMaxMinOp operation;
                         case op of
                              when '00' operation = FPMaxMinOp_MAX;
                              when '01' operation = FPMaxMinOp_MIN;
                              when '10' operation = FPMaxMinOp_MAXNUM;
                              when '11' operation = FPMaxMinOp_MINNUM;


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         case operation of




C7-980                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
                    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
                    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
                    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-981
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.100       FMINNM (vector)

                       Floating-point minimum number (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 0 0 1 1 1 0 1 sz 1                  Rm         1 1 0 0 0 1              Rn              Rd
                                  U                 o1


                       Three registers of the same type variant

                       FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean pair = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              if pair then
                                   element1 = Elem[concat, 2*e, esize];
                                   element2 = Elem[concat, (2*e)+1, esize];
                              else
                                   element1 = Elem[operand1, e, esize];
                                   element2 = Elem[operand2, e, esize];

                              if minimum then
                                   Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);



C7-982                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    else
                         Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-983
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.101       FMINNM (scalar)

                       Floating-point minimum number (scalar): Vd = minNum(Vn, Vm)




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1                    Rm       0 1 1 1 1 0             Rn             Rd
                                                      type                           op


                       Single-precision variant

                       Applies when type = 00.

                       FMINNM <Sd>, <Sn>, <Sm>


                       Double-precision variant

                       Applies when type = 01.

                       FMINNM <Dd>, <Dn>, <Dm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         FPMaxMinOp operation;
                         case op of
                              when '00' operation = FPMaxMinOp_MAX;
                              when '01' operation = FPMaxMinOp_MIN;
                              when '10' operation = FPMaxMinOp_MAXNUM;
                              when '11' operation = FPMaxMinOp_MINNUM;


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         case operation of




C7-984                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
                    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
                    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
                    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-985
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.102       FMINNMP (scalar)

                       Floating-point minimum number of pair of elements (scalar)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4             0
                            0 1 1 1 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 0 0 1 0                                   Rn              Rd
                                                     o1


                       Advanced SIMD variant

                       FMINNMP <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize * 2;
                         integer elements = 2;

                         ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is the source arrangement specifier, encoded in the "sz" field. It can have the following values:

                                         2S          when sz = 0

                                         2D          when sz = 1


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         V[d] = Reduce(op, operand, esize);




C7-986                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.103    FMINNMP (vector)

                Floating-point minimum number pairwise (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 1 sz 1                  Rm         1 1 0 0 0 1               Rn             Rd
                        U                 o1


                Three registers of the same type variant

                FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean pair = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     if pair then
                         element1 = Elem[concat, 2*e, esize];
                         element2 = Elem[concat, (2*e)+1, esize];
                     else
                         element1 = Elem[operand1, e, esize];
                         element2 = Elem[operand2, e, esize];

                     if minimum then
                         Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-987
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              else
                                   Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);

                         V[d] = result;




C7-988                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.104    FMINNMV

                Floating-point minimum number across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 1 0 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 0 0 1 0                                   Rn              Rd
                                           o1


                Advanced SIMD variant

                FMINNMV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q != '01' then ReservedValue();      // .4S only

                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;


                Assembler symbols

                <V>            Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                               S           when sz = 0

                               It is RESERVED when sz = 1.

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>            Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                               4S          when Q = 1, sz = 0

                               It is RESERVED when:

                               ·      Q = 0, sz = x.

                               ·      Q = 1, sz = 1.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 V[d] = Reduce(op, operand, esize);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-989
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.105       FMINP (scalar)

                       Floating-point minimum of pair of elements (scalar)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4             0
                            0 1 1 1 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 1 1 1 0                                   Rn              Rd
                                                     o1


                       Advanced SIMD variant

                       FMINP <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize * 2;
                         integer elements = 2;

                         ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is the source arrangement specifier, encoded in the "sz" field. It can have the following values:

                                         2S          when sz = 0

                                         2D          when sz = 1


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         V[d] = Reduce(op, operand, esize);




C7-990                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.106    FMINP (vector)

                Floating-point minimum pairwise (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 1 sz 1                  Rm         1 1 1 1 0 1               Rn             Rd
                        U                 o1


                Three registers of the same type variant

                FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean pair = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     if pair then
                         element1 = Elem[concat, 2*e, esize];
                         element2 = Elem[concat, (2*e)+1, esize];
                     else
                         element1 = Elem[operand1, e, esize];
                         element2 = Elem[operand2, e, esize];

                     if minimum then
                         Elem[result, e, esize] = FPMin(element1, element2, FPCR);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-991
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              else
                                   Elem[result, e, esize] = FPMax(element1, element2, FPCR);

                         V[d] = result;




C7-992                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.107    FMINV

                Floating-point minimum across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 1 0 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 1 1 1 0                                   Rn              Rd
                                           o1


                Advanced SIMD variant

                FMINV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q != '01' then ReservedValue();

                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;


                Assembler symbols

                <V>            Is the destination width specifier, encoded in the "sz" field. It can have the following values:

                               S           when sz = 0

                               It is RESERVED when sz = 1.

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>            Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                               4S          when Q = 1, sz = 0

                               It is RESERVED when:

                               ·      Q = 0, sz = x.

                               ·      Q = 1, sz = 1.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 V[d] = Reduce(op, operand, esize);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-993
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.108       FMLA (by element)

                       Floating-point fused multiply-add to accumulator (by element)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 1 0 1 1 1 1 1 1 sz L M                Rm       0 0 0 1 H 0            Rn     Rd
                                                                               o2


                       Scalar variant

                       FMLA <V><d>, <V><n>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi = M;
                         case sz:L of
                              when '0x' index = UInt(H:L);
                              when '10' index = UInt(H);
                              when '11' UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean sub_op = (o2 == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 Q 0 0 1 1 1 1 1 sz L M                Rm       0 0 0 1 H 0            Rn     Rd
                                                                               o2


                       Vector variant

                       FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi = M;
                         case sz:L of
                              when '0x' index = UInt(H:L);
                              when '10' index = UInt(H);
                              when '11' UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean sub_op = (o2 == '1');



C7-994                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <V>           Is a width specifier, encoded in the "sz" field. It can have the following values:

                              S           when sz = 0

                              D           when sz = 1

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                              2S          when Q = 0, sz = 0

                              4S          when Q = 1, sz = 0

                              2D          when Q = 1, sz = 1

                              It is RESERVED when Q = 0, sz = 1.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          For the scalar variant: is the name of the SIMD&FP source register, encoded in the "M:Rm" fields.

                              For the vector variant: is the name of the second SIMD&FP source register, encoded in the "M:Rm"
                              fields.

                <Ts>          For the scalar variant: is the element width specifier, encoded in the "sz" field. It can have the
                              following values:

                              S           when sz = 0

                              D           when sz = 1

                              For the vector variant: is an element size specifier, encoded in the "sz" field. It can have the
                              following values:

                              S           when sz = 0

                              D           when sz = 1

                <index>       For the scalar variant: is the element index, encoded in the "sz:L:H" field. It can have the following
                              values:

                              H:L         when sz = 0, L = x

                              H           when sz = 1, L = 0

                              It is RESERVED when sz = 1, L = 1.

                              For the vector variant: is the element index encoded in the "sz:L:H" field. It can have the following
                              values:

                              H:L         when sz = 0, L = x

                              H           when sz = 1, L = 0

                              It is RESERVED when sz = 1, L = 1.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) operand3 = V[d];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2 = Elem[operand2, index, esize];

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-995
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              if sub_op then element1 = FPNeg(element1);
                              Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
                         V[d] = result;




C7-996                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.              ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                     ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.109    FMLA (vector)

                Floating-point fused multiply-add to accumulator (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 0 sz 1                  Rm         1 1 0 0 1 1               Rn             Rd
                                          op


                Three registers of the same type variant

                FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean sub_op = (op == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) operand3 = V[d];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     if sub_op then element1 = FPNeg(element1);
                     Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-997
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.110       FMLS (by element)

                       Floating-point fused multiply-subtract from accumulator (by element)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 1 0 1 1 1 1 1 1 sz L M                Rm       0 1 0 1 H 0            Rn     Rd
                                                                               o2


                       Scalar variant

                       FMLS <V><d>, <V><n>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi = M;
                         case sz:L of
                              when '0x' index = UInt(H:L);
                              when '10' index = UInt(H);
                              when '11' UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean sub_op = (o2 == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 Q 0 0 1 1 1 1 1 sz L M                Rm       0 1 0 1 H 0            Rn     Rd
                                                                               o2


                       Vector variant

                       FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi = M;
                         case sz:L of
                              when '0x' index = UInt(H:L);
                              when '10' index = UInt(H);
                              when '11' UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean sub_op = (o2 == '1');



C7-998                                     Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <V>           Is a width specifier, encoded in the "sz" field. It can have the following values:

                              S           when sz = 0

                              D           when sz = 1

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                              2S          when Q = 0, sz = 0

                              4S          when Q = 1, sz = 0

                              2D          when Q = 1, sz = 1

                              It is RESERVED when Q = 0, sz = 1.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          For the scalar variant: is the name of the SIMD&FP source register, encoded in the "M:Rm" fields.

                              For the vector variant: is the name of the second SIMD&FP source register, encoded in the "M:Rm"
                              fields.

                <Ts>          For the scalar variant: is the element width specifier, encoded in the "sz" field. It can have the
                              following values:

                              S           when sz = 0

                              D           when sz = 1

                              For the vector variant: is an element size specifier, encoded in the "sz" field. It can have the
                              following values:

                              S           when sz = 0

                              D           when sz = 1

                <index>       For the scalar variant: is the element index, encoded in the "sz:L:H" field. It can have the following
                              values:

                              H:L         when sz = 0, L = x

                              H           when sz = 1, L = 0

                              It is RESERVED when sz = 1, L = 1.

                              For the vector variant: is the element index encoded in the "sz:L:H" field. It can have the following
                              values:

                              H:L         when sz = 0, L = x

                              H           when sz = 1, L = 0

                              It is RESERVED when sz = 1, L = 1.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) operand3 = V[d];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2 = Elem[operand2, index, esize];

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-999
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              if sub_op then element1 = FPNeg(element1);
                              Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
                         V[d] = result;




C7-1000                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.              ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                     ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.111    FMLS (vector)

                Floating-point fused multiply-subtract from accumulator (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 1 sz 1                  Rm         1 1 0 0 1 1                Rn             Rd
                                           op


                Three registers of the same type variant

                FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean sub_op = (op == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S           when sz = 0, Q = 0

                               4S           when sz = 0, Q = 1

                               2D           when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) operand3 = V[d];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     if sub_op then element1 = FPNeg(element1);
                     Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1001
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.112       FMOV (vector, immediate)

                       Floating-point move immediate (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15             12 11 10 9 8 7 6 5 4                   0
                            0 Q op 0 1 1 1 1 0 0 0 0 0 a b c 1 1 1 1 0 1 d e f g h                                       Rd
                                                                                  cmode


                       Single-precision variant

                       Applies when op = 0.

                       FMOV <Vd>.<T>, #<imm>


                       Double-precision variant

                       Applies when Q = 1 && op = 1.

                       FMOV <Vd>.2D, #<imm>


                       Decode for all variants of this encoding

                         integer rd = UInt(Rd);

                         integer datasize = if Q == '1' then 128 else 64;
                         bits(datasize) imm;
                         bits(64) imm64;

                         ImmediateOp operation;
                         case cmode:op of
                              when '0xx00' operation = ImmediateOp_MOVI;
                              when '0xx01' operation = ImmediateOp_MVNI;
                              when '0xx10' operation = ImmediateOp_ORR;
                              when '0xx11' operation = ImmediateOp_BIC;
                              when '10x00' operation = ImmediateOp_MOVI;
                              when '10x01' operation = ImmediateOp_MVNI;
                              when '10x10' operation = ImmediateOp_ORR;
                              when '10x11' operation = ImmediateOp_BIC;
                              when '110x0' operation = ImmediateOp_MOVI;
                              when '110x1' operation = ImmediateOp_MVNI;
                              when '1110x' operation = ImmediateOp_MOVI;
                              when '11110' operation = ImmediateOp_MOVI;
                              when '11111'
                                   // FMOV Dn,#imm is in main FP instruction set
                                   if Q == '0' then UnallocatedEncoding();
                                   operation = ImmediateOp_MOVI;

                         imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
                         imm = Replicate(imm64, datasize DIV 64);


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                         2S           when Q = 0

                                         4S           when Q = 1

                       <imm>             Is a floating-point constant with sign, 3-bit exponent and normalized 4 bits of precision, encoded in
                                         "a:b:c:d:e:f:g:h".



C7-1002                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                 ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand;
                 bits(datasize) result;

                 case operation of
                    when ImmediateOp_MOVI
                         result = imm;
                    when ImmediateOp_MVNI
                         result = NOT(imm);
                    when ImmediateOp_ORR
                         operand = V[rd];
                         result = operand OR imm;
                    when ImmediateOp_BIC
                        operand = V[rd];
                        result = operand AND NOT(imm);

                 V[rd] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                             C7-1003
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.113       FMOV (register)

                       Floating-point move register without conversion: Vd = Vn




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9              5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 0 0 0 0 1 0 0 0 0                              Rn             Rd
                                                      type                opc


                       Single-precision variant

                       Applies when type = 00.

                       FMOV <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FMOV <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         FPUnaryOp fpop;
                         case opc of
                              when '00' fpop = FPUnaryOp_MOV;
                              when '01' fpop = FPUnaryOp_ABS;
                              when '10' fpop = FPUnaryOp_NEG;
                              when '11' fpop = FPUnaryOp_SQRT;


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         case fpop of
                              when FPUnaryOp_MOV    result = operand;
                              when FPUnaryOp_ABS    result = FPAbs(operand);
                              when FPUnaryOp_NEG    result = FPNeg(operand);




C7-1004                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                           ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1005
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.114       FMOV (general)

                       Floating-point move to or from general-purpose register without conversion




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18    16 15 14 13 12 11 10 9         5 4    0
                            sf 0 0 1 1 1 1 0 type 1 0 x 1 1 x 0 0 0 0 0 0                           Rn     Rd
                                                             rmode opcode


                       32-bit to single-precision variant

                       Applies when sf = 0 && type = 00 && rmode = 00 && opcode = 111.

                       FMOV <Sd>, <Wn>


                       Single-precision to 32-bit variant

                       Applies when sf = 0 && type = 00 && rmode = 00 && opcode = 110.

                       FMOV <Wd>, <Sn>


                       64-bit to double-precision variant

                       Applies when sf = 1 && type = 01 && rmode = 00 && opcode = 111.

                       FMOV <Dd>, <Xn>


                       64-bit to top half of 128-bit variant

                       Applies when sf = 1 && type = 10 && rmode = 01 && opcode = 111.

                       FMOV <Vd>.D[1], <Xn>


                       Double-precision to 64-bit variant

                       Applies when sf = 1 && type = 01 && rmode = 00 && opcode = 110.

                       FMOV <Xd>, <Dn>


                       Top half of 128-bit to 64-bit variant

                       Applies when sf = 1 && type = 10 && rmode = 01 && opcode = 110.

                       FMOV <Xd>, <Vn>.D[1]


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();



C7-1006                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         fltsize = 128;
                    when '11'
                         UnallocatedEncoding();

                 case opcode<2:1>:rmode of
                    when '00 xx'         // FCVT[NPMZ][US]
                         rounding = FPDecodeRounding(rmode);
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '01 00'         // [US]CVTF
                         rounding = FPRoundingMode(FPCR);
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Dd>          Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sd>          Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Wn>          Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Xn>          Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Wd>          Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Xd>          Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Dn>          Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1007
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   intval = Vpart[n,part];
                                   X[d] = intval;
                              when FPConvOp_MOV_ItoF
                                   intval = X[n];
                                   Vpart[d,part] = intval;




C7-1008                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.115    FMOV (scalar, immediate)

                Floating-point move immediate (scalar): Vd=#imm




                  31 30 29 28 27 26 25 24 23 22 21 20                      13 12 11 10 9 8 7 6 5 4                   0
                  0 0 0 1 1 1 1 0 0 x 1                       imm8             1 0 0 0 0 0 0 0                Rd
                                            type


                Single-precision variant

                Applies when type = 00.

                FMOV <Sd>, #<imm>


                Double-precision variant

                Applies when type = 01.

                FMOV <Dd>, #<imm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 bits(datasize) imm = VFPExpandImm(imm8);


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <imm>          Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded
                               in the "imm8" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 V[d] = imm;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1009
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.116       FMSUB

                       Floating-point fused multiply-subtract (scalar): Vd = Va + (-Vn)*Vm




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14          10 9            5 4            0
                            0 0 0 1 1 1 1 1 0 x 0                    Rm        1      Ra              Rn              Rd
                                                      type o1                 o0


                       Single-precision variant

                       Applies when type = 00.

                       FMSUB <Sd>, <Sn>, <Sm>, <Sa>


                       Double-precision variant

                       Applies when type = 01.

                       FMSUB <Dd>, <Dn>, <Dm>, <Da>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer a = UInt(Ra);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean opa_neg = (o1 == '1');
                         boolean op1_neg = (o0 != o1);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                                         "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                                         "Rm" field.

                       <Da>              Is the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
                                         field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                                         "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                                         "Rm" field.

                       <Sa>              Is the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
                                         field.




C7-1010                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) result;
                 bits(datasize) operanda = V[a];
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];

                 if opa_neg then operanda = FPNeg(operanda);
                 if op1_neg then operand1 = FPNeg(operand1);
                 result = FPMulAdd(operanda, operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1011
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.117       FMUL (by element)

                       Floating-point multiply (by element)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 1 0 1 1 1 1 1 1 sz L M                Rm       1 0 0 1 H 0            Rn     Rd
                                  U


                       Scalar variant

                       FMUL <V><d>, <V><n>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi = M;
                         case sz:L of
                              when '0x' index = UInt(H:L);
                              when '10' index = UInt(H);
                              when '11' UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean mulx_op = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 Q 0 0 1 1 1 1 1 sz L M                Rm       1 0 0 1 H 0            Rn     Rd
                                  U


                       Vector variant

                       FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi = M;
                         case sz:L of
                              when '0x' index = UInt(H:L);
                              when '10' index = UInt(H);
                              when '11' UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean mulx_op = (U == '1');



C7-1012                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <V>           Is a width specifier, encoded in the "sz" field. It can have the following values:

                              S           when sz = 0

                              D           when sz = 1

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                              2S          when Q = 0, sz = 0

                              4S          when Q = 1, sz = 0

                              2D          when Q = 1, sz = 1

                              It is RESERVED when Q = 0, sz = 1.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          For the scalar variant: is the name of the SIMD&FP source register, encoded in the "M:Rm" fields.

                              For the vector variant: is the name of the second SIMD&FP source register, encoded in the "M:Rm"
                              fields.

                <Ts>          For the scalar variant: is the element width specifier, encoded in the "sz" field. It can have the
                              following values:

                              S           when sz = 0

                              D           when sz = 1

                              For the vector variant: is an element size specifier, encoded in the "sz" field. It can have the
                              following values:

                              S           when sz = 0

                              D           when sz = 1

                <index>       For the scalar variant: is the element index, encoded in the "sz:L:H" field. It can have the following
                              values:

                              H:L         when sz = 0, L = x

                              H           when sz = 1, L = 0

                              It is RESERVED when sz = 1, L = 1.

                              For the vector variant: is the element index encoded in the "sz:L:H" field. It can have the following
                              values:

                              H:L         when sz = 0, L = x

                              H           when sz = 1, L = 0

                              It is RESERVED when sz = 1, L = 1.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2 = Elem[operand2, index, esize];

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     if mulx_op then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1013
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
                              else
                                   Elem[result, e, esize] = FPMul(element1, element2, FPCR);

                         V[d] = result;




C7-1014                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.118    FMUL (vector)

                Floating-point multiply (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 0 sz 1                  Rm         1 1 0 1 1 1               Rn             Rd




                Three registers of the same type variant

                FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S          when sz = 0, Q = 0

                               4S          when sz = 0, Q = 1

                               2D          when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     Elem[result, e, esize] = FPMul(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1015
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.119       FMUL (scalar)

                       Floating-point multiply (scalar): Vd = Vn * Vm




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1                    Rm       0 0 0 0 1 0             Rn             Rd
                                                      type                    op


                       Single-precision variant

                       Applies when type = 00.

                       FMUL <Sd>, <Sn>, <Sm>


                       Double-precision variant

                       Applies when type = 01.

                       FMUL <Dd>, <Dn>, <Dm>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean negated = (op == '1');


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Dm>              Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Sm>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         result = FPMul(operand1, operand2, FPCR);

                         if negated then result = FPNeg(result);

                         V[d] = result;




C7-1016                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.120    FMULX (by element)

                Floating-point multiply extended (by element)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 1 sz L M                Rm        1 0 0 1 H 0              Rn             Rd
                        U


                Scalar variant

                FMULX <V><d>, <V><n>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi = M;
                 case sz:L of
                     when '0x' index = UInt(H:L);
                     when '10' index = UInt(H);
                     when '11' UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean mulx_op = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 1 sz L M                Rm        1 0 0 1 H 0              Rn             Rd
                        U


                Vector variant

                FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi = M;
                 case sz:L of
                     when '0x' index = UInt(H:L);
                     when '10' index = UInt(H);
                     when '11' UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean mulx_op = (U == '1');



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1017
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "Q:sz" field. It can have the following values:

                                         2S          when Q = 0, sz = 0

                                         4S          when Q = 1, sz = 0

                                         2D          when Q = 1, sz = 1

                                         It is RESERVED when Q = 0, sz = 1.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              For the scalar variant: is the name of the SIMD&FP source register, encoded in the "M:Rm" fields.

                                         For the vector variant: is the name of the second SIMD&FP source register, encoded in the "M:Rm"
                                         fields.

                       <Ts>              For the scalar variant: is the element width specifier, encoded in the "sz" field. It can have the
                                         following values:

                                         S           when sz = 0

                                         D           when sz = 1

                                         For the vector variant: is an element size specifier, encoded in the "sz" field. It can have the
                                         following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <index>           For the scalar variant: is the element index, encoded in the "sz:L:H" field. It can have the following
                                         values:

                                         H:L         when sz = 0, L = x

                                         H           when sz = 1, L = 0

                                         It is RESERVED when sz = 1, L = 1.

                                         For the vector variant: is the element index encoded in the "sz:L:H" field. It can have the following
                                         values:

                                         H:L         when sz = 0, L = x

                                         H           when sz = 1, L = 0

                                         It is RESERVED when sz = 1, L = 1.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(idxdsize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2 = Elem[operand2, index, esize];

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              if mulx_op then



C7-1018                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
                    else
                        Elem[result, e, esize] = FPMul(element1, element2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1019
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.121       FMULX

                       Floating-point multiply extended


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                            0 1 0 1 1 1 1 0 0 sz 1                   Rm         1 1 0 1 1 1               Rn             Rd




                       Scalar variant

                       FMULX <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                            0 Q 0 0 1 1 1 0 0 sz 1                   Rm         1 1 0 1 1 1               Rn             Rd




                       Vector variant

                       FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0



C7-1020                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              4S         when sz = 0, Q = 1

                              2D         when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1021
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.122       FNEG (vector)

                       Floating-point negate (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                            0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 1 1 0                                Rn              Rd
                                  U


                       Vector variant

                       FNEG <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean neg = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              if neg then
                                   element = FPNeg(element);
                              else
                                   element = FPAbs(element);
                              Elem[result, e, esize] = element;

                         V[d] = result;




C7-1022                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.123    FNEG (scalar)

                Floating-point negate (scalar): Vd = -Vn




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 0 0 1 1 1 1 0 0 x 1 0 0 0 0 1 0 1 0 0 0 0                                  Rn             Rd
                                            type                  opc


                Single-precision variant

                Applies when type = 00.

                FNEG <Sd>, <Sn>


                Double-precision variant

                Applies when type = 01.

                FNEG <Dd>, <Dn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 FPUnaryOp fpop;
                 case opc of
                     when '00' fpop = FPUnaryOp_MOV;
                     when '01' fpop = FPUnaryOp_ABS;
                     when '10' fpop = FPUnaryOp_NEG;
                     when '11' fpop = FPUnaryOp_SQRT;


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(datasize) result;
                 bits(datasize) operand = V[n];

                 case fpop of
                     when FPUnaryOp_MOV    result = operand;
                     when FPUnaryOp_ABS    result = FPAbs(operand);
                     when FPUnaryOp_NEG    result = FPNeg(operand);




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1023
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);

                         V[d] = result;




C7-1024                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.124    FNMADD

                Floating-point negated fused multiply-add (scalar): Vd = (-Va) + (-Vn)*Vm




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14             10 9              5 4          0
                  0 0 0 1 1 1 1 1 0 x 1                    Rm        0       Ra                 Rn             Rd
                                            type o1                 o0


                Single-precision variant

                Applies when type = 00.

                FNMADD <Sd>, <Sn>, <Sm>, <Sa>


                Double-precision variant

                Applies when type = 01.

                FNMADD <Dd>, <Dn>, <Dm>, <Da>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer a = UInt(Ra);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean opa_neg = (o1 == '1');
                 boolean op1_neg = (o0 != o1);


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                               "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                               "Rm" field.

                <Da>           Is the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
                               field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                               "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                               "Rm" field.

                <Sa>           Is the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
                               field.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1025
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operanda = V[a];
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         if opa_neg then operanda = FPNeg(operanda);
                         if op1_neg then operand1 = FPNeg(operand1);
                         result = FPMulAdd(operanda, operand1, operand2, FPCR);

                         V[d] = result;




C7-1026                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.125    FNMSUB

                Floating-point negated fused multiply-subtract (scalar): Vd = (-Va) + Vn*Vm




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14             10 9              5 4          0
                  0 0 0 1 1 1 1 1 0 x 1                    Rm        1        Ra                Rn             Rd
                                            type o1                 o0


                Single-precision variant

                Applies when type = 00.

                FNMSUB <Sd>, <Sn>, <Sm>, <Sa>


                Double-precision variant

                Applies when type = 01.

                FNMSUB <Dd>, <Dn>, <Dm>, <Da>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer a = UInt(Ra);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean opa_neg = (o1 == '1');
                 boolean op1_neg = (o0 != o1);


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                               "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                               "Rm" field.

                <Da>           Is the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
                               field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
                               "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
                               "Rm" field.

                <Sa>           Is the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
                               field.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1027
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) result;
                         bits(datasize) operanda = V[a];
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];

                         if opa_neg then operanda = FPNeg(operanda);
                         if op1_neg then operand1 = FPNeg(operand1);
                         result = FPMulAdd(operanda, operand1, operand2, FPCR);

                         V[d] = result;




C7-1028                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.126    FNMUL

                Floating-point multiply-negate (scalar): Vd = -(Vn * Vm)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4          0
                  0 0 0 1 1 1 1 0 0 x 1                    Rm        1 0 0 0 1 0                Rn             Rd
                                            type                    op


                Single-precision variant

                Applies when type = 00.

                FNMUL <Sd>, <Sn>, <Sm>


                Double-precision variant

                Applies when type = 01.

                FNMUL <Dd>, <Dn>, <Dm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean negated = (op == '1');


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) result;
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];

                 result = FPMul(operand1, operand2, FPCR);

                 if negated then result = FPNeg(result);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1029
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.127       FRECPE

                       Floating-point reciprocal estimate


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                            0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0                                  Rn             Rd




                       Scalar variant

                       FRECPE <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                            0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0                                  Rn             Rd




                       Vector variant

                       FRECPE <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1



C7-1030                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2D         when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRecipEstimate(element, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1031
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.128       FRECPS

                       Floating-point reciprocal step


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                            0 1 0 1 1 1 1 0 0 sz 1                   Rm         1 1 1 1 1 1               Rn             Rd




                       Scalar variant

                       FRECPS <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                            0 Q 0 0 1 1 1 0 0 sz 1                   Rm         1 1 1 1 1 1               Rn             Rd




                       Vector variant

                       FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0



C7-1032                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              4S         when sz = 0, Q = 1

                              2D         when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     Elem[result, e, esize] = FPRecipStepFused(element1, element2);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1033
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.129       FRECPX

                       Floating-point reciprocal exponent (scalar)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4         0
                            0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 1 1 1 0                                  Rn             Rd




                       Scalar variant

                       FRECPX <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              Elem[result, e, esize] = FPRecpX(element, FPCR);

                         V[d] = result;




C7-1034                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                             ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.130    FRINTA (vector)

                Floating-point round to integral, to nearest with ties to away (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 0 1 0                                  Rn             Rd
                        U                  o2                                   o1


                Vector variant

                FRINTA <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1035
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.131       FRINTA (scalar)

                       Floating-point round to integral, to nearest with ties to away (scalar): Vd = roundToIntegralTiesToAway(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17       15 14 13 12 11 10 9             5 4           0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 1 0 0 1 0 0 0 0                                Rn             Rd
                                                      type              rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTA <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTA <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1036                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                              ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.132    FRINTI (vector)

                Floating-point round to integral, using current rounding mode (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 0 1 1 0                                  Rn             Rd
                        U                  o2                                 o1


                Vector variant

                FRINTI <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1037
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.133       FRINTI (scalar)

                       Floating-point round to integral, using current rounding mode (scalar): Vd = roundToIntegral(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17      15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 1 1 1 1 0 0 0 0                              Rn             Rd
                                                      type              rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTI <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTI <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1038                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.134    FRINTM (vector)

                Floating-point round to integral, toward minus infinity (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 1 1 0                                  Rn             Rd
                        U                  o2                                 o1


                Vector variant

                FRINTM <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1039
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.135       FRINTM (scalar)

                       Floating-point round to integral, toward minus infinity (scalar): Vd = roundToIntegralTowardNegative(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17      15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 0 1 0 1 0 0 0 0                              Rn             Rd
                                                      type             rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTM <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTM <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1040                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.136    FRINTN (vector)

                Floating-point round to integral, to nearest with ties to even (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 0 1 0                                  Rn             Rd
                        U                  o2                                   o1


                Vector variant

                FRINTN <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1041
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.137       FRINTN (scalar)

                       Floating-point round to integral, to nearest with ties to even (scalar): Vd = roundToIntegralTiesToEven(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17       15 14 13 12 11 10 9             5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 0 0 0 1 0 0 0 0                                 Rn            Rd
                                                      type              rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTN <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTN <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1042                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                              ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.138    FRINTP (vector)

                Floating-point round to integral, toward positive infinity (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 0 0 1 0                                  Rn             Rd
                        U                  o2                                   o1


                Vector variant

                FRINTP <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1043
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.139       FRINTP (scalar)

                       Floating-point round to integral, toward positive infinity (scalar): Vd = roundToIntegralTowardPositive(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17      15 14 13 12 11 10 9             5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 0 0 1 1 0 0 0 0                                Rn            Rd
                                                      type             rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTP <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTP <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1044                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                     ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                              ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.140    FRINTX (vector)

                Floating-point round to integral exact, using current rounding mode (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4          0
                  0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 1 1 0                                   Rn             Rd
                        U                  o2                                 o1


                Vector variant

                FRINTX <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1045
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.141       FRINTX (scalar)

                       Floating-point round to integral exact, using current rounding mode (scalar): Vd = roundToIntegralExact(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17      15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 1 1 0 1 0 0 0 0                              Rn             Rd
                                                      type             rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTX <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTX <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1046                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                            ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.142    FRINTZ (vector)

                Floating-point round to integral, toward zero (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 0 1 1 0                                  Rn             Rd
                        U                  o2                                 o1


                Vector variant

                FRINTZ <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean exact = FALSE;
                 FPRounding rounding;
                 case U:o1:o2 of
                     when '0xx' rounding = FPDecodeRounding(o1:o2);
                     when '100' rounding = FPRounding_TIEAWAY;
                     when '101' UnallocatedEncoding();
                     when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                     when '111' rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1

                                2D          when sz = 1, Q = 1

                                It is RESERVED when sz = 1, Q = 0.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1047
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.143       FRINTZ (scalar)

                       Floating-point round to integral, toward zero (scalar): Vd = roundToIntegralTowardZero(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17      15 14 13 12 11 10 9            5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 1 0 1 1 1 0 0 0 0                              Rn             Rd
                                                      type             rmode


                       Single-precision variant

                       Applies when type = 00.

                       FRINTZ <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FRINTZ <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         boolean exact = FALSE;
                         FPRounding rounding;
                         case rmode of
                              when '0xx' rounding = FPDecodeRounding(rmode<1:0>);
                              when '100' rounding = FPRounding_TIEAWAY;
                              when '101' UnallocatedEncoding();
                              when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
                              when '111' rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         result = FPRoundInt(operand, FPCR, rounding, exact);

                         V[d] = result;




C7-1048                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.144    FRSQRTE

                Floating-point reciprocal square root estimate


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0                                   Rn             Rd




                Scalar variant

                FRSQRTE <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                  0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0                                   Rn             Rd




                Vector variant

                FRSQRTE <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;


                Assembler symbols

                <V>             Is a width specifier, encoded in the "sz" field. It can have the following values:

                                S           when sz = 0

                                D           when sz = 1

                <d>             Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>             Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0

                                4S          when sz = 0, Q = 1



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1049
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         2D         when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);

                         V[d] = result;




C7-1050                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                    ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.145    FRSQRTS

                Floating-point reciprocal square root step


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                  0 1 0 1 1 1 1 0 1 sz 1                    Rm         1 1 1 1 1 1               Rn             Rd




                Scalar variant

                FRSQRTS <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                  0 Q 0 0 1 1 1 0 1 sz 1                    Rm         1 1 1 1 1 1               Rn             Rd




                Vector variant

                FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;


                Assembler symbols

                <V>             Is a width specifier, encoded in the "sz" field. It can have the following values:

                                S           when sz = 0

                                D           when sz = 1

                <d>             Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>             Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>             Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                2S          when sz = 0, Q = 0



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1051
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         4S         when sz = 0, Q = 1

                                         2D         when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);

                         V[d] = result;




C7-1052                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.146    FSQRT (vector)

                Floating-point square root (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4           0
                  0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 1 1 1 0                                 Rn             Rd




                Vector variant

                FSQRT <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                               2S           when sz = 0, Q = 0

                               4S           when sz = 0, Q = 1

                               2D           when sz = 1, Q = 1

                               It is RESERVED when sz = 1, Q = 0.

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FPSqrt(element, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1053
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.147       FSQRT (scalar)

                       Floating-point square root (scalar): Vd = sqrt(Vn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9              5 4            0
                            0 0 0 1 1 1 1 0 0 x 1 0 0 0 0 1 1 1 0 0 0 0                              Rn             Rd
                                                      type                opc


                       Single-precision variant

                       Applies when type = 00.

                       FSQRT <Sd>, <Sn>


                       Double-precision variant

                       Applies when type = 01.

                       FSQRT <Dd>, <Dn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer datasize;
                         case type of
                              when '00' datasize = 32;
                              when '01' datasize = 64;
                              when '1x' UnallocatedEncoding();

                         FPUnaryOp fpop;
                         case opc of
                              when '00' fpop = FPUnaryOp_MOV;
                              when '01' fpop = FPUnaryOp_ABS;
                              when '10' fpop = FPUnaryOp_NEG;
                              when '11' fpop = FPUnaryOp_SQRT;


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Dn>              Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(datasize) result;
                         bits(datasize) operand = V[n];

                         case fpop of
                              when FPUnaryOp_MOV    result = operand;
                              when FPUnaryOp_ABS    result = FPAbs(operand);
                              when FPUnaryOp_NEG    result = FPNeg(operand);




C7-1054                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                    ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                           ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1055
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.148       FSUB (vector)

                       Floating-point subtract (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4            0
                            0 Q 0 0 1 1 1 0 1 sz 1                  Rm         1 1 0 1 0 1              Rn              Rd
                                  U


                       Three registers of the same type variant

                       FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean abs = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         2D          when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         bits(esize) diff;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              diff = FPSub(element1, element2, FPCR);
                              Elem[result, e, esize] = if abs then FPAbs(diff) else diff;

                         V[d] = result;




C7-1056                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.149    FSUB (scalar)

                Floating-point subtract (scalar): Vd = Vn - Vm




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4          0
                  0 0 0 1 1 1 1 0 0 x 1                    Rm         0 0 1 1 1 0               Rn             Rd
                                            type                             op


                Single-precision variant

                Applies when type = 00.

                FSUB <Sd>, <Sn>, <Sm>


                Double-precision variant

                Applies when type = 01.

                FSUB <Dd>, <Dn>, <Dm>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize;
                 case type of
                     when '00' datasize = 32;
                     when '01' datasize = 64;
                     when '1x' UnallocatedEncoding();

                 boolean sub_op = (op == '1');


                Assembler symbols

                <Dd>           Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Dn>           Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Dm>           Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Sd>           Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>           Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Sm>           Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) result;
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];

                 if sub_op then
                     result = FPSub(operand1, operand2, FPCR);
                 else
                     result = FPAdd(operand1, operand2, FPCR);

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1057
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.150       INS (element)

                       Insert vector element from another vector element

                       This instruction is used by the alias MOV (element). The alias is always the preferred disassembly.




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14        11 10 9             5 4             0
                            0 1 1 0 1 1 1 0 0 0 0                  imm5        0     imm4     1         Rn              Rd




                       Advanced SIMD variant

                       INS <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer size = LowestSetBit(imm5);
                         if size > 3 then UnallocatedEncoding();

                         integer dst_index = UInt(imm5<4:size+1>);
                         integer src_index = UInt(imm4<3:size>);
                         integer idxdsize = if imm4<3> == '1' then 128 else 64;
                         // imm4<size-1:0> is IGNORED

                         integer esize = 8 << size;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ts>              Is an element size specifier, encoded in the "imm5" field. It can have the following values:

                                         B           when imm5 = xxxx1

                                         H           when imm5 = xxx10

                                         S           when imm5 = xx100

                                         D           when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <index1>          Is the destination element index encoded in the "imm5" field. It can have the following values:

                                         imm5<4:1>   when imm5 = xxxx1

                                         imm5<4:2>   when imm5 = xxx10

                                         imm5<4:3>   when imm5 = xx100

                                         imm5<4>     when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <index2>          Is the source element index encoded in the "imm5:imm4" field. It can have the following values:

                                         imm4<3:0>   when imm5 = xxxx1

                                         imm4<3:1>   when imm5 = xxx10

                                         imm4<3:2>   when imm5 = xx100

                                         imm4<3>     when imm5 = x1000



C7-1058                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when imm5 = x0000.

                              Unspecified bits in "imm4" are ignored but should be set to zero by an assembler.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(idxdsize) operand = V[n];
                 bits(128) result;

                 result = V[d];
                 Elem[result, dst_index, esize] = Elem[operand, src_index, esize];
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1059
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.151       INS (general)

                       Insert vector element from general-purpose register

                       This instruction is used by the alias MOV (from general). The alias is always the preferred disassembly.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9             5 4             0
                            0 1 0 0 1 1 1 0 0 0 0                    imm5       0 0 0 1 1 1              Rn              Rd




                       Advanced SIMD variant

                       INS <Vd>.<Ts>[<index>], <R><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer size = LowestSetBit(imm5);

                         if size > 3 then UnallocatedEncoding();
                         integer index = UInt(imm5<4:size+1>);

                         integer esize = 8 << size;
                         integer datasize = 128;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ts>              Is an element size specifier, encoded in the "imm5" field. It can have the following values:

                                         B           when imm5 = xxxx1

                                         H           when imm5 = xxx10

                                         S           when imm5 = xx100

                                         D           when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <index>           Is the element index encoded in the "imm5" field. It can have the following values:

                                         imm5<4:1>   when imm5 = xxxx1

                                         imm5<4:2>   when imm5 = xxx10

                                         imm5<4:3>   when imm5 = xx100

                                         imm5<4>     when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <R>               Is the width specifier for the general-purpose source register, encoded in the "imm5" field. It can
                                         have the following values:

                                         W           when imm5 = xxxx1

                                         W           when imm5 = xxx10

                                         W           when imm5 = xx100

                                         X           when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <n>               Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the "Rn" field.


C7-1060                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(esize) element = X[n];
                 bits(datasize) result;

                 result = V[d];
                 Elem[result, index, esize] = element;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                             C7-1061
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.152       LD1 (multiple structures)

                       Load multiple 1-element structures to one, two, three or four registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15         12 11 10 9       5 4     0
                            0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 x x 1 x size                            Rn     Rt
                                                       L                      opcode


                       One register variant

                       Applies when opcode = 0111.

                       LD1 { <Vt>.<T> }, [<Xn|SP>]


                       Two registers variant

                       Applies when opcode = 1010.

                       LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]


                       Three registers variant

                       Applies when opcode = 0110.

                       LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]


                       Four registers variant

                       Applies when opcode = 0010.

                       LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20          16 15         12 11 10 9       5 4     0
                            0 Q 0 0 1 1 0 0 1 1 0                 Rm         x x 1 x size           Rn     Rt
                                                       L                      opcode


                       One register, immediate offset variant

                       Applies when Rm = 11111 && opcode = 0111.

                       LD1 { <Vt>.<T> }, [<Xn|SP>], <imm>


                       One register, register offset variant

                       Applies when Rm != 11111 && opcode = 0111.

                       LD1 { <Vt>.<T> }, [<Xn|SP>], <Xm>


                       Two registers, immediate offset variant

                       Applies when Rm = 11111 && opcode = 1010.



C7-1062                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>


                Two registers, register offset variant

                Applies when Rm != 11111 && opcode = 1010.

                LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>


                Three registers, immediate offset variant

                Applies when Rm = 11111 && opcode = 0110.

                LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>


                Three registers, register offset variant

                Applies when Rm != 11111 && opcode = 0110.

                LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>


                Four registers, immediate offset variant

                Applies when Rm = 11111 && opcode = 0010.

                LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>


                Four registers, register offset variant

                Applies when Rm != 11111 && opcode = 0010.

                LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>          Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              1D          when size = 11, Q = 0

                              2D          when size = 11, Q = 1

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Vt3>         Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                <Vt4>         Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1063
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <imm>             For the one register, immediate offset variant: is the post-index immediate offset, encoded in the "Q"
                                         field. It can have the following values:

                                         #8           when Q = 0

                                         #16          when Q = 1

                                         For the two registers, immediate offset variant: is the post-index immediate offset, encoded in the
                                         "Q" field. It can have the following values:

                                         #16          when Q = 0

                                         #32          when Q = 1

                                         For the three registers, immediate offset variant: is the post-index immediate offset, encoded in the
                                         "Q" field. It can have the following values:

                                         #24          when Q = 0

                                         #48          when Q = 1

                                         For the four registers, immediate offset variant: is the post-index immediate offset, encoded in the
                                         "Q" field. It can have the following values:

                                         #32          when Q = 0

                                         #64          when Q = 1

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << UInt(size);
                         integer elements = datasize DIV esize;

                         integer rpt;       // number of iterations
                         integer selem;     // structure elements

                         case opcode of
                              when '0000' rpt = 1; selem = 4;          // LD/ST4 (4 registers)
                              when '0010' rpt = 4; selem = 1;          // LD/ST1 (4 registers)
                              when '0100' rpt = 1; selem = 3;          // LD/ST3 (3 registers)
                              when '0110' rpt = 3; selem = 1;          // LD/ST1 (3 registers)
                              when '0111' rpt = 1; selem = 1;          // LD/ST1 (1 register)
                              when '1000' rpt = 1; selem = 2;          // LD/ST2 (2 registers)
                              when '1010' rpt = 2; selem = 1;          // LD/ST1 (2 registers)
                              otherwise UnallocatedEncoding();

                         // .1D format only permitted with LD1 & ST1
                         if size:Q == '110' && selem != 1 then ReservedValue();


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(datasize) rval;
                         integer e, r, s, tt;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];




C7-1064                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 offs = Zeros();
                 for r = 0 to rpt-1
                     for e = 0 to elements-1
                         tt = (t + r) MOD 32;
                         for s = 0 to selem-1
                             rval = V[tt];
                             if memop == MemOp_LOAD then
                                 Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                 V[tt] = rval;
                             else // memop == MemOp_STORE
                                 Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                             offs = offs + ebytes;
                             tt = (tt + 1) MOD 32;

                 if wback then
                     if m != 31 then
                         offs = X[m];
                     if n == 31 then
                         SP[] = address + offs;
                     else
                         X[n] = address + offs;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1065
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.153       LD1 (single structure)

                       Load single 1-element structure to one lane of one register


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15      13 12 11 10 9       5 4     0
                            0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 x x 0 S size                            Rn     Rt
                                                       L R                   opcode


                       8-bit variant

                       Applies when opcode = 000.

                       LD1 { <Vt>.B }[<index>], [<Xn|SP>]


                       16-bit variant

                       Applies when opcode = 010 && size = x0.

                       LD1 { <Vt>.H }[<index>], [<Xn|SP>]


                       32-bit variant

                       Applies when opcode = 100 && size = 00.

                       LD1 { <Vt>.S }[<index>], [<Xn|SP>]


                       64-bit variant

                       Applies when opcode = 100 && S = 0 && size = 01.

                       LD1 { <Vt>.D }[<index>], [<Xn|SP>]


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20          16 15      13 12 11 10 9       5 4     0
                            0 Q 0 0 1 1 0 1 1 1 0                 Rm         x x 0 S size           Rn     Rt
                                                       L R                   opcode


                       8-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 000.

                       LD1 { <Vt>.B }[<index>], [<Xn|SP>], #1


                       8-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 000.

                       LD1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>


                       16-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 010 && size = x0.



C7-1066                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                LD1 { <Vt>.H }[<index>], [<Xn|SP>], #2


                16-bit, register offset variant

                Applies when Rm != 11111 && opcode = 010 && size = x0.

                LD1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>


                32-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 100 && size = 00.

                LD1 { <Vt>.S }[<index>], [<Xn|SP>], #4


                32-bit, register offset variant

                Applies when Rm != 11111 && opcode = 100 && size = 00.

                LD1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>


                64-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 100 && S = 0 && size = 01.

                LD1 { <Vt>.D }[<index>], [<Xn|SP>], #8


                64-bit, register offset variant

                Applies when Rm != 11111 && opcode = 100 && S = 0 && size = 01.

                LD1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>          Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <index>       For the 8-bit variant: is the element index, encoded in "Q:S:size".

                              For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                              For the 32-bit variant: is the element index, encoded in "Q:S".

                              For the 64-bit variant: is the element index, encoded in "Q".

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 integer scale = UInt(opcode<2:1>);
                 integer selem = UInt(opcode<0>:R) + 1;
                 boolean replicate = FALSE;
                 integer index;

                 case scale of
                    when 3
                         // load and replicate
                         if L == '0' || S == '1' then UnallocatedEncoding();
                         scale = UInt(size);



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1067
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   replicate = TRUE;
                              when 0
                                   index = UInt(Q:S:size);          // B[0-15]
                              when 1
                                   if size<0> == '1' then UnallocatedEncoding();
                                   index = UInt(Q:S:size<1>);       // H[0-7]
                              when 2
                                   if size<1> == '1' then UnallocatedEncoding();
                                   if size<0> == '0' then
                                       index = UInt(Q:S);           // S[0-3]
                                   else
                                       if S == '1' then UnallocatedEncoding();
                                       index = UInt(Q);             // D[0-1]
                                       scale = 3;

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(128) rval;
                         bits(esize) element;
                         integer s;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         offs = Zeros();
                         if replicate then
                              // load and replicate to all elements
                              for s = 0 to selem-1
                                   element = Mem[address + offs, ebytes, AccType_VEC];
                                   // replicate to fill 128- or 64-bit register
                                   V[t] = Replicate(element, datasize DIV esize);
                                   offs = offs + ebytes;
                                   t = (t + 1) MOD 32;
                         else
                              // load/store one element per register
                              for s = 0 to selem-1
                                   rval = V[t];
                                   if memop == MemOp_LOAD then
                                       // insert into one lane of 128-bit register
                                       Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                       V[t] = rval;
                                   else // memop == MemOp_STORE
                                       // extract from one lane of 128-bit register
                                       Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                                   offs = offs + ebytes;
                                   t = (t + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1068                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.154    LD1R

                Load single 1-element structure and replicate to all lanes (of one register)


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15        13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 size                                   Rn             Rt
                                              L R                      opcode S


                No offset variant

                LD1R { <Vt>.<T> }, [<Xn|SP>]


                Decode for this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15     13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 1 1 0                    Rm         1 1 0 0 size               Rn             Rt
                                              L R                      opcode S


                Immediate offset variant

                Applies when Rm = 11111.

                LD1R { <Vt>.<T> }, [<Xn|SP>], <imm>


                Register offset variant

                Applies when Rm != 11111.

                LD1R { <Vt>.<T> }, [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>           Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1069
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         1D           when size = 11, Q = 0

                                         2D           when size = 11, Q = 1

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

                                         #1           when size = 00

                                         #2           when size = 01

                                         #4           when size = 10

                                         #8           when size = 11

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate
                                   if L == '0' || S == '1' then UnallocatedEncoding();
                                   scale = UInt(size);
                                   replicate = TRUE;
                              when 0
                                   index = UInt(Q:S:size);            // B[0-15]
                              when 1
                                   if size<0> == '1' then UnallocatedEncoding();
                                   index = UInt(Q:S:size<1>);         // H[0-7]
                              when 2
                                   if size<1> == '1' then UnallocatedEncoding();
                                   if size<0> == '0' then
                                       index = UInt(Q:S);             // S[0-3]
                                   else
                                       if S == '1' then UnallocatedEncoding();
                                       index = UInt(Q);               // D[0-1]
                                       scale = 3;

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(128) rval;
                         bits(esize) element;
                         integer s;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         offs = Zeros();




C7-1070                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                        element = Mem[address + offs, ebytes, AccType_VEC];
                        // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                        rval = V[t];
                        if memop == MemOp_LOAD then
                            // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                        else // memop == MemOp_STORE
                            // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                        offs = X[m];
                    if n == 31 then
                         SP[] = address + offs;
                    else
                         X[n] = address + offs;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1071
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.155       LD2 (multiple structures)

                       Load multiple 2-element structures to two registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15           12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 size                                 Rn              Rt
                                                        L                       opcode


                       No offset variant

                       LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]


                       Decode for this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15       12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 1 1 0                    Rm        1 0 0 0 size              Rn              Rt
                                                        L                       opcode


                       Immediate offset variant

                       Applies when Rm = 11111.

                       LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>


                       Register offset variant

                       Applies when Rm != 11111.

                       LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1



C7-1072                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2D           when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>         Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

                              #16          when Q = 0

                              #32          when Q = 1

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << UInt(size);
                 integer elements = datasize DIV esize;

                 integer rpt;    // number of iterations
                 integer selem;  // structure elements

                 case opcode of
                    when '0000' rpt = 1; selem = 4;        // LD/ST4 (4 registers)
                    when '0010' rpt = 4; selem = 1;        // LD/ST1 (4 registers)
                    when '0100' rpt = 1; selem = 3;        // LD/ST3 (3 registers)
                    when '0110' rpt = 3; selem = 1;        // LD/ST1 (3 registers)
                    when '0111' rpt = 1; selem = 1;        // LD/ST1 (1 register)
                    when '1000' rpt = 1; selem = 2;        // LD/ST2 (2 registers)
                    when '1010' rpt = 2; selem = 1;        // LD/ST1 (2 registers)
                    otherwise UnallocatedEncoding();

                 // .1D format only permitted with LD1 & ST1
                 if size:Q == '110' && selem != 1 then ReservedValue();


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(datasize) rval;
                 integer e, r, s, tt;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 for r = 0 to rpt-1
                     for e = 0 to elements-1
                         tt = (t + r) MOD 32;
                         for s = 0 to selem-1
                             rval = V[tt];
                             if memop == MemOp_LOAD then
                                 Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                 V[tt] = rval;
                             else // memop == MemOp_STORE
                                 Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                             offs = offs + ebytes;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1073
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                       tt = (tt + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1074                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.156    LD2 (single structure)

                Load single 2-element structure to one lane of two registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 x x 0 S size                                Rn             Rt
                                              L R                    opcode


                8-bit variant

                Applies when opcode = 000.

                LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]


                16-bit variant

                Applies when opcode = 010 && size = x0.

                LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]


                32-bit variant

                Applies when opcode = 100 && size = 00.

                LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]


                64-bit variant

                Applies when opcode = 100 && S = 0 && size = 01.

                LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 1 1 1                  Rm         x x 0 S size              Rn             Rt
                                              L R                    opcode


                8-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 000.

                LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2


                8-bit, register offset variant

                Applies when Rm != 11111 && opcode = 000.

                LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>


                16-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 010 && size = x0.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1075
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4


                       16-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 010 && size = x0.

                       LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>


                       32-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 100 && size = 00.

                       LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8


                       32-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 100 && size = 00.

                       LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>


                       64-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 100 && S = 0 && size = 01.

                       LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16


                       64-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 100 && S = 0 && size = 01.

                       LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <index>           For the 8-bit variant: is the element index, encoded in "Q:S:size".

                                         For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                                         For the 32-bit variant: is the element index, encoded in "Q:S".

                                         For the 64-bit variant: is the element index, encoded in "Q".

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate



C7-1076                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         if L == '0' || S == '1' then UnallocatedEncoding();
                         scale = UInt(size);
                         replicate = TRUE;
                    when 0
                         index = UInt(Q:S:size);        // B[0-15]
                    when 1
                         if size<0> == '1' then UnallocatedEncoding();
                         index = UInt(Q:S:size<1>);     // H[0-7]
                    when 2
                         if size<1> == '1' then UnallocatedEncoding();
                         if size<0> == '0' then
                            index = UInt(Q:S);           // S[0-3]
                         else
                            if S == '1' then UnallocatedEncoding();
                            index = UInt(Q);             // D[0-1]
                            scale = 3;

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(128) rval;
                 bits(esize) element;
                 integer s;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                         element = Mem[address + offs, ebytes, AccType_VEC];
                         // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                         rval = V[t];
                         if memop == MemOp_LOAD then
                             // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                         else // memop == MemOp_STORE
                             // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                         offs = X[m];
                    if n == 31 then




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1077
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1078                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.157    LD2R

                Load single 2-element structure and replicate to all lanes of two registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15        13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 1 1 0 0 size                                   Rn             Rt
                                              L R                      opcode S


                No offset variant

                LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]


                Decode for this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15     13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 1 1 1                    Rm         1 1 0 0 size               Rn             Rt
                                              L R                      opcode S


                Immediate offset variant

                Applies when Rm = 11111.

                LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>


                Register offset variant

                Applies when Rm != 11111.

                LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>           Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1079
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         1D           when size = 11, Q = 0

                                         2D           when size = 11, Q = 1

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

                                         #2           when size = 00

                                         #4           when size = 01

                                         #8           when size = 10

                                         #16          when size = 11

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate
                                   if L == '0' || S == '1' then UnallocatedEncoding();
                                   scale = UInt(size);
                                   replicate = TRUE;
                              when 0
                                   index = UInt(Q:S:size);            // B[0-15]
                              when 1
                                   if size<0> == '1' then UnallocatedEncoding();
                                   index = UInt(Q:S:size<1>);         // H[0-7]
                              when 2
                                   if size<1> == '1' then UnallocatedEncoding();
                                   if size<0> == '0' then
                                       index = UInt(Q:S);             // S[0-3]
                                   else
                                       if S == '1' then UnallocatedEncoding();
                                       index = UInt(Q);               // D[0-1]
                                       scale = 3;

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(128) rval;
                         bits(esize) element;
                         integer s;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];




C7-1080                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                        element = Mem[address + offs, ebytes, AccType_VEC];
                        // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                        rval = V[t];
                        if memop == MemOp_LOAD then
                            // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                        else // memop == MemOp_STORE
                            // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                        offs = X[m];
                    if n == 31 then
                         SP[] = address + offs;
                    else
                         X[n] = address + offs;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1081
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.158       LD3 (multiple structures)

                       Load multiple 3-element structures to three registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15           12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 size                                 Rn              Rt
                                                        L                       opcode


                       No offset variant

                       LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]


                       Decode for this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15       12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 1 1 0                    Rm        0 1 0 0 size              Rn              Rt
                                                        L                       opcode


                       Immediate offset variant

                       Applies when Rm = 11111.

                       LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>


                       Register offset variant

                       Applies when Rm != 11111.

                       LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1



C7-1082                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2D           when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Vt3>         Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>         Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

                              #24          when Q = 0

                              #48          when Q = 1

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << UInt(size);
                 integer elements = datasize DIV esize;

                 integer rpt;    // number of iterations
                 integer selem;  // structure elements

                 case opcode of
                    when '0000' rpt = 1; selem = 4;        // LD/ST4 (4 registers)
                    when '0010' rpt = 4; selem = 1;        // LD/ST1 (4 registers)
                    when '0100' rpt = 1; selem = 3;        // LD/ST3 (3 registers)
                    when '0110' rpt = 3; selem = 1;        // LD/ST1 (3 registers)
                    when '0111' rpt = 1; selem = 1;        // LD/ST1 (1 register)
                    when '1000' rpt = 1; selem = 2;        // LD/ST2 (2 registers)
                    when '1010' rpt = 2; selem = 1;        // LD/ST1 (2 registers)
                    otherwise UnallocatedEncoding();

                 // .1D format only permitted with LD1 & ST1
                 if size:Q == '110' && selem != 1 then ReservedValue();


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(datasize) rval;
                 integer e, r, s, tt;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 for r = 0 to rpt-1
                     for e = 0 to elements-1
                         tt = (t + r) MOD 32;
                         for s = 0 to selem-1
                             rval = V[tt];
                             if memop == MemOp_LOAD then
                                 Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                 V[tt] = rval;
                             else // memop == MemOp_STORE



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1083
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                           Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                                       offs = offs + ebytes;
                                       tt = (tt + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1084                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.159    LD3 (single structure)

                Load single 3-element structure to one lane of three registers)


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 x x 1 S size                                Rn             Rt
                                              L R                     opcode


                8-bit variant

                Applies when opcode = 001.

                LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]


                16-bit variant

                Applies when opcode = 011 && size = x0.

                LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]


                32-bit variant

                Applies when opcode = 101 && size = 00.

                LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]


                64-bit variant

                Applies when opcode = 101 && S = 0 && size = 01.

                LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15    13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 1 1 0                  Rm          x x 1 S size             Rn             Rt
                                              L R                     opcode


                8-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 001.

                LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3


                8-bit, register offset variant

                Applies when Rm != 11111 && opcode = 001.

                LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>


                16-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 011 && size = x0.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1085
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6


                       16-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 011 && size = x0.

                       LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>


                       32-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 101 && size = 00.

                       LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12


                       32-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 101 && size = 00.

                       LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>


                       64-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 101 && S = 0 && size = 01.

                       LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24


                       64-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 101 && S = 0 && size = 01.

                       LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <index>           For the 8-bit variant: is the element index, encoded in "Q:S:size".

                                         For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                                         For the 32-bit variant: is the element index, encoded in "Q:S".

                                         For the 64-bit variant: is the element index, encoded in "Q".

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of



C7-1086                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when 3
                         // load and replicate
                         if L == '0' || S == '1' then UnallocatedEncoding();
                         scale = UInt(size);
                         replicate = TRUE;
                    when 0
                         index = UInt(Q:S:size);        // B[0-15]
                    when 1
                         if size<0> == '1' then UnallocatedEncoding();
                         index = UInt(Q:S:size<1>);     // H[0-7]
                    when 2
                         if size<1> == '1' then UnallocatedEncoding();
                         if size<0> == '0' then
                            index = UInt(Q:S);           // S[0-3]
                         else
                            if S == '1' then UnallocatedEncoding();
                            index = UInt(Q);             // D[0-1]
                            scale = 3;

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(128) rval;
                 bits(esize) element;
                 integer s;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                         element = Mem[address + offs, ebytes, AccType_VEC];
                         // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                         rval = V[t];
                         if memop == MemOp_LOAD then
                             // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                         else // memop == MemOp_STORE
                             // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                         offs = X[m];
                    if n == 31 then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1087
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1088                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.160    LD3R

                Load single 3-element structure and replicate to all lanes of three registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15        13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 1 1 1 0 size                                   Rn             Rt
                                              L R                      opcode S


                No offset variant

                LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]


                Decode for this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15     13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 1 1 0                    Rm         1 1 1 0 size               Rn             Rt
                                              L R                      opcode S


                Immediate offset variant

                Applies when Rm = 11111.

                LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>


                Register offset variant

                Applies when Rm != 11111.

                LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>           Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1089
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         1D           when size = 11, Q = 0

                                         2D           when size = 11, Q = 1

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

                                         #3           when size = 00

                                         #6           when size = 01

                                         #12          when size = 10

                                         #24          when size = 11

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate
                                   if L == '0' || S == '1' then UnallocatedEncoding();
                                   scale = UInt(size);
                                   replicate = TRUE;
                              when 0
                                   index = UInt(Q:S:size);            // B[0-15]
                              when 1
                                   if size<0> == '1' then UnallocatedEncoding();
                                   index = UInt(Q:S:size<1>);         // H[0-7]
                              when 2
                                   if size<1> == '1' then UnallocatedEncoding();
                                   if size<0> == '0' then
                                       index = UInt(Q:S);             // S[0-3]
                                   else
                                       if S == '1' then UnallocatedEncoding();
                                       index = UInt(Q);               // D[0-1]
                                       scale = 3;

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(128) rval;
                         bits(esize) element;
                         integer s;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];




C7-1090                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                        element = Mem[address + offs, ebytes, AccType_VEC];
                        // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                        rval = V[t];
                        if memop == MemOp_LOAD then
                            // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                        else // memop == MemOp_STORE
                            // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                        offs = X[m];
                    if n == 31 then
                         SP[] = address + offs;
                    else
                         X[n] = address + offs;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1091
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.161       LD4 (multiple structures)

                       Load multiple 4-element structures to four registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15           12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 size                                 Rn              Rt
                                                        L                       opcode


                       No offset variant

                       LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]


                       Decode for this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15       12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 1 1 0                    Rm        0 0 0 0 size              Rn              Rt
                                                        L                       opcode


                       Immediate offset variant

                       Applies when Rm = 11111.

                       LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>


                       Register offset variant

                       Applies when Rm != 11111.

                       LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1



C7-1092                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2D           when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Vt3>         Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                <Vt4>         Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>         Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

                              #32          when Q = 0

                              #64          when Q = 1

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << UInt(size);
                 integer elements = datasize DIV esize;

                 integer rpt;    // number of iterations
                 integer selem;  // structure elements

                 case opcode of
                    when '0000' rpt = 1; selem = 4;        // LD/ST4 (4 registers)
                    when '0010' rpt = 4; selem = 1;        // LD/ST1 (4 registers)
                    when '0100' rpt = 1; selem = 3;        // LD/ST3 (3 registers)
                    when '0110' rpt = 3; selem = 1;        // LD/ST1 (3 registers)
                    when '0111' rpt = 1; selem = 1;        // LD/ST1 (1 register)
                    when '1000' rpt = 1; selem = 2;        // LD/ST2 (2 registers)
                    when '1010' rpt = 2; selem = 1;        // LD/ST1 (2 registers)
                    otherwise UnallocatedEncoding();

                 // .1D format only permitted with LD1 & ST1
                 if size:Q == '110' && selem != 1 then ReservedValue();


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(datasize) rval;
                 integer e, r, s, tt;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 for r = 0 to rpt-1
                     for e = 0 to elements-1
                         tt = (t + r) MOD 32;
                         for s = 0 to selem-1
                             rval = V[tt];
                             if memop == MemOp_LOAD then
                                 Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1093
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                           V[tt] = rval;
                                       else // memop == MemOp_STORE
                                           Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                                       offs = offs + ebytes;
                                       tt = (tt + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1094                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.162    LD4 (single structure)

                Load single 4-element structure to one lane of four registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15        13 12 11 10 9              5 4          0
                   0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 x x 1 S size                                Rn             Rt
                                              L R                    opcode


                8-bit variant

                Applies when opcode = 001.

                LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]


                16-bit variant

                Applies when opcode = 011 && size = x0.

                LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]


                32-bit variant

                Applies when opcode = 101 && size = 00.

                LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]


                64-bit variant

                Applies when opcode = 101 && S = 0 && size = 01.

                LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15      13 12 11 10 9              5 4          0
                   0 Q 0 0 1 1 0 1 1 1 1                  Rm         x x 1 S size              Rn             Rt
                                              L R                    opcode


                8-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 001.

                LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4


                8-bit, register offset variant

                Applies when Rm != 11111 && opcode = 001.

                LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>


                16-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 011 && size = x0.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1095
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8


                       16-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 011 && size = x0.

                       LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>


                       32-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 101 && size = 00.

                       LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16


                       32-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 101 && size = 00.

                       LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>


                       64-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 101 && S = 0 && size = 01.

                       LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32


                       64-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 101 && S = 0 && size = 01.

                       LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <Vt4>             Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                       <index>           For the 8-bit variant: is the element index, encoded in "Q:S:size".

                                         For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                                         For the 32-bit variant: is the element index, encoded in "Q:S".

                                         For the 64-bit variant: is the element index, encoded in "Q".

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;



C7-1096                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 case scale of
                    when 3
                         // load and replicate
                         if L == '0' || S == '1' then UnallocatedEncoding();
                         scale = UInt(size);
                         replicate = TRUE;
                    when 0
                         index = UInt(Q:S:size);        // B[0-15]
                    when 1
                         if size<0> == '1' then UnallocatedEncoding();
                         index = UInt(Q:S:size<1>);     // H[0-7]
                    when 2
                         if size<1> == '1' then UnallocatedEncoding();
                         if size<0> == '0' then
                            index = UInt(Q:S);           // S[0-3]
                         else
                            if S == '1' then UnallocatedEncoding();
                            index = UInt(Q);             // D[0-1]
                            scale = 3;

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(128) rval;
                 bits(esize) element;
                 integer s;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                         element = Mem[address + offs, ebytes, AccType_VEC];
                         // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                         rval = V[t];
                         if memop == MemOp_LOAD then
                             // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                         else // memop == MemOp_STORE
                             // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1097
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1098                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.163    LD4R

                Load single 4-element structure and replicate to all lanes of four registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15        13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 1 1 1 0 size                                   Rn             Rt
                                              L R                      opcode S


                No offset variant

                LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]


                Decode for this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15     13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 0 1 1 1 1                    Rm         1 1 1 0 size               Rn             Rt
                                              L R                      opcode S


                Immediate offset variant

                Applies when Rm = 11111.

                LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>


                Register offset variant

                Applies when Rm != 11111.

                LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>           Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1099
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         1D           when size = 11, Q = 0

                                         2D           when size = 11, Q = 1

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <Vt4>             Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

                                         #4           when size = 00

                                         #8           when size = 01

                                         #16          when size = 10

                                         #32          when size = 11

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate
                                   if L == '0' || S == '1' then UnallocatedEncoding();
                                   scale = UInt(size);
                                   replicate = TRUE;
                              when 0
                                   index = UInt(Q:S:size);            // B[0-15]
                              when 1
                                   if size<0> == '1' then UnallocatedEncoding();
                                   index = UInt(Q:S:size<1>);         // H[0-7]
                              when 2
                                   if size<1> == '1' then UnallocatedEncoding();
                                   if size<0> == '0' then
                                       index = UInt(Q:S);             // S[0-3]
                                   else
                                       if S == '1' then UnallocatedEncoding();
                                       index = UInt(Q);               // D[0-1]
                                       scale = 3;

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(128) rval;
                         bits(esize) element;
                         integer s;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();


C7-1100                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                        element = Mem[address + offs, ebytes, AccType_VEC];
                        // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                        rval = V[t];
                        if memop == MemOp_LOAD then
                            // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                        else // memop == MemOp_STORE
                            // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                        offs = offs + ebytes;
                        t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                        offs = X[m];
                    if n == 31 then
                         SP[] = address + offs;
                    else
                         X[n] = address + offs;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1101
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.164       LDNP (SIMD&FP)

                       Load pair of SIMD&FP registers, with non-temporal hint




                           31 30 29 28 27 26 25 24 23 22 21                      15 14         10 9              5 4               0
                            opc 1 0 1 1 0 0 0 1                      imm7                Rt2             Rn               Rt
                                                         L


                       32-bit variant

                       Applies when opc = 00.

                       LDNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]


                       64-bit variant

                       Applies when opc = 01.

                       LDNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]


                       128-bit variant

                       Applies when opc = 10.

                       LDNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]


                       Decode for all variants of this encoding

                         boolean wback     = FALSE;
                         boolean postindex = FALSE;


                       Assembler symbols

                       <Dt1>             Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Dt2>             Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                       <Qt1>             Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Qt2>             Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                       <St1>             Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <St2>             Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
                                         to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                                         For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
                                         to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

                                         For the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range
                                         -1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2);
                         AccType acctype = AccType_VECSTREAM;



C7-1102                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 if opc == '11' then UnallocatedEncoding();
                 integer scale = 2 + UInt(opc);
                 integer datasize = 8 << scale;
                 bits(64) offset = LSL(SignExtend(imm7, 64), scale);


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(datasize) data1;
                 bits(datasize) data2;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        data1 = V[t];
                        data2 = V[t2];
                         Mem[address + 0     , dbytes, acctype] = data1;
                         Mem[address + dbytes, dbytes, acctype] = data2;

                    when MemOp_LOAD
                        data1 = Mem[address + 0      , dbytes, acctype];
                        data2 = Mem[address + dbytes, dbytes, acctype];
                        if rt_unknown then
                            data1 = bits(datasize) UNKNOWN;
                            data2 = bits(datasize) UNKNOWN;
                         V[t]  = data1;
                         V[t2] = data2;

                 if wback then
                    if postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1103
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.165       LDP (SIMD&FP)

                       Load pair of SIMD&FP registers


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21                 15 14            10 9      5 4     0
                            opc 1 0 1 1 0 0 1 1                  imm7                 Rt2           Rn     Rt
                                                       L


                       32-bit variant

                       Applies when opc = 00.

                       LDP <St1>, <St2>, [<Xn|SP>], #<imm>


                       64-bit variant

                       Applies when opc = 01.

                       LDP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>


                       128-bit variant

                       Applies when opc = 10.

                       LDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>


                       Decode for all variants of this encoding

                         boolean wback     = TRUE;
                         boolean postindex = TRUE;


                       Pre-index


                           31 30 29 28 27 26 25 24 23 22 21                 15 14            10 9      5 4     0
                            opc 1 0 1 1 0 1 1 1                  imm7                 Rt2           Rn     Rt
                                                       L


                       32-bit variant

                       Applies when opc = 00.

                       LDP <St1>, <St2>, [<Xn|SP>, #<imm>]!


                       64-bit variant

                       Applies when opc = 01.

                       LDP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!


                       128-bit variant

                       Applies when opc = 10.

                       LDP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!


                       Decode for all variants of this encoding

                         boolean wback     = TRUE;
                         boolean postindex = FALSE;




C7-1104                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Signed offset


                  31 30 29 28 27 26 25 24 23 22 21                   15 14            10 9             5 4           0
                  opc 1 0 1 1 0 1 0 1                   imm7                   Rt2             Rn             Rt
                                              L


                32-bit variant

                Applies when opc = 00.

                LDP <St1>, <St2>, [<Xn|SP>{, #<imm>}]


                64-bit variant

                Applies when opc = 01.

                LDP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]


                128-bit variant

                Applies when opc = 10.

                LDP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]


                Decode for all variants of this encoding

                 boolean wback  = FALSE;
                 boolean postindex = FALSE;


                Assembler symbols

                <Dt1>         Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Dt2>         Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                <Qt1>         Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Qt2>         Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                <St1>         Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                <St2>         Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>         For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
                              multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.

                              For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
                              the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                              For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
                              multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.

                              For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
                              the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

                              For the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a
                              multiple of 16 in the range -1024 to 1008, encoded in the "imm7" field as <imm>/16.

                              For the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16
                              in the range -1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1105
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer t2 = UInt(Rt2);
                         AccType acctype = AccType_VEC;
                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         if opc == '11' then UnallocatedEncoding();
                         integer scale = 2 + UInt(opc);
                         integer datasize = 8 << scale;
                         bits(64) offset = LSL(SignExtend(imm7, 64), scale);


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(datasize) data1;
                         bits(datasize) data2;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   data1 = V[t];
                                   data2 = V[t2];
                                   Mem[address + 0      , dbytes, acctype] = data1;
                                   Mem[address + dbytes, dbytes, acctype] = data2;

                              when MemOp_LOAD
                                   data1 = Mem[address + 0      , dbytes, acctype];
                                   data2 = Mem[address + dbytes, dbytes, acctype];
                                   if rt_unknown then
                                       data1 = bits(datasize) UNKNOWN;
                                       data2 = bits(datasize) UNKNOWN;
                                   V[t]   = data1;
                                   V[t2] = data2;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C7-1106                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.            ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                   ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.166    LDR (immediate, SIMD&FP)

                Load SIMD&FP register (immediate offset)


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20                      12 11 10 9               5 4          0
                  size 1 1 1 1 0 0 x 1 0                   imm9                 0 1         Rn             Rt
                                          opc


                8-bit variant

                Applies when size = 00 && opc = 01.

                LDR <Bt>, [<Xn|SP>], #<simm>


                16-bit variant

                Applies when size = 01 && opc = 01.

                LDR <Ht>, [<Xn|SP>], #<simm>


                32-bit variant

                Applies when size = 10 && opc = 01.

                LDR <St>, [<Xn|SP>], #<simm>


                64-bit variant

                Applies when size = 11 && opc = 01.

                LDR <Dt>, [<Xn|SP>], #<simm>


                128-bit variant

                Applies when size = 00 && opc = 11.

                LDR <Qt>, [<Xn|SP>], #<simm>


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = TRUE;
                 integer scale = UInt(opc<1>:size);
                 if scale > 4 then UnallocatedEncoding();
                 bits(64) offset = SignExtend(imm9, 64);


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21 20                      12 11 10 9               5 4          0
                  size 1 1 1 1 0 0 x 1 0                   imm9                 1 1         Rn             Rt
                                          opc


                8-bit variant

                Applies when size = 00 && opc = 01.

                LDR <Bt>, [<Xn|SP>, #<simm>]!




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1107
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       16-bit variant

                       Applies when size = 01 && opc = 01.

                       LDR <Ht>, [<Xn|SP>, #<simm>]!


                       32-bit variant

                       Applies when size = 10 && opc = 01.

                       LDR <St>, [<Xn|SP>, #<simm>]!


                       64-bit variant

                       Applies when size = 11 && opc = 01.

                       LDR <Dt>, [<Xn|SP>, #<simm>]!


                       128-bit variant

                       Applies when size = 00 && opc = 11.

                       LDR <Qt>, [<Xn|SP>, #<simm>]!


                       Decode for all variants of this encoding

                         boolean wback = TRUE;
                         boolean postindex = FALSE;
                         integer scale = UInt(opc<1>:size);
                         if scale > 4 then UnallocatedEncoding();
                         bits(64) offset = SignExtend(imm9, 64);


                       Unsigned offset


                           31 30 29 28 27 26 25 24 23 22 21                                  10 9      5 4     0
                            size 1 1 1 1 0 1 x 1                       imm12                        Rn     Rt
                                                     opc


                       8-bit variant

                       Applies when size = 00 && opc = 01.

                       LDR <Bt>, [<Xn|SP>{, #<pimm>}]


                       16-bit variant

                       Applies when size = 01 && opc = 01.

                       LDR <Ht>, [<Xn|SP>{, #<pimm>}]


                       32-bit variant

                       Applies when size = 10 && opc = 01.

                       LDR <St>, [<Xn|SP>{, #<pimm>}]


                       64-bit variant

                       Applies when size = 11 && opc = 01.

                       LDR <Dt>, [<Xn|SP>{, #<pimm>}]


                       128-bit variant

                       Applies when size = 00 && opc = 11.



C7-1108                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                LDR <Qt>, [<Xn|SP>{, #<pimm>}]


                Decode for all variants of this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(opc<1>:size);
                 if scale > 4 then UnallocatedEncoding();
                 bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                Assembler symbols

                <Bt>          Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Dt>          Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Ht>          Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Qt>          Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <St>          Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>        Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                <pimm>        For the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting
                              to 0 and encoded in the "imm12" field.

                              For the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0
                              to 8190, defaulting to 0 and encoded in the "imm12" field as <pimm>/2.

                              For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
                              to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.

                              For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
                              to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.

                              For the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range
                              0 to 65520, defaulting to 0 and encoded in the "imm12" field as <pimm>/16.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_VEC;
                 MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(datasize) data;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-1109
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   data = V[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   V[t] = data;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C7-1110                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.167    LDR (literal, SIMD&FP)

                Load SIMD&FP register (PC-relative literal)




                  31 30 29 28 27 26 25 24 23                                                            5 4          0
                    opc 0 1 1 1 0 0                                   imm19                                    Rt




                32-bit variant

                Applies when opc = 00.

                LDR <St>, <label>


                64-bit variant

                Applies when opc = 01.

                LDR <Dt>, <label>


                128-bit variant

                Applies when opc = 10.

                LDR <Qt>, <label>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer size;
                 bits(64) offset;

                 case opc of
                     when '00'
                          size = 4;
                     when '01'
                          size = 8;
                     when '10'
                          size = 16;
                     when '11'
                          UnallocatedEncoding();

                 offset = SignExtend(imm19:'00', 64);


                Assembler symbols

                <Dt>           Is the 64-bit name of the SIMD&FP register to be loaded, encoded in the "Rt" field.

                <Qt>           Is the 128-bit name of the SIMD&FP register to be loaded, encoded in the "Rt" field.

                <St>           Is the 32-bit name of the SIMD&FP register to be loaded, encoded in the "Rt" field.

                <label>        Is the program label from which the data is to be loaded. Its offset from the address of this
                               instruction, in the range +/-1MB, is encoded as "imm19" times 4.


                Operation

                 bits(64) address = PC[] + offset;
                 bits(size*8) data;

                 CheckFPAdvSIMDEnabled64();



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1111
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                         data = Mem[address, size, AccType_VEC];
                         V[t] = data;




C7-1112                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.168    LDR (register, SIMD&FP)

                Load SIMD&FP register (register offset)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15    13 12 11 10 9                5 4           0
                  size 1 1 1 1 0 0 x 1 1                 Rm         option  S 1 0             Rn             Rt
                                           opc


                8-bit variant

                Applies when size = 00 && opc = 01.

                LDR <Bt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                16-bit variant

                Applies when size = 01 && opc = 01.

                LDR <Ht>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                32-bit variant

                Applies when size = 10 && opc = 01.

                LDR <St>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                64-bit variant

                Applies when size = 11 && opc = 01.

                LDR <Dt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                128-bit variant

                Applies when size = 00 && opc = 11.

                LDR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                Decode for all variants of this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(opc<1>:size);
                 if scale > 4 then UnallocatedEncoding();
                 if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                 ExtendType extend_type = DecodeRegExtend(option);
                 integer shift = if S == '1' then scale else 0;


                Assembler symbols

                <Bt>          Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Dt>          Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Ht>          Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Qt>          Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <St>          Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1113
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <R>               Is the index width specifier, encoded in the "option" field. It can have the following values:

                                         W           when option = x10

                                         X           when option = x11

                                         It is RESERVED when:

                                         ·      option = 00x.

                                         ·      option = 10x.

                       <m>               Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                                         field.

                       <extend>          Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                                         the following values:

                                         UXTW        when option = 010

                                         LSL         when option = 011

                                         SXTW        when option = 110

                                         SXTX        when option = 111

                                         It is RESERVED when:

                                         ·      option = 00x.

                                         ·      option = 10x.

                       <amount>          For the 8-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                                         LSL, encoded in the "S" field. It can have the following values:

                                         [absent]    when S = 0

                                         #0          when S = 1

                                         For the 16-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                                         LSL, encoded in the "S" field. It can have the following values:

                                         #0          when S = 0

                                         #1          when S = 1

                                         For the 32-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                                         LSL, encoded in the "S" field. It can have the following values:

                                         #0          when S = 0

                                         #2          when S = 1

                                         For the 64-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                                         LSL, encoded in the "S" field. It can have the following values:

                                         #0          when S = 0

                                         #3          when S = 1

                                         For the 128-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is
                                         not LSL, encoded in the "S" field. It can have the following values:

                                         #0          when S = 0

                                         #4          when S = 1


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         integer m = UInt(Rm);
                         AccType acctype = AccType_VEC;
                         MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = 8 << scale;




C7-1114                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 bits(64) offset = ExtendReg(m, extend_type, shift);
                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(datasize) data;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        data = V[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                         V[t] = data;

                 if wback then
                    if postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1115
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.169       LDUR (SIMD&FP)

                       Load SIMD&FP register (unscaled offset)




                           31 30 29 28 27 26 25 24 23 22 21 20                          12 11 10 9             5 4              0
                            size 1 1 1 1 0 0 x 1 0                       imm9               0 0         Rn               Rt
                                                      opc


                       8-bit variant

                       Applies when size = 00 && opc = 01.

                       LDUR <Bt>, [<Xn|SP>{, #<simm>}]


                       16-bit variant

                       Applies when size = 01 && opc = 01.

                       LDUR <Ht>, [<Xn|SP>{, #<simm>}]


                       32-bit variant

                       Applies when size = 10 && opc = 01.

                       LDUR <St>, [<Xn|SP>{, #<simm>}]


                       64-bit variant

                       Applies when size = 11 && opc = 01.

                       LDUR <Dt>, [<Xn|SP>{, #<simm>}]


                       128-bit variant

                       Applies when size = 00 && opc = 11.

                       LDUR <Qt>, [<Xn|SP>{, #<simm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(opc<1>:size);
                         if scale > 4 then UnallocatedEncoding();
                         bits(64) offset = SignExtend(imm9, 64);


                       Assembler symbols

                       <Bt>              Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Dt>              Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Ht>              Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Qt>              Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <St>              Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>            Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                                         in the "imm9" field.



C7-1116                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 AccType acctype = AccType_VEC;
                 MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = 8 << scale;


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(datasize) data;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        data = V[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                         V[t] = data;

                 if wback then
                    if postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1117
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.170       MLA (by element)

                       Multiply-add to accumulator (vector, by element)




                           31 30 29 28 27 26 25 24 23 22 21 20 19         16 15 14 13 12 11 10 9               5 4             0
                            0 Q 1 0 1 1 1 1 size L M                  Rm       0 0 0 0 H 0               Rn              Rd
                                                                                 o2


                       Vector variant

                       MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);       Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o2 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.


C7-1118                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Ts>          Is an element size specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) operand3 = V[d];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 bits(esize) product;

                 element2 = UInt(Elem[operand2, index, esize]);
                 for e = 0 to elements-1
                     element1 = UInt(Elem[operand1, e, esize]);
                     product = (element1 * element2)<esize-1:0>;
                     if sub_op then
                         Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                     else
                         Elem[result, e, esize] = Elem[operand3, e, esize] + product;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1119
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.171       MLA (vector)

                       Multiply-add to accumulator (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         1 0 0 1 0 1               Rn              Rd
                                  U


                       Three registers of the same type variant

                       MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean sub_op = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) operand3 = V[d];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         bits(esize) product;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              product = (UInt(element1) * UInt(element2))<esize-1:0>;
                              if sub_op then



C7-1120                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                    else
                         Elem[result, e, esize] = Elem[operand3, e, esize] + product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1121
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.172       MLS (by element)

                       Multiply-subtract from accumulator (vector, by element)




                           31 30 29 28 27 26 25 24 23 22 21 20 19         16 15 14 13 12 11 10 9               5 4             0
                            0 Q 1 0 1 1 1 1 size L M                  Rm       0 1 0 0 H 0               Rn              Rd
                                                                                 o2


                       Vector variant

                       MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);       Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o2 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.


C7-1122                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Ts>          Is an element size specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) operand3 = V[d];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 bits(esize) product;

                 element2 = UInt(Elem[operand2, index, esize]);
                 for e = 0 to elements-1
                     element1 = UInt(Elem[operand1, e, esize]);
                     product = (element1 * element2)<esize-1:0>;
                     if sub_op then
                         Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                     else
                         Elem[result, e, esize] = Elem[operand3, e, esize] + product;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1123
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.173       MLS (vector)

                       Multiply-subtract from accumulator (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 1 0 1 1 1 0 size 1                  Rm         1 0 0 1 0 1               Rn              Rd
                                  U


                       Three registers of the same type variant

                       MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean sub_op = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) operand3 = V[d];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         bits(esize) product;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              product = (UInt(element1) * UInt(element2))<esize-1:0>;
                              if sub_op then



C7-1124                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         Elem[result, e, esize] = Elem[operand3, e, esize] - product;
                    else
                         Elem[result, e, esize] = Elem[operand3, e, esize] + product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1125
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.174       MOV (scalar)

                       Move vector element to scalar

                       This instruction is an alias of the DUP (element) instruction. This means that:

                       ·        The encodings in this description are named to match the encodings of DUP (element).

                       ·        The description of DUP (element) gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9              5 4            0
                            0 1 0 1 1 1 1 0 0 0 0                  imm5         0 0 0 0 0 1             Rn              Rd




                       Scalar variant

                       MOV <V><d>, <Vn>.<T>[<index>]

                       is equivalent to

                       DUP    <V><d>, <Vn>.<T>[<index>]

                       and is always the preferred disassembly.


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "imm5" field. It can have the following values:

                                         B           when imm5 = xxxx1

                                         H           when imm5 = xxx10

                                         S           when imm5 = xx100

                                         D           when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is the element width specifier, encoded in the "imm5" field. It can have the following values:

                                         B           when imm5 = xxxx1

                                         H           when imm5 = xxx10

                                         S           when imm5 = xx100

                                         D           when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.

                       <index>           Is the element index encoded in the "imm5" field. It can have the following values:

                                         imm5<4:1>   when imm5 = xxxx1

                                         imm5<4:2>   when imm5 = xxx10

                                         imm5<4:3>   when imm5 = xx100

                                         imm5<4>     when imm5 = x1000

                                         It is RESERVED when imm5 = x0000.


                       Operation

                       The description of DUP (element) gives the operational pseudocode for this instruction.


C7-1126                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.175    MOV (element)

                Move vector element to another vector element

                This instruction is an alias of the INS (element) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of INS (element).

                ·      The description of INS (element) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14         11 10 9              5 4          0
                   0 1 1 0 1 1 1 0 0 0 0                    imm5        0    imm4       1        Rn             Rd




                Advanced SIMD variant

                MOV <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]

                is equivalent to

                INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]

                and is always the preferred disassembly.


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ts>            Is an element size specifier, encoded in the "imm5" field. It can have the following values:

                                B            when imm5 = xxxx1

                                H            when imm5 = xxx10

                                S            when imm5 = xx100

                                D            when imm5 = x1000

                                It is RESERVED when imm5 = x0000.

                <index1>        Is the destination element index encoded in the "imm5" field. It can have the following values:

                                imm5<4:1>    when imm5 = xxxx1

                                imm5<4:2>    when imm5 = xxx10

                                imm5<4:3>    when imm5 = xx100

                                imm5<4>      when imm5 = x1000

                                It is RESERVED when imm5 = x0000.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <index2>        Is the source element index encoded in the "imm5:imm4" field. It can have the following values:

                                imm4<3:0>    when imm5 = xxxx1

                                imm4<3:1>    when imm5 = xxx10

                                imm4<3:2>    when imm5 = xx100

                                imm4<3>      when imm5 = x1000

                                It is RESERVED when imm5 = x0000.

                                Unspecified bits in "imm4" are ignored but should be set to zero by an assembler.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1127
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                       The description of INS (element) gives the operational pseudocode for this instruction.




C7-1128                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.              ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                     ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                               C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.176    MOV (from general)

                Move general-purpose register to a vector element

                This instruction is an alias of the INS (general) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of INS (general).

                ·      The description of INS (general) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                 5 4          0
                   0 1 0 0 1 1 1 0 0 0 0                    imm5        0 0 0 1 1 1               Rn             Rd




                Advanced SIMD variant

                MOV <Vd>.<Ts>[<index>], <R><n>

                is equivalent to

                INS  <Vd>.<Ts>[<index>], <R><n>

                and is always the preferred disassembly.


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ts>            Is an element size specifier, encoded in the "imm5" field. It can have the following values:

                                B            when imm5 = xxxx1

                                H            when imm5 = xxx10

                                S            when imm5 = xx100

                                D            when imm5 = x1000

                                It is RESERVED when imm5 = x0000.

                <index>         Is the element index encoded in the "imm5" field. It can have the following values:

                                imm5<4:1>    when imm5 = xxxx1

                                imm5<4:2>    when imm5 = xxx10

                                imm5<4:3>    when imm5 = xx100

                                imm5<4>      when imm5 = x1000

                                It is RESERVED when imm5 = x0000.

                <R>             Is the width specifier for the general-purpose source register, encoded in the "imm5" field. It can
                                have the following values:

                                W            when imm5 = xxxx1

                                W            when imm5 = xxx10

                                W            when imm5 = xx100

                                X            when imm5 = x1000

                                It is RESERVED when imm5 = x0000.

                <n>             Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the "Rn" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1129
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                       The description of INS (general) gives the operational pseudocode for this instruction.




C7-1130                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                      ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.177    MOV (vector)

                Move vector

                This instruction is an alias of the ORR (vector, register) instruction. This means that:

                ·      The encodings in this description are named to match the encodings of ORR (vector, register).

                ·      The description of ORR (vector, register) gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 1 0 1 0 1                   Rm          0 0 0 1 1 1              Rn             Rd
                                              size


                Three registers of the same type variant

                MOV <Vd>.<T>, <Vn>.<T>

                is equivalent to

                ORR  <Vd>.<T>, <Vn>.<T>, <Vn>.<T>

                and is the preferred disassembly when Rm == Rn.


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                8B           when Q = 0

                                16B          when Q = 1

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.


                Operation

                The description of ORR (vector, register) gives the operational pseudocode for this instruction.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1131
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.178       MOV (to general)

                       Move vector element to general-purpose register

                       This instruction is an alias of the UMOV instruction. This means that:

                       ·        The encodings in this description are named to match the encodings of UMOV.

                       ·        The description of UMOV gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9            5 4              0
                            0 Q 0 0 1 1 1 0 0 0 0                    imm5       0 0 1 1 1 1             Rn              Rd




                       32-bit variant

                       Applies when Q = 0.

                       MOV <Wd>, <Vn>.S[<index>]

                       is equivalent to

                       UMOV <Wd>, <Vn>.S[<index>]

                       and is the preferred disassembly when imm5 == 'xx100'.

                       64-bit variant

                       Applies when Q = 1.

                       MOV <Xd>, <Vn>.D[<index>]

                       is equivalent to

                       UMOV <Xd>, <Vn>.D[<index>]

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Wd>              Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>              Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <index>           For the 32-bit variant: is the element index encoded in the "imm5" field. It can have the following
                                         values:

                                         imm5<4:1>   when imm5 = xxxx1

                                         imm5<4:2>   when imm5 = xxx10

                                         imm5<4:3>   when imm5 = xx100

                                         It is RESERVED when imm5 = xx000.

                                         For the 64-bit variant: is the element index encoded in "imm5<4>".


                       Operation

                       The description of UMOV gives the operational pseudocode for this instruction.




C7-1132                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.179    MOVI

                Move immediate (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       12 11 10 9 8 7 6 5 4                   0
                  0 Q op 0 1 1 1 1 0 0 0 0 0 a b c                  cmode       0 1 d e f g h               Rd




                8-bit variant

                Applies when op = 0 && cmode = 1110.

                MOVI <Vd>.<T>, #<imm8>{, LSL #0}


                16-bit shifted immediate variant

                Applies when op = 0 && cmode = 10x0.

                MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}


                32-bit shifted immediate variant

                Applies when op = 0 && cmode = 0xx0.

                MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}


                32-bit shifting ones variant

                Applies when op = 0 && cmode = 110x.

                MOVI <Vd>.<T>, #<imm8>, MSL #<amount>


                64-bit scalar variant

                Applies when Q = 0 && op = 1 && cmode = 1110.

                MOVI <Dd>, #<imm>


                64-bit vector variant

                Applies when Q = 1 && op = 1 && cmode = 1110.

                MOVI <Vd>.2D, #<imm>


                Decode for all variants of this encoding

                 integer rd = UInt(Rd);

                 integer datasize = if Q == '1' then 128 else 64;
                 bits(datasize) imm;
                 bits(64) imm64;

                 ImmediateOp operation;
                 case cmode:op of
                     when '0xx00' operation = ImmediateOp_MOVI;
                     when '0xx01' operation = ImmediateOp_MVNI;
                     when '0xx10' operation = ImmediateOp_ORR;
                     when '0xx11' operation = ImmediateOp_BIC;
                     when '10x00' operation = ImmediateOp_MOVI;
                     when '10x01' operation = ImmediateOp_MVNI;
                     when '10x10' operation = ImmediateOp_ORR;
                     when '10x11' operation = ImmediateOp_BIC;
                     when '110x0' operation = ImmediateOp_MOVI;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1133
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when '110x1' operation = ImmediateOp_MVNI;
                              when '1110x' operation = ImmediateOp_MOVI;
                              when '11110' operation = ImmediateOp_MOVI;
                              when '11111'
                                   // FMOV Dn,#imm is in main FP instruction set
                                   if Q == '0' then UnallocatedEncoding();
                                   operation = ImmediateOp_MOVI;

                         imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
                         imm = Replicate(imm64, datasize DIV 64);


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <imm>             Is a 64-bit immediate 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh',
                                         encoded in "a:b:c:d:e:f:g:h".

                       <T>               For the 8-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the following
                                         values:

                                         8B           when Q = 0

                                         16B          when Q = 1

                                         For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                                         following values:

                                         4H           when Q = 0

                                         8H           when Q = 1

                                         For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                                         following values:

                                         2S           when Q = 0

                                         4S           when Q = 1

                       <imm8>            Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

                       <amount>          For the 16-bit shifted immediate variant: is the shift amount encoded in the "cmode<1>" field. It can
                                         have the following values:

                                         0            when cmode<1> = 0

                                         8            when cmode<1> = 1

                                         defaulting to 0 if LSL is omitted.

                                         For the 32-bit shifted immediate variant: is the shift amount encoded in the "cmode<2:1>" field. It
                                         can have the following values:

                                         0            when cmode<2:1> = 00

                                         8            when cmode<2:1> = 01

                                         16           when cmode<2:1> = 10

                                         24           when cmode<2:1> = 11

                                         defaulting to 0 if LSL is omitted.

                                         For the 32-bit shifting ones variant: is the shift amount encoded in the "cmode<0>" field. It can have
                                         the following values:

                                         8            when cmode<0> = 0

                                         16           when cmode<0> = 1




C7-1134                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand;
                 bits(datasize) result;

                 case operation of
                    when ImmediateOp_MOVI
                         result = imm;
                    when ImmediateOp_MVNI
                         result = NOT(imm);
                    when ImmediateOp_ORR
                         operand = V[rd];
                         result = operand OR imm;
                    when ImmediateOp_BIC
                        operand = V[rd];
                        result = operand AND NOT(imm);

                 V[rd] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                             C7-1135
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.180       MUL (by element)

                       Multiply (vector, by element)




                           31 30 29 28 27 26 25 24 23 22 21 20 19         16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 1 size L M                  Rm       1 0 0 0 H 0               Rn              Rd




                       Vector variant

                       MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);       Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.




C7-1136                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Ts>          Is an element size specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 bits(esize) product;

                 element2 = UInt(Elem[operand2, index, esize]);
                 for e = 0 to elements-1
                     element1 = UInt(Elem[operand1, e, esize]);
                     product = (element1 * element2)<esize-1:0>;
                     Elem[result, e, esize] = product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1137
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.181       MUL (vector)

                       Multiply (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         1 0 0 1 1 1               Rn              Rd
                                  U


                       Three registers of the same type variant

                       MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if U == '1' && size != '00' then ReservedValue();
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean poly = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;
                         bits(esize) product;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if poly then
                                   product = PolynomialMult(element1, element2)<esize-1:0>;



C7-1138                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    else
                        product = (UInt(element1) * UInt(element2))<esize-1:0>;
                     Elem[result, e, esize] = product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                             C7-1139
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.182       MVN

                       Bitwise NOT (vector)

                       This instruction is an alias of the NOT instruction. This means that:

                       ·        The encodings in this description are named to match the encodings of NOT.

                       ·        The description of NOT gives the operational pseudocode for this instruction.




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4            0
                            0 Q 1 0 1 1 1 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0                                 Rn              Rd




                       Vector variant

                       MVN <Vd>.<T>, <Vn>.<T>

                       is equivalent to

                       NOT    <Vd>.<T>, <Vn>.<T>

                       and is always the preferred disassembly.


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                         8B          when Q = 0

                                         16B         when Q = 1

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                       The description of NOT gives the operational pseudocode for this instruction.




C7-1140                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.183    MVNI

                Move inverted immediate (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       12 11 10 9 8 7 6 5 4                   0
                  0 Q 1 0 1 1 1 1 0 0 0 0 0 a b c                    cmode      0 1 d e f g h               Rd
                        op


                16-bit shifted immediate variant

                Applies when cmode = 10x0.

                MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}


                32-bit shifted immediate variant

                Applies when cmode = 0xx0.

                MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}


                32-bit shifting ones variant

                Applies when cmode = 110x.

                MVNI <Vd>.<T>, #<imm8>, MSL #<amount>


                Decode for all variants of this encoding

                 integer rd = UInt(Rd);

                 integer datasize = if Q == '1' then 128 else 64;
                 bits(datasize) imm;
                 bits(64) imm64;

                 ImmediateOp operation;
                 case cmode:op of
                     when '0xx00' operation = ImmediateOp_MOVI;
                     when '0xx01' operation = ImmediateOp_MVNI;
                     when '0xx10' operation = ImmediateOp_ORR;
                     when '0xx11' operation = ImmediateOp_BIC;
                     when '10x00' operation = ImmediateOp_MOVI;
                     when '10x01' operation = ImmediateOp_MVNI;
                     when '10x10' operation = ImmediateOp_ORR;
                     when '10x11' operation = ImmediateOp_BIC;
                     when '110x0' operation = ImmediateOp_MOVI;
                     when '110x1' operation = ImmediateOp_MVNI;
                     when '1110x' operation = ImmediateOp_MOVI;
                     when '11110' operation = ImmediateOp_MOVI;
                     when '11111'
                         // FMOV Dn,#imm is in main FP instruction set
                         if Q == '0' then UnallocatedEncoding();
                         operation = ImmediateOp_MOVI;

                 imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
                 imm = Replicate(imm64, datasize DIV 64);


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1141
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <T>               For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                                         following values:

                                         4H           when Q = 0

                                         8H           when Q = 1

                                         For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                                         following values:

                                         2S           when Q = 0

                                         4S           when Q = 1

                       <imm8>            Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

                       <amount>          For the 16-bit shifted immediate variant: is the shift amount encoded in the "cmode<1>" field. It can
                                         have the following values:

                                         0            when cmode<1> = 0

                                         8            when cmode<1> = 1

                                         defaulting to 0 if LSL is omitted.

                                         For the 32-bit shifted immediate variant: is the shift amount encoded in the "cmode<2:1>" field. It
                                         can have the following values:

                                         0            when cmode<2:1> = 00

                                         8            when cmode<2:1> = 01

                                         16           when cmode<2:1> = 10

                                         24           when cmode<2:1> = 11

                                         defaulting to 0 if LSL is omitted.

                                         For the 32-bit shifting ones variant: is the shift amount encoded in the "cmode<0>" field. It can have
                                         the following values:

                                         8            when cmode<0> = 0

                                         16           when cmode<0> = 1


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand;
                         bits(datasize) result;

                         case operation of
                              when ImmediateOp_MOVI
                                   result = imm;
                              when ImmediateOp_MVNI
                                   result = NOT(imm);
                              when ImmediateOp_ORR
                                   operand = V[rd];
                                   result = operand OR imm;
                              when ImmediateOp_BIC
                                   operand = V[rd];
                                   result = operand AND NOT(imm);

                         V[rd] = result;




C7-1142                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                 ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.184    NEG (vector)

                Negate (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0                                  Rn             Rd
                        U


                Scalar variant

                NEG <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 boolean neg = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0                                  Rn             Rd
                        U


                Vector variant

                NEG <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean neg = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               D           when size = 11

                               It is RESERVED when:

                               ·      size = 0x.

                               ·      size = 10.

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>            Is the number of the SIMD&FP source register, encoded in the "Rn" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1143
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              if neg then
                                   element = -element;
                              else
                                   element = Abs(element);
                              Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1144                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.185    NOT

                Bitwise NOT (vector)

                This instruction is used by the alias MVN. The alias is always the preferred disassembly.




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                  0 Q 1 0 1 1 1 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0                                   Rn             Rd




                Vector variant

                NOT <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV 8;


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                8B          when Q = 0

                                16B         when Q = 1

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = NOT(element);

                 V[d] = result;




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1145
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.186       ORN (vector)

                       Bitwise inclusive OR NOT (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4            0
                            0 Q 0 0 1 1 1 0 1 1 1                   Rm         0 0 0 1 1 1              Rn              Rd
                                                     size


                       Three registers of the same type variant

                       ORN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean invert = (size<0> == '1');
                         LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                         8B          when Q = 0

                                         16B         when Q = 1

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         if invert then operand2 = NOT(operand2);

                         case op of
                              when LogicalOp_AND
                                   result = operand1 AND operand2;
                              when LogicalOp_ORR
                                   result = operand1 OR operand2;

                         V[d] = result;




C7-1146                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.187    ORR (vector, immediate)

                Bitwise inclusive OR (vector, immediate)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15          12 11 10 9 8 7 6 5 4                    0
                  0 Q 0 0 1 1 1 1 0 0 0 0 0 a b c x x x 1 0 1 d e f g h                                         Rd
                        op                                             cmode


                16-bit variant

                Applies when cmode = 10x1.

                ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}


                32-bit variant

                Applies when cmode = 0xx1.

                ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}


                Decode for all variants of this encoding

                 integer rd = UInt(Rd);

                 integer datasize = if Q == '1' then 128 else 64;
                 bits(datasize) imm;
                 bits(64) imm64;

                 ImmediateOp operation;
                 case cmode:op of
                     when '0xx00' operation = ImmediateOp_MOVI;
                     when '0xx01' operation = ImmediateOp_MVNI;
                     when '0xx10' operation = ImmediateOp_ORR;
                     when '0xx11' operation = ImmediateOp_BIC;
                     when '10x00' operation = ImmediateOp_MOVI;
                     when '10x01' operation = ImmediateOp_MVNI;
                     when '10x10' operation = ImmediateOp_ORR;
                     when '10x11' operation = ImmediateOp_BIC;
                     when '110x0' operation = ImmediateOp_MOVI;
                     when '110x1' operation = ImmediateOp_MVNI;
                     when '1110x' operation = ImmediateOp_MOVI;
                     when '11110' operation = ImmediateOp_MOVI;
                     when '11111'
                         // FMOV Dn,#imm is in main FP instruction set
                         if Q == '0' then UnallocatedEncoding();
                         operation = ImmediateOp_MOVI;

                 imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
                 imm = Replicate(imm64, datasize DIV 64);


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP register, encoded in the "Rd" field.

                <T>            For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                               following values:

                               4H         when Q = 0

                               8H         when Q = 1




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1147
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
                                         following values:

                                         2S           when Q = 0

                                         4S           when Q = 1

                       <imm8>            Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

                       <amount>          For the 16-bit variant: is the shift amount encoded in the "cmode<1>" field. It can have the
                                         following values:

                                         0            when cmode<1> = 0

                                         8            when cmode<1> = 1

                                         defaulting to 0 if LSL is omitted.

                                         For the 32-bit variant: is the shift amount encoded in the "cmode<2:1>" field. It can have the
                                         following values:

                                         0            when cmode<2:1> = 00

                                         8            when cmode<2:1> = 01

                                         16           when cmode<2:1> = 10

                                         24           when cmode<2:1> = 11

                                         defaulting to 0 if LSL is omitted.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand;
                         bits(datasize) result;

                         case operation of
                              when ImmediateOp_MOVI
                                   result = imm;
                              when ImmediateOp_MVNI
                                   result = NOT(imm);
                              when ImmediateOp_ORR
                                   operand = V[rd];
                                   result = operand OR imm;
                              when ImmediateOp_BIC
                                   operand = V[rd];
                                   result = operand AND NOT(imm);

                         V[rd] = result;




C7-1148                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.188    ORR (vector, register)

                Bitwise inclusive OR (vector, register)

                This instruction is used by the alias MOV (vector). See the Alias conditions table for details of when each alias is
                preferred.




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4           0
                  0 Q 0 0 1 1 1 0 1 0 1                    Rm          0 0 0 1 1 1              Rn             Rd
                                             size


                Three registers of the same type variant

                ORR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean invert = (size<0> == '1');
                 LogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;


                Alias conditions


                                     Alias                   is preferred when

                                     MOV (vector)            Rm == Rn



                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                                8B          when Q = 0

                                16B         when Q = 1

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>            Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;

                 if invert then operand2 = NOT(operand2);

                 case op of
                     when LogicalOp_AND
                          result = operand1 AND operand2;
                     when LogicalOp_ORR



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1149
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   result = operand1 OR operand2;

                         V[d] = result;




C7-1150                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.189    PMUL

                Polynomial multiply




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         1 0 0 1 1 1               Rn              Rd
                        U


                Three registers of the same type variant

                PMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if U == '1' && size != '00' then ReservedValue();
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean poly = (U == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              It is RESERVED when:

                              ·      size = 01, Q = x.

                              ·      size = 1x, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(esize) element1;
                 bits(esize) element2;
                 bits(esize) product;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, esize];
                     element2 = Elem[operand2, e, esize];
                     if poly then
                         product = PolynomialMult(element1, element2)<esize-1:0>;
                     else
                         product = (UInt(element1) * UInt(element2))<esize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1151
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, e, esize] = product;

                         V[d] = result;




C7-1152                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.190    PMULL, PMULL2

                Polynomial multiply long




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 size 1                  Rm          1 1 1 0 0 0               Rn               Rd




                Three registers, not all the same type variant

                PMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '01' || size == '10' then ReservedValue();
                 if size == '11' && ! HaveCryptoExt() then UnallocatedEncoding();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              1Q          when size = 11

                              It is RESERVED when:

                              ·      size = 01.

                              ·      size = 10.

                              The '1Q' arrangement is only allocated in an implementation that includes the Cryptographic
                              Extension, and is otherwise RESERVED.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              1D          when size = 11, Q = 0

                              2D          when size = 11, Q = 1

                              It is RESERVED when:

                              ·      size = 01, Q = x.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1153
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         ·      size = 10, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              Elem[result, e, 2*esize] = PolynomialMult(element1, element2);

                         V[d] = result;




C7-1154                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.191    RADDHN, RADDHN2

                Rounding add returning high narrow




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 1 0 0 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                RADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean round = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1155
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(2*datasize) operand1 = V[n];
                         bits(2*datasize) operand2 = V[m];
                         bits(datasize)      result;
                         integer round_const = if round then 1 << (esize - 1) else 0;
                         bits(2*esize) element1;
                         bits(2*esize) element2;
                         bits(2*esize) sum;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, 2*esize];
                              element2 = Elem[operand2, e, 2*esize];
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              sum = sum + round_const;
                              Elem[result, e, esize] = sum<2*esize-1:esize>;

                         Vpart[d, part] = result;




C7-1156                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.192    RBIT (vector)

                Reverse bit order (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 Q 1 0 1 1 1 0 0 1 1 0 0 0 0 0 0 1 0 1 1 0                                  Rn             Rd




                Vector variant

                RBIT <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 8;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV 8;


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                               8B          when Q = 0

                               16B         when Q = 1

                <Vn>           Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 bits(esize) element;
                 bits(esize) rev;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     for i = 0 to esize-1
                         rev<esize-1-i> = element<i>;
                     Elem[result, e, esize] = rev;

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1157
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.193       REV16 (vector)

                       Reverse elements in 16-bit halfwords (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4             0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 0 1 1 0                                 Rn              Rd
                                  U                                                     o0


                       Vector variant

                       REV16 <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         // size=esize:      B(0),   H(1),   S(1), D(S)
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         // op=REVx:        64(0), 32(1), 16(2)
                         bits(2) op = o0:U;

                         // => op+size:
                         //        64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
                         //        32+B = 1, 32+H = 2, 32+S = X, 32+D = X
                         //        16+B = 2, 16+H = X, 16+S = X, 16+D = X
                         //         8+B = X,    8+H = X,   8+S = X,  8+D = X
                         // => 3-(op+size) (index bits in group)
                         //        64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
                         //        32+B = 2, 32+H = 1, 32+S = X, 32+D = X
                         //        16+B = 1, 16+H = X, 16+S = X, 16+D = X
                         //         8+B = X,    8+H = X,   8+S = X,  8+D = X

                         // index bits within group: 1, 2, 3
                         if UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();
                         integer ibits = 3-(UInt(op)+UInt(size));

                         // invert mask to invert index bits within group (max index = 15)
                         bits(4) revmask = Zeros(4-ibits):Ones(ibits);


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         It is RESERVED when:

                                         ·      size = 01, Q = x.

                                         ·      size = 1x, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.




C7-1158                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 integer e_rev;
                 for e = 0 to elements-1
                     e_rev = UInt(e<3:0> EOR revmask);
                     Elem[result, e_rev, esize] = Elem[operand, e, esize];

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1159
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.194       REV32 (vector)

                       Reverse elements in 32-bit words (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4             0
                            0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 0 0 0 1 0                                 Rn              Rd
                                  U                                                     o0


                       Vector variant

                       REV32 <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         // size=esize:      B(0),   H(1),  S(1), D(S)
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         // op=REVx:        64(0), 32(1), 16(2)
                         bits(2) op = o0:U;

                         // => op+size:
                         //        64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
                         //        32+B = 1, 32+H = 2, 32+S = X, 32+D = X
                         //        16+B = 2, 16+H = X, 16+S = X, 16+D = X
                         //         8+B = X,    8+H = X, 8+S = X,   8+D = X
                         // => 3-(op+size) (index bits in group)
                         //        64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
                         //        32+B = 2, 32+H = 1, 32+S = X, 32+D = X
                         //        16+B = 1, 16+H = X, 16+S = X, 16+D = X
                         //         8+B = X,    8+H = X, 8+S = X,   8+D = X

                         // index bits within group: 1, 2, 3
                         if UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();
                         integer ibits = 3-(UInt(op)+UInt(size));

                         // invert mask to invert index bits within group (max index = 15)
                         bits(4) revmask = Zeros(4-ibits):Ones(ibits);


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         It is RESERVED when size = 1x, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.




C7-1160                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 integer e_rev;
                 for e = 0 to elements-1
                     e_rev = UInt(e<3:0> EOR revmask);
                     Elem[result, e_rev, esize] = Elem[operand, e, esize];

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1161
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.195       REV64

                       Reverse elements in 64-bit doublewords (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4             0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 0 0 1 0                                 Rn              Rd
                                  U                                                     o0


                       Vector variant

                       REV64 <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         // size=esize:      B(0),   H(1),  S(1), D(S)
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         // op=REVx:        64(0), 32(1), 16(2)
                         bits(2) op = o0:U;

                         // => op+size:
                         //        64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
                         //        32+B = 1, 32+H = 2, 32+S = X, 32+D = X
                         //        16+B = 2, 16+H = X, 16+S = X, 16+D = X
                         //         8+B = X,    8+H = X, 8+S = X,   8+D = X
                         // => 3-(op+size) (index bits in group)
                         //        64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
                         //        32+B = 2, 32+H = 1, 32+S = X, 32+D = X
                         //        16+B = 1, 16+H = X, 16+S = X, 16+D = X
                         //         8+B = X,    8+H = X, 8+S = X,   8+D = X

                         // index bits within group: 1, 2, 3
                         if UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();
                         integer ibits = 3-(UInt(op)+UInt(size));

                         // invert mask to invert index bits within group (max index = 15)
                         bits(4) revmask = Zeros(4-ibits):Ones(ibits);


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.




C7-1162                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 integer e_rev;
                 for e = 0 to elements-1
                     e_rev = UInt(e<3:0> EOR revmask);
                     Elem[result, e_rev, esize] = Elem[operand, e, esize];

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1163
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.196       RSHRN, RSHRN2

                       Rounding shift right narrow (immediate)




                           31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 1 0              !=0000      immb      1 0 0 0 1 1               Rn               Rd
                                                            immh                               op


                       Vector variant

                       RSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3> == '1' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         integer shift = (2 * esize) - UInt(immh:immb);
                         boolean round = (op == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B          when immh = 0001, Q = 0

                                         16B         when immh = 0001, Q = 1

                                         4H          when immh = 001x, Q = 0

                                         8H          when immh = 001x, Q = 1

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                         8H          when immh = 0001

                                         4S          when immh = 001x

                                         2D          when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.



C7-1164                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when immh = 1xxx.

                <shift>       Is the right shift amount, in the range 1 to the destination element width in bits, encoded in the
                              "immh:immb" field. It can have the following values:

                              (16-UInt(immh:immb))when immh = 0001

                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when immh = 1xxx.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize*2) operand = V[n];
                 bits(datasize) result;
                 integer round_const = if round then (1 << (shift - 1)) else 0;
                 integer element;

                 for e = 0 to elements-1
                     element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
                     Elem[result, e, esize] = element<esize-1:0>;

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1165
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.197       RSUBHN, RSUBHN2

                       Rounding subtract returning high narrow




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 1 0 1 1 1 0 size 1                   Rm          0 1 1 0 0 0               Rn               Rd
                                  U                                                    o1


                       Three registers, not all the same type variant

                       RSUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o1 == '1');
                         boolean round = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.




C7-1166                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand1 = V[n];
                 bits(2*datasize) operand2 = V[m];
                 bits(datasize)   result;
                 integer round_const = if round then 1 << (esize - 1) else 0;
                 bits(2*esize) element1;
                 bits(2*esize) element2;
                 bits(2*esize) sum;

                 for e = 0 to elements-1
                     element1 = Elem[operand1, e, 2*esize];
                     element2 = Elem[operand2, e, 2*esize];
                     if sub_op then
                         sum = element1 - element2;
                     else
                         sum = element1 + element2;
                     sum = sum + round_const;
                     Elem[result, e, esize] = sum<2*esize-1:esize>;

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1167
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.198       SABA

                       Signed absolute difference and accumulate




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         0 1 1 1 1 1               Rn              Rd
                                  U                                                        ac


                       Three registers of the same type variant

                       SABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean accumulate = (ac == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         bits(esize) absdiff;

                         result = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);




C7-1168                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    absdiff = Abs(element1 - element2)<esize-1:0>;
                     Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1169
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.199       SABAL, SABAL2

                       Signed absolute difference and accumulate long




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          0 1 0 1 0 0               Rn               Rd
                                  U                                                    op


                       Three registers, not all the same type variant

                       SABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean accumulate = (op == '0');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.




C7-1170                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) absdiff;

                 result = if accumulate then V[d] else Zeros();
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     absdiff = Abs(element1 - element2)<2*esize-1:0>;
                     Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1171
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.200       SABD

                       Signed absolute difference




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         0 1 1 1 0 1               Rn              Rd
                                  U                                                        ac


                       Three registers of the same type variant

                       SABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean accumulate = (ac == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         bits(esize) absdiff;

                         result = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);




C7-1172                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    absdiff = Abs(element1 - element2)<esize-1:0>;
                     Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1173
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.201       SABDL, SABDL2

                       Signed absolute difference long




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          0 1 1 1 0 0               Rn               Rd
                                  U                                                    op


                       Three registers, not all the same type variant

                       SABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean accumulate = (op == '0');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.




C7-1174                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) absdiff;

                 result = if accumulate then V[d] else Zeros();
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     absdiff = Abs(element1 - element2)<2*esize-1:0>;
                     Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1175
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.202       SADALP

                       Signed add and accumulate long pairwise




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4             0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 0 1 0                                 Rn              Rd
                                  U                                              op


                       Vector variant

                       SADALP <Vd>.<Ta>, <Vn>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV (2*esize);
                         boolean acc = (op == '1');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 00, Q = 0

                                         8H          when size = 00, Q = 1

                                         2S          when size = 01, Q = 0

                                         4S          when size = 01, Q = 1

                                         1D          when size = 10, Q = 0

                                         2D          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;




C7-1176                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 bits(2*esize) sum;
                 integer op1;
                 integer op2;

                 result = if acc then V[d] else Zeros();
                 for e = 0 to elements-1
                     op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
                     op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
                     sum = (op1 + op2)<2*esize-1:0>;
                     Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1177
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.203       SADDL, SADDL2

                       Signed add long (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          0 0 0 0 0 0               Rn               Rd
                                  U                                                    o1


                       Three registers, not all the same type variant

                       SADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o1 == '1');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.




C7-1178                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 integer sum;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     if sub_op then
                         sum = element1 - element2;
                     else
                         sum = element1 + element2;
                     Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1179
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.204       SADDLP

                       Signed add long pairwise




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4             0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 0 1 0                                 Rn              Rd
                                  U                                              op


                       Vector variant

                       SADDLP <Vd>.<Ta>, <Vn>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV (2*esize);
                         boolean acc = (op == '1');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 00, Q = 0

                                         8H          when size = 00, Q = 1

                                         2S          when size = 01, Q = 0

                                         4S          when size = 01, Q = 1

                                         1D          when size = 10, Q = 0

                                         2D          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;




C7-1180                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 bits(2*esize) sum;
                 integer op1;
                 integer op2;

                 result = if acc then V[d] else Zeros();
                 for e = 0 to elements-1
                     op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
                     op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
                     sum = (op1 + op2)<2*esize-1:0>;
                     Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1181
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.205       SADDLV

                       Signed add long across vector




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4            0
                            0 Q 0 0 1 1 1 0 size 1 1 0 0 0 0 0 0 1 1 1 0                                  Rn               Rd
                                  U


                       Advanced SIMD variant

                       SADDLV <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size:Q == '100' then ReservedValue();
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 00

                                         S           when size = 01

                                         D           when size = 10

                                         It is RESERVED when size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 10, Q = 0.

                                         ·      size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         integer sum;

                         sum = Int(Elem[operand, 0, esize], unsigned);




C7-1182                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 for e = 1 to elements-1
                     sum = sum + Int(Elem[operand, e, esize], unsigned);

                 V[d] = sum<2*esize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1183
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.206       SADDW, SADDW2

                       Signed add wide




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          0 0 0 1 0 0               Rn               Rd
                                  U                                                    o1


                       Three registers, not all the same type variant

                       SADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o1 == '1');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1




C7-1184                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when size = 11, Q = x.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand1 = V[n];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 integer sum;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, 2*esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     if sub_op then
                         sum = element1 - element2;
                     else
                         sum = element1 + element2;
                     Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1185
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.207       SCVTF (vector, fixed-point)

                       Signed fixed-point convert to floating-point (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 1 0 1 1 1 1 1 0              !=0000     immb      1 1 1 0 0 1             Rn             Rd
                                  U                         immh


                       Scalar variant

                       SCVTF <V><d>, <V><n>, #<fbits>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '00xx' then ReservedValue();
                         integer esize = 32 << UInt(immh<3>);
                         integer datasize = esize;
                         integer elements = 1;

                         integer fracbits = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         FPRounding rounding = FPRoundingMode(FPCR);


                       Vector


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 Q 0 0 1 1 1 1 0              !=0000     immb      1 1 1 0 0 1             Rn             Rd
                                  U                         immh


                       Vector variant

                       SCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh == '00xx' then ReservedValue();
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(immh<3>);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer fracbits = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         FPRounding rounding = FPRoundingMode(FPCR);


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "immh" field. It can have the following values:

                                         S           when immh = 01xx

                                         D           when immh = 1xxx



C7-1186                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when immh = 00xx.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              2S          when immh = 01xx, Q = 0

                              4S          when immh = 01xx, Q = 1

                              2D          when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when:

                              ·      immh = 0001, Q = x.

                              ·      immh = 001x, Q = x.

                              ·      immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <fbits>       For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
                              in the "immh:immb" field. It can have the following values:

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              It is RESERVED when immh = 00xx.

                              For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
                              in the "immh:immb" field. It can have the following values:

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when:

                              ·      immh = 0001.

                              ·      immh = 001x.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand  = V[n];
                 bits(datasize) result;
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1187
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.208       SCVTF (vector, integer)

                       Signed integer convert to floating-point (vector)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                            0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0                                  Rn             Rd
                                  U


                       Scalar variant

                       SCVTF <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 32 << UInt(sz);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4           0
                            0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0                                  Rn             Rd
                                  U


                       Vector variant

                       SCVTF <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz:Q == '10' then ReservedValue();
                         integer esize = 32 << UInt(sz);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "sz" field. It can have the following values:

                                         S           when sz = 0

                                         D           when sz = 1

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0



C7-1188                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              4S         when sz = 0, Q = 1

                              2D         when sz = 1, Q = 1

                              It is RESERVED when sz = 1, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 FPRounding rounding = FPRoundingMode(FPCR);
                 bits(esize) element;

                 for e = 0 to elements-1
                     element = Elem[operand, e, esize];
                     Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1189
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.209       SCVTF (scalar, fixed-point)

                       Signed fixed-point convert to floating-point (scalar): Vd = signed_convertFromInt(Rn/(2^fbits))




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18     16 15               10 9          5 4         0
                            sf 0 0 1 1 1 1 0 0 x 0 0 0 0 1 0                       scale            Rn             Rd
                                                     type    rmode opcode


                       32-bit to single-precision variant

                       Applies when sf = 0 && type = 00.

                       SCVTF <Sd>, <Wn>, #<fbits>


                       32-bit to double-precision variant

                       Applies when sf = 0 && type = 01.

                       SCVTF <Dd>, <Wn>, #<fbits>


                       64-bit to single-precision variant

                       Applies when sf = 1 && type = 00.

                       SCVTF <Sd>, <Xn>, #<fbits>


                       64-bit to double-precision variant

                       Applies when sf = 1 && type = 01.

                       SCVTF <Dd>, <Xn>, #<fbits>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;

                         case type of
                              when '00' fltsize = 32;
                              when '01' fltsize = 64;
                              when '1x' UnallocatedEncoding();

                         if sf == '0' && scale<5> == '0' then UnallocatedEncoding();
                         integer fracbits = 64 - UInt(scale);

                         case opcode<2:1>:rmode of
                              when '00 11'         // FCVTZ
                                   rounding = FPRounding_ZERO;
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_ItoF;
                              otherwise
                                   UnallocatedEncoding();




C7-1190                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                         ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                <Dd>          Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sd>          Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Xn>          Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Wn>          Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                <fbits>       For the 32-bit to double-precision and 32-bit to single-precision variant: is the number of bits after
                              the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus "scale".

                              For the 64-bit to double-precision and 64-bit to single-precision variant: is the number of bits after
                              the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus "scale".


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                         V[d] = fltval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1191
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.210       SCVTF (scalar, integer)

                       Signed integer convert to floating-point (scalar): Vd = signed_convertFromInt(Rn)




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15 14 13 12 11 10 9         5 4    0
                            sf 0 0 1 1 1 1 0 0 x 1 0 0 0 1 0 0 0 0 0 0 0                            Rn       Rd
                                                     type    rmode opcode


                       32-bit to single-precision variant

                       Applies when sf = 0 && type = 00.

                       SCVTF <Sd>, <Wn>


                       32-bit to double-precision variant

                       Applies when sf = 0 && type = 01.

                       SCVTF <Dd>, <Wn>


                       64-bit to single-precision variant

                       Applies when sf = 1 && type = 00.

                       SCVTF <Sd>, <Xn>


                       64-bit to double-precision variant

                       Applies when sf = 1 && type = 01.

                       SCVTF <Dd>, <Xn>


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer intsize = if sf == '1' then 64 else 32;
                         integer fltsize;
                         FPConvOp op;
                         FPRounding rounding;
                         boolean unsigned;
                         integer part;

                         case type of
                              when '00'
                                   fltsize = 32;
                              when '01'
                                   fltsize = 64;
                              when '10'
                                   if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                                   fltsize = 128;
                              when '11'
                                   UnallocatedEncoding();

                         case opcode<2:1>:rmode of
                              when '00 xx'         // FCVT[NPMZ][US]
                                   rounding = FPDecodeRounding(rmode);
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '01 00'         // [US]CVTF
                                   rounding = FPRoundingMode(FPCR);
                                   unsigned = (opcode<0> == '1');



C7-1192                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         op = FPConvOp_CVT_ItoF;
                    when '10 00'         // FCVTA[US]
                         rounding = FPRounding_TIEAWAY;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                    when '11 00'         // FMOV
                         if fltsize != intsize then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 0;
                    when '11 01'         // FMOV D[1]
                         if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                         op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                         part = 1;
                    otherwise
                         UnallocatedEncoding();


                Assembler symbols

                <Dd>          Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sd>          Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Xn>          Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                <Wn>          Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                Operation

                 CheckFPAdvSIMDEnabled64();

                 bits(fltsize) fltval;
                 bits(intsize) intval;

                 case op of
                    when FPConvOp_CVT_FtoI
                         fltval = V[n];
                         intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                         X[d] = intval;
                    when FPConvOp_CVT_ItoF
                         intval = X[n];
                         fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                         V[d] = fltval;
                    when FPConvOp_MOV_FtoI
                         intval = Vpart[n,part];
                         X[d] = intval;
                    when FPConvOp_MOV_ItoF
                        intval = X[n];
                         Vpart[d,part] = intval;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1193
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.211       SHA1C

                       SHA1 hash update (choose)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9           5 4             0
                            0 1 0 1 1 1 1 0 0 0 0                   Rm         0 0 0 0 0 0          Rn              Rd




                       Advanced SIMD variant

                       SHA1C <Qd>, <Sn>, <Vm>.4S


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if ! HaveCryptoExt() then UnallocatedEncoding();


                       Assembler symbols

                       <Qd>              Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) X = V[d];
                         bits(32)    Y = V[n];      // Note: 32 not 128 bits wide
                         bits(128) W = V[m];
                         bits(32)    t;

                         for e = 0 to 3
                              t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);
                              Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
                              X<63:32> = ROL(X<63:32>, 30);
                              <Y, X> = ROL(Y : X, 32);
                         V[d] = X;




C7-1194                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                           ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.212    SHA1H

                SHA1 fixed rotate




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0                                Rn             Rd




                Advanced SIMD variant

                SHA1H <Sd>, <Sn>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 if ! HaveCryptoExt() then UnallocatedEncoding();


                Assembler symbols

                <Sd>          Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(32) operand = V[n];        // read element [0] only,    [1-3] zeroed
                 V[d] = ROL(operand, 30);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1195
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.213       SHA1M

                       SHA1 hash update (majority)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9           5 4             0
                            0 1 0 1 1 1 1 0 0 0 0                   Rm         0 0 1 0 0 0          Rn              Rd




                       Advanced SIMD variant

                       SHA1M <Qd>, <Sn>, <Vm>.4S


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if ! HaveCryptoExt() then UnallocatedEncoding();


                       Assembler symbols

                       <Qd>              Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

                       <Sn>              Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) X = V[d];
                         bits(32)    Y = V[n];      // Note: 32 not 128 bits wide
                         bits(128) W = V[m];
                         bits(32)    t;

                         for e = 0 to 3
                              t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);
                              Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
                              X<63:32> = ROL(X<63:32>, 30);
                              <Y, X> = ROL(Y : X, 32);
                         V[d] = X;




C7-1196                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.214    SHA1P

                SHA1 hash update (parity)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4          0
                  0 1 0 1 1 1 1 0 0 0 0                  Rm         0 0 0 1 0 0               Rn             Rd




                Advanced SIMD variant

                SHA1P <Qd>, <Sn>, <Vm>.4S


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if ! HaveCryptoExt() then UnallocatedEncoding();


                Assembler symbols

                <Qd>          Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

                <Sn>          Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(128) X = V[d];
                 bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
                 bits(128) W = V[m];
                 bits(32)  t;

                 for e = 0 to 3
                     t = SHAparity(X<63:32>, X<95:64>, X<127:96>);
                     Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
                     X<63:32> = ROL(X<63:32>, 30);
                     <Y, X> = ROL(Y : X, 32);
                 V[d] = X;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1197
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.215       SHA1SU0

                       SHA1 schedule update 0




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9           5 4             0
                            0 1 0 1 1 1 1 0 0 0 0                   Rm         0 0 1 1 0 0           Rn             Rd




                       Advanced SIMD variant

                       SHA1SU0 <Vd>.4S, <Vn>.4S, <Vm>.4S


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if ! HaveCryptoExt() then UnallocatedEncoding();


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) operand1 = V[d];
                         bits(128) operand2 = V[n];
                         bits(128) operand3 = V[m];
                         bits(128) result;

                         result = operand2<63:0> : operand1<127:64>;
                         result = result EOR operand1 EOR operand3;
                         V[d] = result;




C7-1198                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                            ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.216    SHA1SU1

                SHA1 schedule update 1




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0                                Rn             Rd




                Advanced SIMD variant

                SHA1SU1 <Vd>.4S, <Vn>.4S


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 if ! HaveCryptoExt() then UnallocatedEncoding();


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the second SIMD&FP source register, encoded in the "Rn" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(128) operand1 = V[d];
                 bits(128) operand2 = V[n];
                 bits(128) result;
                 bits(128) T = operand1 EOR LSR(operand2, 32);
                 result<31:0>   = ROL(T<31:0>,    1);
                 result<63:32>  = ROL(T<63:32>,   1);
                 result<95:64>  = ROL(T<95:64>,   1);
                 result<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1199
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.217       SHA256H2

                       SHA256 hash update (part 2)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9           5 4             0
                            0 1 0 1 1 1 1 0 0 0 0                   Rm         0 1 0 1 0 0          Rn              Rd
                                                                                       P


                       Advanced SIMD variant

                       SHA256H2 <Qd>, <Qn>, <Vm>.4S


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if ! HaveCryptoExt() then UnallocatedEncoding();
                         boolean part1 = (P == '0');


                       Assembler symbols

                       <Qd>              Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

                       <Qn>              Is the 128-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) result;
                         if part1 then
                              result = SHA256hash(V[d], V[n], V[m], TRUE);
                         else
                              result = SHA256hash(V[n], V[d], V[m], FALSE);
                         V[d] = result;




C7-1200                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.218    SHA256H

                SHA256 hash update (part 1)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4          0
                  0 1 0 1 1 1 1 0 0 0 0                  Rm         0 1 0 0 0 0               Rn             Rd
                                                                            P


                Advanced SIMD variant

                SHA256H <Qd>, <Qn>, <Vm>.4S


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if ! HaveCryptoExt() then UnallocatedEncoding();
                 boolean part1 = (P == '0');


                Assembler symbols

                <Qd>          Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

                <Qn>          Is the 128-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(128) result;
                 if part1 then
                     result = SHA256hash(V[d], V[n], V[m], TRUE);
                 else
                     result = SHA256hash(V[n], V[d], V[m], FALSE);
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1201
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.219       SHA256SU0

                       SHA256 schedule update 0




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9             5 4             0
                            0 1 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0                              Rn             Rd




                       Advanced SIMD variant

                       SHA256SU0 <Vd>.4S, <Vn>.4S


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         if ! HaveCryptoExt() then UnallocatedEncoding();


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the second SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckCryptoEnabled64();

                         bits(128) operand1 = V[d];
                         bits(128) operand2 = V[n];
                         bits(128) result;
                         bits(128) T = operand2<31:0> : operand1<127:32>;
                         bits(32) elt;

                         for e = 0 to 3
                              elt = Elem[T, e, 32];
                              elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
                              Elem[result, e, 32] = elt + Elem[operand1, e, 32];
                         V[d] = result;




C7-1202                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                            ID121714

                                                             C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                          C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.220    SHA256SU1

                SHA256 schedule update 1




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 0 0 0                  Rm         0 1 1 0 0 0              Rn             Rd




                Advanced SIMD variant

                SHA256SU1 <Vd>.4S, <Vn>.4S, <Vm>.4S


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if ! HaveCryptoExt() then UnallocatedEncoding();


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the third SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckCryptoEnabled64();

                 bits(128) operand1 = V[d];
                 bits(128) operand2 = V[n];
                 bits(128) operand3 = V[m];
                 bits(128) result;
                 bits(128) T0 = operand3<31:0> : operand2<127:32>;
                 bits(64) T1;
                 bits(32) elt;

                 T1 = operand3<127:64>;
                 for e = 0 to 1
                     elt = Elem[T1, e, 32];
                     elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
                     elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
                     Elem[result, e, 32] = elt;

                 T1 = result<63:0>;
                 for e = 2 to 3
                     elt = Elem[T1, e - 2, 32];
                     elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
                     elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
                     Elem[result, e, 32] = elt;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1203
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.221       SHADD

                       Signed halving add




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         0 0 0 0 0 1               Rn              Rd
                                  U


                       Three registers of the same type variant

                       SHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              sum = element1 + element2;
                              Elem[result, e, esize] = sum<esize:1>;

                         V[d] = result;



C7-1204                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.222    SHL

                Shift left (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 0              !=0000     immb      0 1 0 1 0 1              Rn             Rd
                                                  immh


                Scalar variant

                SHL <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = UInt(immh:immb) - esize;


                Vector


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 0              !=0000     immb      0 1 0 1 0 1              Rn             Rd
                                                  immh


                Vector variant

                SHL <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = UInt(immh:immb) - esize;


                Assembler symbols

                <V>            Is a width specifier, encoded in the "immh" field. It can have the following values:

                               D           when immh = 1xxx

                               It is RESERVED when immh = 0xxx.

                <d>            Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>            Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1205
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the left shift amount, in the range 0 to 63, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (UInt(immh:immb)-64)when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
                                         encoded in the "immh:immb" field. It can have the following values:

                                         (UInt(immh:immb)-8)when immh = 0001

                                         (UInt(immh:immb)-16)when immh = 001x

                                         (UInt(immh:immb)-32)when immh = 01xx

                                         (UInt(immh:immb)-64)when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) result;

                         for e = 0 to elements-1
                              Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);

                         V[d] = result;




C7-1206                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                   C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                               C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.223    SHLL, SHLL2

                Shift left long (by element size)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                     5 4             0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 1 0 0 1 1 1 0                                     Rn               Rd




                Vector variant

                SHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = esize;
                 boolean unsigned = FALSE; // Or TRUE without change of functionality


                Assembler symbols

                2                Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                 64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                 the following values:

                                 [absent]    when Q = 0

                                 [present]   when Q = 1

                <Vd>             Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>             Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                 8H          when size = 00

                                 4S          when size = 01

                                 2D          when size = 10

                                 It is RESERVED when size = 11.

                <Vn>             Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Tb>             Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                 8B          when size = 00, Q = 0

                                 16B         when size = 00, Q = 1

                                 4H          when size = 01, Q = 0

                                 8H          when size = 01, Q = 1

                                 2S          when size = 10, Q = 0

                                 4S          when size = 10, Q = 1

                                 It is RESERVED when size = 11, Q = x.




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1207
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <shift>           Is the left shift amount, which must be equal to the source element width in bits, encoded in the
                                         "size" field. It can have the following values:

                                         8            when size = 00

                                         16           when size = 01

                                         32           when size = 10

                                         It is RESERVED when size = 11.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = Vpart[n, part];
                         bits(2*datasize) result;
                         integer element;

                         for e = 0 to elements-1
                              element = Int(Elem[operand, e, esize], unsigned) << shift;
                              Elem[result, e, 2*esize] = element<2*esize-1:0>;

                         V[d] = result;




C7-1208                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                              ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.224    SHRN, SHRN2

                Shift right narrow (immediate)




                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 1 0               !=0000      immb      1 0 0 0 0 1               Rn               Rd
                                                   immh                               op


                Vector variant

                SHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');


                Assembler symbols

                2               Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                the following values:

                                [absent]    when Q = 0

                                [present]   when Q = 1

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>            Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                8B          when immh = 0001, Q = 0

                                16B         when immh = 0001, Q = 1

                                4H          when immh = 001x, Q = 0

                                8H          when immh = 001x, Q = 1

                                2S          when immh = 01xx, Q = 0

                                4S          when immh = 01xx, Q = 1

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                It is RESERVED when immh = 1xxx, Q = x.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>            Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                8H          when immh = 0001

                                4S          when immh = 001x

                                2D          when immh = 01xx

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000.



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1209
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when immh = 1xxx.

                       <shift>           Is the right shift amount, in the range 1 to the destination element width in bits, encoded in the
                                         "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize*2) operand = V[n];
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         for e = 0 to elements-1
                              element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
                              Elem[result, e, esize] = element<esize-1:0>;

                         Vpart[d, part] = result;




C7-1210                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                 ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.225    SHSUB

                Signed halving subtract




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 1                  Rm         0 0 1 0 0 1               Rn              Rd
                        U


                Three registers of the same type variant

                SHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1

                               It is RESERVED when size = 11, Q = x.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer diff;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     diff = element1 - element2;
                     Elem[result, e, esize] = diff<esize:1>;

                 V[d] = result;



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1211
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.226       SLI

                       Shift left and insert (immediate)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 1 1 1 1 1 1 1 0              !=0000     immb      0 1 0 1 0 1             Rn             Rd
                                                            immh


                       Scalar variant

                       SLI <V><d>, <V><n>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh<3> != '1' then ReservedValue();
                         integer esize = 8 << 3;
                         integer datasize = esize;
                         integer elements = 1;

                         integer shift = UInt(immh:immb) - esize;


                       Vector


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 Q 1 0 1 1 1 1 0              !=0000     immb      0 1 0 1 0 1             Rn             Rd
                                                            immh


                       Vector variant

                       SLI <Vd>.<T>, <Vn>.<T>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer shift = UInt(immh:immb) - esize;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "immh" field. It can have the following values:

                                         D           when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


C7-1212                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              8B           when immh = 0001, Q = 0

                              16B          when immh = 0001, Q = 1

                              4H           when immh = 001x, Q = 0

                              8H           when immh = 001x, Q = 1

                              2S           when immh = 01xx, Q = 0

                              4S           when immh = 01xx, Q = 1

                              2D           when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <shift>       For the scalar variant: is the left shift amount, in the range 0 to 63, encoded in the "immh:immb"
                              field. It can have the following values:

                              (UInt(immh:immb)-64)when immh = 1xxx

                              It is RESERVED when immh = 0xxx.

                              For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
                              encoded in the "immh:immb" field. It can have the following values:

                              (UInt(immh:immb)-8)when immh = 0001

                              (UInt(immh:immb)-16)when immh = 001x

                              (UInt(immh:immb)-32)when immh = 01xx

                              (UInt(immh:immb)-64)when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand   = V[n];
                 bits(datasize) operand2 = V[d];
                 bits(datasize) result;
                 bits(esize) mask = LSL(Ones(esize), shift);
                 bits(esize) shifted;

                 for e = 0 to elements-1
                     shifted = LSL(Elem[operand, e, esize], shift);
                     Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1213
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.227       SMAX

                       Signed maximum (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         0 1 1 0 0 1               Rn              Rd
                                  U                                                        o1


                       Three registers of the same type variant

                       SMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         integer maxmin;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              maxmin = if minimum then Min(element1, element2) else Max(element1, element2);




C7-1214                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                     Elem[result, e, esize] = maxmin<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1215
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.228       SMAXP

                       Signed maximum pairwise




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         1 0 1 0 0 1               Rn              Rd
                                  U                                                        o1


                       Three registers of the same type variant

                       SMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         integer element1;
                         integer element2;
                         integer maxmin;

                         for e = 0 to elements-1
                              element1 = Int(Elem[concat, 2*e, esize], unsigned);
                              element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
                              maxmin = if minimum then Min(element1, element2) else Max(element1, element2);



C7-1216                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                     Elem[result, e, esize] = maxmin<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1217
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.229       SMAXV

                       Signed maximum across vector




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4            0
                            0 Q 0 0 1 1 1 0 size 1 1 0 0 0 0 1 0 1 0 1 0                                  Rn               Rd
                                  U                                         op


                       Advanced SIMD variant

                       SMAXV <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size:Q == '100' then ReservedValue();
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean min = (op == '1');


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 10, Q = 0.

                                         ·      size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         integer maxmin;
                         integer element;




C7-1218                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 maxmin = Int(Elem[operand, 0, esize], unsigned);
                 for e = 1 to elements-1
                     element = Int(Elem[operand, e, esize], unsigned);
                     maxmin = if min then Min(maxmin, element) else Max(maxmin, element);

                 V[d] = maxmin<esize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1219
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.230       SMIN

                       Signed minimum (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         0 1 1 0 1 1               Rn              Rd
                                  U                                                        o1


                       Three registers of the same type variant

                       SMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         integer maxmin;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              maxmin = if minimum then Min(element1, element2) else Max(element1, element2);




C7-1220                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                     Elem[result, e, esize] = maxmin<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1221
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.231       SMINP

                       Signed minimum pairwise




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         1 0 1 0 1 1               Rn              Rd
                                  U                                                        o1


                       Three registers of the same type variant

                       SMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean minimum = (o1 == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(2*datasize) concat = operand2:operand1;
                         integer element1;
                         integer element2;
                         integer maxmin;

                         for e = 0 to elements-1
                              element1 = Int(Elem[concat, 2*e, esize], unsigned);
                              element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
                              maxmin = if minimum then Min(element1, element2) else Max(element1, element2);



C7-1222                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                     Elem[result, e, esize] = maxmin<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1223
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.232       SMINV

                       Signed minimum across vector




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4            0
                            0 Q 0 0 1 1 1 0 size 1 1 0 0 0 1 1 0 1 0 1 0                                  Rn               Rd
                                  U                                         op


                       Advanced SIMD variant

                       SMINV <V><d>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size:Q == '100' then ReservedValue();
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean min = (op == '1');


                       Assembler symbols

                       <V>               Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 10, Q = 0.

                                         ·      size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         integer maxmin;
                         integer element;




C7-1224                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 maxmin = Int(Elem[operand, 0, esize], unsigned);
                 for e = 1 to elements-1
                     element = Int(Elem[operand, e, esize], unsigned);
                     maxmin = if min then Min(maxmin, element) else Max(maxmin, element);

                 V[d] = maxmin<esize-1:0>;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1225
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.233       SMLAL, SMLAL2 (by element)

                       Signed multiply-add long (vector, by element)




                           31 30 29 28 27 26 25 24 23 22 21 20 19           16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 1 size L M                   Rm        0 0 1 0 H 0               Rn               Rd
                                  U                                                 o2


                       Vector variant

                       SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);        Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean sub_op = (o2 == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1



C7-1226                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                              the following values:

                              0:Rm        when size = 01

                              M:Rm        when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              Restricted to V0-V15 when element size <Ts> is H.

                <Ts>          Is an element size specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(idxdsize)   operand2 = V[m];
                 bits(2*datasize) operand3 = V[d];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;

                 element2 = Int(Elem[operand2, index, esize], unsigned);
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     product = (element1 * element2)<2*esize-1:0>;
                     if sub_op then
                         Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
                     else
                         Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1227
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.234       SMLAL, SMLAL2 (vector)

                       Signed multiply-add long (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          1 0 0 0 0 0               Rn               Rd
                                  U                                                    o1


                       Three registers, not all the same type variant

                       SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;
                         boolean sub_op = (o1 == '1');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



C7-1228                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) operand3 = V[d];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;
                 bits(2*esize) accum;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     product = (element1 * element2)<2*esize-1:0>;
                     if sub_op then
                         accum = Elem[operand3, e, 2*esize] - product;
                     else
                         accum = Elem[operand3, e, 2*esize] + product;
                     Elem[result, e, 2*esize] = accum;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1229
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.235       SMLSL, SMLSL2 (by element)

                       Signed multiply-subtract long (vector, by element)




                           31 30 29 28 27 26 25 24 23 22 21 20 19           16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 1 size L M                   Rm        0 1 1 0 H 0               Rn               Rd
                                  U                                                 o2


                       Vector variant

                       SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);        Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');
                         boolean sub_op = (o2 == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1



C7-1230                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                              the following values:

                              0:Rm        when size = 01

                              M:Rm        when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              Restricted to V0-V15 when element size <Ts> is H.

                <Ts>          Is an element size specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(idxdsize)   operand2 = V[m];
                 bits(2*datasize) operand3 = V[d];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;

                 element2 = Int(Elem[operand2, index, esize], unsigned);
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     product = (element1 * element2)<2*esize-1:0>;
                     if sub_op then
                         Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
                     else
                         Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1231
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.236       SMLSL, SMLSL2 (vector)

                       Signed multiply-subtract long (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          1 0 1 0 0 0               Rn               Rd
                                  U                                                    o1


                       Three registers, not all the same type variant

                       SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;
                         boolean sub_op = (o1 == '1');
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



C7-1232                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) operand3 = V[d];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;
                 bits(2*esize) accum;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     product = (element1 * element2)<2*esize-1:0>;
                     if sub_op then
                         accum = Elem[operand3, e, 2*esize] - product;
                     else
                         accum = Elem[operand3, e, 2*esize] + product;
                     Elem[result, e, 2*esize] = accum;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1233
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.237       SMOV

                       Signed move vector element to general-purpose register




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9               5 4              0
                            0 Q 0 0 1 1 1 0 0 0 0                   imm5        0 0 1 0 1 1              Rn             Rd




                       32-bit variant

                       Applies when Q = 0.

                       SMOV <Wd>, <Vn>.<Ts>[<index>]


                       64-bit variant

                       Applies when Q = 1.

                       SMOV <Xd>, <Vn>.<Ts>[<index>]


                       Decode for all variants of this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer size;
                         case Q:imm5 of
                              when 'xxxxx1' size = 0;        // SMOV [WX]d, Vn.B
                              when 'xxxx10' size = 1;        // SMOV [WX]d, Vn.H
                              when '1xx100' size = 2;        // SMOV Xd, Vn.S
                              otherwise        UnallocatedEncoding();

                         integer idxdsize = if imm5<4> == '1' then 128 else 64;
                         integer index = UInt(imm5<4:size+1>);
                         integer esize = 8 << size;
                         integer datasize = if Q == '1' then 64 else 32;


                       Assembler symbols

                       <Wd>              Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Xd>              Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Ts>              For the 32-bit variant: is an element size specifier, encoded in the "imm5" field. It can have the
                                         following values:

                                         B           when imm5 = xxxx1

                                         H           when imm5 = xxx10

                                         It is RESERVED when imm5 = xxx00.

                                         For the 64-bit variant: is an element size specifier, encoded in the "imm5" field. It can have the
                                         following values:

                                         B           when imm5 = xxxx1

                                         H           when imm5 = xxx10

                                         S           when imm5 = xx100

                                         It is RESERVED when imm5 = xx000.




C7-1234                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <index>       For the 32-bit variant: is the element index encoded in the "imm5" field. It can have the following
                              values:

                              imm5<4:1>  when imm5 = xxxx1

                              imm5<4:2>  when imm5 = xxx10

                              It is RESERVED when imm5 = xxx00.

                              For the 64-bit variant: is the element index encoded in the "imm5" field. It can have the following
                              values:

                              imm5<4:1>  when imm5 = xxxx1

                              imm5<4:2>  when imm5 = xxx10

                              imm5<4:3>  when imm5 = xx100

                              It is RESERVED when imm5 = xx000.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(idxdsize) operand = V[n];

                 X[d] = SignExtend(Elem[operand, index, esize], datasize);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1235
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.238       SMULL, SMULL2 (by element)

                       Signed multiply long (vector, by element)




                           31 30 29 28 27 26 25 24 23 22 21 20 19           16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 1 size L M                   Rm        1 0 1 0 H 0               Rn               Rd
                                  U


                       Vector variant

                       SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);        Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1


C7-1236                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                              the following values:

                              0:Rm        when size = 01

                              M:Rm        when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              Restricted to V0-V15 when element size <Ts> is H.

                <Ts>          Is an element size specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(idxdsize)   operand2 = V[m];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;

                 element2 = Int(Elem[operand2, index, esize], unsigned);
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     product = (element1 * element2)<2*esize-1:0>;
                     Elem[result, e, 2*esize] = product;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1237
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.239       SMULL, SMULL2 (vector)

                       Signed multiply long (vector)




                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          1 1 0 0 0 0               Rn               Rd
                                  U


                       Three registers, not all the same type variant

                       SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         8H          when size = 00

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



C7-1238                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1239
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.240       SQABS

                       Signed saturating absolute value


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                            0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0                                  Rn             Rd
                                  U


                       Scalar variant

                       SQABS <V><d>, <V><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;

                         boolean neg = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                   5 4          0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0                                  Rn             Rd
                                  U


                       Vector variant

                       SQABS <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean neg = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         D           when size = 11

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the SIMD&FP source register, encoded in the "Rn" field.



C7-1240                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = SInt(Elem[operand, e, esize]);
                     if neg then
                         element = -element;
                     else
                         element = Abs(element);
                     (Elem[result, e, esize], sat) = SignedSatQ(element, esize);
                     if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1241
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.241       SQADD

                       Signed saturating add


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 0 1 1 1 1 0 size 1                   Rm         0 0 0 0 1 1               Rn             Rd
                                  U


                       Scalar variant

                       SQADD <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 0 0 1 1 1 0 size 1                   Rm         0 0 0 0 1 1               Rn             Rd
                                  U


                       Vector variant

                       SQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         D           when size = 11

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.



C7-1242                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer sum;
                 boolean sat;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     sum = element1 + element2;
                     (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
                    if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1243
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.242       SQDMLAL, SQDMLAL2 (by element)

                       Signed saturating doubling multiply-add long (by element)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 1 0 1 1 1 1 1 size L M                Rm       0 0 1 1 H 0            Rn     Rd
                                                                               o2


                       Scalar variant

                       SQDMLAL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);     Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         integer part = 0;

                         boolean sub_op = (o2 == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 Q 0 0 1 1 1 1 size L M                Rm       0 0 1 1 H 0            Rn     Rd
                                                                               o2


                       Vector variant

                       SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);     Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);



C7-1244                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 integer elements = datasize DIV esize;

                 boolean sub_op = (o2 == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Va>          Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vb>          Is the source width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                              the following values:

                              0:Rm        when size = 01



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1245
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.

                       <Ts>              For the scalar variant: is the element width specifier, encoded in the "size" field. It can have the
                                         following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         For the vector variant: is an element size specifier, encoded in the "size" field. It can have the
                                         following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <index>           For the scalar variant: is the element index, encoded in the "size:L:H:M" field. It can have the
                                         following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         For the vector variant: is the element index encoded in the "size:L:H:M" field. It can have the
                                         following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(idxdsize)      operand2 = V[m];
                         bits(2*datasize) operand3 = V[d];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;
                         integer accum;
                         boolean sat1;
                         boolean sat2;

                         element2 = SInt(Elem[operand2, index, esize]);
                         for e = 0 to elements-1



C7-1246                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    element1 = SInt(Elem[operand1, e, esize]);
                    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
                    if sub_op then
                        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
                    else
                        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
                    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
                    if sat1 || sat2 then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1247
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.243       SQDMLAL, SQDMLAL2 (vector)

                       Signed saturating doubling multiply-add long


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 1 0 1 1 1 1 0 size 1                   Rm          1 0 0 1 0 0               Rn               Rd
                                                                                       o1


                       Scalar variant

                       SQDMLAL <Va><d>, <Vb><n>, <Vb><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '00' || size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         integer part = 0;

                         boolean sub_op = (o1 == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          1 0 0 1 0 0               Rn               Rd
                                                                                       o1


                       Vector variant

                       SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '00' || size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean sub_op = (o1 == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1



C7-1248                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Va>          Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vb>          Is the source width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) operand3 = V[d];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;
                 integer accum;
                 boolean sat1;
                 boolean sat2;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1249
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                         for e = 0 to elements-1
                              element1 = SInt(Elem[operand1, e, esize]);
                              element2 = SInt(Elem[operand2, e, esize]);
                              (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
                              if sub_op then
                                   accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
                              else
                                   accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
                              (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
                              if sat1 || sat2 then FPSR.QC = '1';

                         V[d] = result;




C7-1250                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.244    SQDMLSL, SQDMLSL2 (by element)

                Signed saturating doubling multiply-subtract long (by element)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19        16 15 14 13 12 11 10 9                 5 4          0
                  0 1 0 1 1 1 1 1 size L M                 Rm       0 1 1 1 H 0                Rn             Rd
                                                                       o2


                Scalar variant

                SQDMLSL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);    Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;

                 boolean sub_op = (o2 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19        16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 0 0 1 1 1 1 size L M                 Rm       0 1 1 1 H 0                Rn             Rd
                                                                       o2


                Vector variant

                SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);    Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1251
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         integer elements = datasize DIV esize;

                         boolean sub_op = (o2 == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Va>              Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         S           when size = 01

                                         D           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vb>              Is the source width specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01



C7-1252                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              M:Rm        when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              Restricted to V0-V15 when element size <Ts> is H.

                <Ts>          For the scalar variant: is the element width specifier, encoded in the "size" field. It can have the
                              following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              For the vector variant: is an element size specifier, encoded in the "size" field. It can have the
                              following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       For the scalar variant: is the element index, encoded in the "size:L:H:M" field. It can have the
                              following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              For the vector variant: is the element index encoded in the "size:L:H:M" field. It can have the
                              following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(idxdsize)   operand2 = V[m];
                 bits(2*datasize) operand3 = V[d];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;
                 integer accum;
                 boolean sat1;
                 boolean sat2;

                 element2 = SInt(Elem[operand2, index, esize]);
                 for e = 0 to elements-1



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1253
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              element1 = SInt(Elem[operand1, e, esize]);
                              (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
                              if sub_op then
                                   accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
                              else
                                   accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
                              (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
                              if sat1 || sat2 then FPSR.QC = '1';

                         V[d] = result;




C7-1254                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.245    SQDMLSL, SQDMLSL2 (vector)

                Signed saturating doubling multiply-subtract long


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                  0 1 0 1 1 1 1 0 size 1                   Rm          1 0 1 1 0 0               Rn               Rd
                                                                             o1


                Scalar variant

                SQDMLSL <Va><d>, <Vb><n>, <Vb><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '00' || size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;

                 boolean sub_op = (o1 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 size 1                   Rm          1 0 1 1 0 0               Rn               Rd
                                                                             o1


                Vector variant

                SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '00' || size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');


                Assembler symbols

                2              Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                               64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                               the following values:

                               [absent]    when Q = 0

                               [present]   when Q = 1



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1255
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Va>              Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         S           when size = 01

                                         D           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vb>              Is the source width specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) operand3 = V[d];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;
                         integer accum;
                         boolean sat1;
                         boolean sat2;



C7-1256                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 for e = 0 to elements-1
                     element1 = SInt(Elem[operand1, e, esize]);
                     element2 = SInt(Elem[operand2, e, esize]);
                     (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
                     if sub_op then
                         accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
                     else
                         accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
                     (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
                     if sat1 || sat2 then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1257
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.246       SQDMULH (by element)

                       Signed saturating doubling multiply returning high half (by element)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 1 0 1 1 1 1 1 size L M                Rm       1 1 0 0 H 0            Rn     Rd
                                                                                      op


                       Scalar variant

                       SQDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);     Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;

                         boolean round = (op == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19       16 15 14 13 12 11 10 9         5 4    0
                            0 Q 0 0 1 1 1 1 size L M                Rm       1 1 0 0 H 0            Rn     Rd
                                                                                      op


                       Vector variant

                       SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                       Decode for this encoding

                         integer idxdsize = if H == '1' then 128 else 64;
                         integer index;
                         bit Rmhi;
                         case size of
                              when '01' index = UInt(H:L:M); Rmhi = '0';
                              when '10' index = UInt(H:L);     Rmhi = M;
                              otherwise UnallocatedEncoding();

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rmhi:Rm);

                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;




C7-1258                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 integer elements = datasize DIV esize;

                 boolean round = (op == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                              the following values:

                              0:Rm        when size = 01

                              M:Rm        when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              Restricted to V0-V15 when element size <Ts> is H.

                <Ts>          For the scalar variant: is the element width specifier, encoded in the "size" field. It can have the
                              following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              For the vector variant: is an element size specifier, encoded in the "size" field. It can have the
                              following values:

                              H           when size = 01

                              S           when size = 10




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1259
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <index>           For the scalar variant: is the element index, encoded in the "size:L:H:M" field. It can have the
                                         following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         For the vector variant: is the element index encoded in the "size:L:H:M" field. It can have the
                                         following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(idxdsize) operand2 = V[m];
                         bits(datasize) result;
                         integer round_const = if round then 1 << (esize - 1) else 0;
                         integer element1;
                         integer element2;
                         integer product;
                         boolean sat;

                         element2 = SInt(Elem[operand2, index, esize]);
                         for e = 0 to elements-1
                              element1 = SInt(Elem[operand1, e, esize]);
                              product = (2 * element1 * element2) + round_const;
                              // The following only saturates if element1 and element2 equal -(2^(esize-1))
                              (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1260                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.247    SQDMULH (vector)

                Signed saturating doubling multiply returning high half


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 size 1                   Rm         1 0 1 1 0 1               Rn             Rd
                        U


                Scalar variant

                SQDMULH <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' || size == '00' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean rounding = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 0 size 1                   Rm         1 0 1 1 0 1               Rn             Rd
                        U


                Vector variant

                SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' || size == '00' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean rounding = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               H           when size = 01

                               S           when size = 10

                               It is RESERVED when:

                               ·      size = 00.

                               ·      size = 11.

                <d>            Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>            Is the number of the first SIMD&FP source register, encoded in the "Rn" field.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1261
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer round_const = if rounding then 1 << (esize - 1) else 0;
                         integer element1;
                         integer element2;
                         integer product;
                         boolean sat;

                         for e = 0 to elements-1
                              element1 = SInt(Elem[operand1, e, esize]);
                              element2 = SInt(Elem[operand2, e, esize]);
                              product = (2 * element1 * element2) + round_const;
                              (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1262                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.248    SQDMULL, SQDMULL2 (by element)

                Signed saturating doubling multiply long (by element)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19        16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 size L M                 Rm       1 0 1 1 H 0               Rn             Rd




                Scalar variant

                SQDMULL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);     Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19        16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 size L M                 Rm       1 0 1 1 H 0               Rn             Rd




                Vector variant

                SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);     Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1263
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Ta>              Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                         4S          when size = 01

                                         2D          when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Va>              Is the destination width specifier, encoded in the "size" field. It can have the following values:

                                         S           when size = 01

                                         D           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Vb>              Is the source width specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.



C7-1264                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              ·      size = 11.

                              Restricted to V0-V15 when element size <Ts> is H.

                <Ts>          For the scalar variant: is the element width specifier, encoded in the "size" field. It can have the
                              following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              For the vector variant: is an element size specifier, encoded in the "size" field. It can have the
                              following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       For the scalar variant: is the element index, encoded in the "size:L:H:M" field. It can have the
                              following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              For the vector variant: is the element index encoded in the "size:L:H:M" field. It can have the
                              following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(idxdsize)   operand2 = V[m];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;
                 boolean sat;

                 element2 = SInt(Elem[operand2, index, esize]);
                 for e = 0 to elements-1
                     element1 = SInt(Elem[operand1, e, esize]);
                     (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);
                     Elem[result, e, 2*esize] = product;
                     if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1265
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.249       SQDMULL, SQDMULL2 (vector)

                       Signed saturating doubling multiply long


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 1 0 1 1 1 1 0 size 1                   Rm          1 1 0 1 0 0               Rn               Rd




                       Scalar variant

                       SQDMULL <Va><d>, <Vb><n>, <Vb><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '00' || size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         integer part = 0;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                            0 Q 0 0 1 1 1 0 size 1                   Rm          1 1 0 1 0 0               Rn               Rd




                       Vector variant

                       SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size == '00' || size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.




C7-1266                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Va>          Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vb>          Is the source width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize)   operand1 = Vpart[n, part];
                 bits(datasize)   operand2 = Vpart[m, part];
                 bits(2*datasize) result;
                 integer element1;
                 integer element2;
                 bits(2*esize) product;
                 boolean sat;

                 for e = 0 to elements-1
                     element1 = SInt(Elem[operand1, e, esize]);
                     element2 = SInt(Elem[operand2, e, esize]);
                     (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1267
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, e, 2*esize] = product;
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1268                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.250    SQNEG

                Signed saturating negate


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0                                  Rn             Rd
                        U


                Scalar variant

                SQNEG <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 boolean neg = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0                                  Rn             Rd
                        U


                Vector variant

                SQNEG <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean neg = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               B           when size = 00

                               H           when size = 01

                               S           when size = 10

                               D           when size = 11

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>            Is the number of the SIMD&FP source register, encoded in the "Rn" field.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1269
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              element = SInt(Elem[operand, e, esize]);
                              if neg then
                                   element = -element;
                              else
                                   element = Abs(element);
                              (Elem[result, e, esize], sat) = SignedSatQ(element, esize);
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1270                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.251    SQRDMULH (by element)

                Signed saturating rounding doubling multiply returning high half (by element)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19        16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 size L M                Rm        1 1 0 1 H 0               Rn             Rd
                                                                            op


                Scalar variant

                SQRDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);    Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 boolean round = (op == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19        16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 size L M                Rm        1 1 0 1 H 0               Rn             Rd
                                                                            op


                Vector variant

                SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);    Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1271
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         integer elements = datasize DIV esize;

                         boolean round = (op == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <d>               Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.

                       <Ts>              For the scalar variant: is the element width specifier, encoded in the "size" field. It can have the
                                         following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         For the vector variant: is an element size specifier, encoded in the "size" field. It can have the
                                         following values:

                                         H           when size = 01

                                         S           when size = 10




C7-1272                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <index>       For the scalar variant: is the element index, encoded in the "size:L:H:M" field. It can have the
                              following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                              For the vector variant: is the element index encoded in the "size:L:H:M" field. It can have the
                              following values:

                              H:L:M       when size = 01

                              H:L         when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(idxdsize) operand2 = V[m];
                 bits(datasize) result;
                 integer round_const = if round then 1 << (esize - 1) else 0;
                 integer element1;
                 integer element2;
                 integer product;
                 boolean sat;

                 element2 = SInt(Elem[operand2, index, esize]);
                 for e = 0 to elements-1
                     element1 = SInt(Elem[operand1, e, esize]);
                     product = (2 * element1 * element2) + round_const;
                     // The following only saturates if element1 and element2 equal -(2^(esize-1))
                     (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
                     if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1273
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.252       SQRDMULH (vector)

                       Signed saturating rounding doubling multiply returning high half


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 1 1 1 1 1 0 size 1                   Rm         1 0 1 1 0 1               Rn             Rd
                                  U


                       Scalar variant

                       SQRDMULH <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' || size == '00' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean rounding = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 1 0 1 1 1 0 size 1                   Rm         1 0 1 1 0 1               Rn             Rd
                                  U


                       Vector variant

                       SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' || size == '00' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean rounding = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.



C7-1274                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 00, Q = x.

                              ·      size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer round_const = if rounding then 1 << (esize - 1) else 0;
                 integer element1;
                 integer element2;
                 integer product;
                 boolean sat;

                 for e = 0 to elements-1
                     element1 = SInt(Elem[operand1, e, esize]);
                     element2 = SInt(Elem[operand2, e, esize]);
                     product = (2 * element1 * element2) + round_const;
                     (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
                     if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1275
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.253       SQRSHL

                       Signed saturating rounding shift left (register)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 0 1 1 1 1 0 size 1                  Rm          0 1 0 1 1 1               Rn             Rd
                                  U                                                       R S


                       Scalar variant

                       SQRSHL <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean unsigned = (U == '1');
                         boolean rounding = (R == '1');
                         boolean saturating = (S == '1');
                         if S == '0' && size != '11' then ReservedValue();


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 0 0 1 1 1 0 size 1                  Rm          0 1 0 1 1 1               Rn             Rd
                                  U                                                       R S


                       Vector variant

                       SQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');
                         boolean rounding = (R == '1');
                         boolean saturating = (S == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         D           when size = 11

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.


C7-1276                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;

                 integer round_const = 0;
                 integer shift;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     shift = SInt(Elem[operand2, e, esize]<7:0>);
                     if rounding then
                         round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                     element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                     if saturating then
                         (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                         if sat then FPSR.QC = '1';
                     else
                         Elem[result, e, esize] = element<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1277
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.254       SQRSHRN, SQRSHRN2

                       Signed saturating rounded shift right narrow (immediate)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 1 0 1 1 1 1 1 0            !=0000      immb     1 0 0 1 1 1           Rn     Rd
                                  U                       immh                            op


                       Scalar variant

                       SQRSHRN <Vb><d>, <Va><n>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then ReservedValue();
                         if immh<3> == '1' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = esize;
                         integer elements = 1;
                         integer part = 0;

                         integer shift = (2 * esize) - UInt(immh:immb);
                         boolean round = (op == '1');
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 Q 0 0 1 1 1 1 0            !=0000      immb     1 0 0 1 1 1           Rn     Rd
                                  U                       immh                            op


                       Vector variant

                       SQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3> == '1' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         integer shift = (2 * esize) - UInt(immh:immb);
                         boolean round = (op == '1');
                         boolean unsigned = (U == '1');




C7-1278                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                               ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                2         Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                          64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                          the following values:

                          [absent]    when Q = 0

                          [present]   when Q = 1

                <Vd>      Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>      Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                          8B          when immh = 0001, Q = 0

                          16B         when immh = 0001, Q = 1

                          4H          when immh = 001x, Q = 0

                          8H          when immh = 001x, Q = 1

                          2S          when immh = 01xx, Q = 0

                          4S          when immh = 01xx, Q = 1

                          See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                          It is RESERVED when immh = 1xxx, Q = x.

                <Vn>      Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>      Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                          8H          when immh = 0001

                          4S          when immh = 001x

                          2D          when immh = 01xx

                          See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                          It is RESERVED when immh = 1xxx.

                <Vb>      Is the destination width specifier, encoded in the "immh" field. It can have the following values:

                          B           when immh = 0001

                          H           when immh = 001x

                          S           when immh = 01xx

                          It is RESERVED when:

                          ·      immh = 0000.

                          ·      immh = 1xxx.

                <d>       Is the number of the SIMD&FP destination register, in the "Rd" field.

                <Va>      Is the source width specifier, encoded in the "immh" field. It can have the following values:

                          H           when immh = 0001

                          S           when immh = 001x

                          D           when immh = 01xx

                          It is RESERVED when:

                          ·      immh = 0000.

                          ·      immh = 1xxx.

                <n>       Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <shift>   For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
                          bits, encoded in the "immh:immb" field. It can have the following values:

                          (16-UInt(immh:immb))when immh = 0001



ARM DDI 0487A.e             Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1279
ID121714                                     Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the destination element width in
                                         bits, encoded in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize*2) operand = V[n];
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
                              (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                              if sat then FPSR.QC = '1';

                         Vpart[d, part] = result;




C7-1280                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.255    SQRSHRUN, SQRSHRUN2

                Signed saturating rounded shift right unsigned narrow (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 1 1 1 1 1 1 1 0              !=0000      immb      1 0 0 0 1 1               Rn               Rd
                                                  immh                               op


                Scalar variant

                SQRSHRUN <Vb><d>, <Va><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then ReservedValue();
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 1 0              !=0000      immb      1 0 0 0 1 1               Rn               Rd
                                                  immh                               op


                Vector variant

                SQRSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');


                Assembler symbols

                2              Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                               64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                               the following values:

                               [absent]    when Q = 0



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1281
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B          when immh = 0001, Q = 0

                                         16B         when immh = 0001, Q = 1

                                         4H          when immh = 001x, Q = 0

                                         8H          when immh = 001x, Q = 1

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                         8H          when immh = 0001

                                         4S          when immh = 001x

                                         2D          when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.

                       <Vb>              Is the destination width specifier, encoded in the "immh" field. It can have the following values:

                                         B           when immh = 0001

                                         H           when immh = 001x

                                         S           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <Va>              Is the source width specifier, encoded in the "immh" field. It can have the following values:

                                         H           when immh = 0001

                                         S           when immh = 001x

                                         D           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
                                         bits, encoded in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.


C7-1282                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              For the vector variant: is the right shift amount, in the range 1 to the destination element width in
                              bits, encoded in the "immh:immb" field. It can have the following values:

                              (16-UInt(immh:immb))when immh = 0001

                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when immh = 1xxx.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize*2) operand = V[n];
                 bits(datasize) result;
                 integer round_const = if round then (1 << (shift - 1)) else 0;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
                     (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
                    if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1283
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.256       SQSHL (immediate)

                       Signed saturating shift left (immediate)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 1 0 1 1 1 1 1 0            !=0000      immb     0 1 1 1 0 1           Rn     Rd
                                  U                       immh                        op


                       Scalar variant

                       SQSHL <V><d>, <V><n>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = esize;
                         integer elements = 1;

                         integer shift = UInt(immh:immb) - esize;

                         boolean src_unsigned;
                         boolean dst_unsigned;
                         case op:U of
                              when '00' UnallocatedEncoding();
                              when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                              when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                              when '11' src_unsigned = TRUE;    dst_unsigned = TRUE;


                       Vector


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 Q 0 0 1 1 1 1 0            !=0000      immb     0 1 1 1 0 1           Rn     Rd
                                  U                       immh                        op


                       Vector variant

                       SQSHL <Vd>.<T>, <Vn>.<T>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer shift = UInt(immh:immb) - esize;

                         boolean src_unsigned;
                         boolean dst_unsigned;
                         case op:U of
                              when '00' UnallocatedEncoding();




C7-1284                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                               ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                    when '11' src_unsigned = TRUE;      dst_unsigned = TRUE;


                Assembler symbols

                <V>           Is a width specifier, encoded in the "immh" field. It can have the following values:

                              B           when immh = 0001

                              H           when immh = 001x

                              S           when immh = 01xx

                              D           when immh = 1xxx

                              It is RESERVED when immh = 0000.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              8B          when immh = 0001, Q = 0

                              16B         when immh = 0001, Q = 1

                              4H          when immh = 001x, Q = 0

                              8H          when immh = 001x, Q = 1

                              2S          when immh = 01xx, Q = 0

                              4S          when immh = 01xx, Q = 1

                              2D          when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <shift>       For the scalar variant: is the left shift amount, in the range 0 to the operand width in bits minus 1,
                              encoded in the "immh:immb" field. It can have the following values:

                              (UInt(immh:immb)-8)when immh = 0001

                              (UInt(immh:immb)-16)when immh = 001x

                              (UInt(immh:immb)-32)when immh = 01xx

                              (UInt(immh:immb)-64)when immh = 1xxx

                              It is RESERVED when immh = 0000.

                              For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
                              encoded in the "immh:immb" field. It can have the following values:

                              (UInt(immh:immb)-8)when immh = 0001

                              (UInt(immh:immb)-16)when immh = 001x

                              (UInt(immh:immb)-32)when immh = 01xx

                              (UInt(immh:immb)-64)when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand  = V[n];
                 bits(datasize) result;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1285
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              element = Int(Elem[operand, e, esize], src_unsigned) << shift;
                              (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1286                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.257    SQSHL (register)

                Signed saturating shift left (register)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 size 1                   Rm          0 1 0 0 1 1              Rn             Rd
                        U                                                       R S


                Scalar variant

                SQSHL <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');
                 if S == '0' && size != '11' then ReservedValue();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 0 size 1                   Rm          0 1 0 0 1 1              Rn             Rd
                        U                                                       R S


                Vector variant

                SQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               B             when size = 00

                               H             when size = 01

                               S             when size = 10

                               D             when size = 11

                <d>            Is the number of the SIMD&FP destination register, in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1287
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         integer round_const = 0;
                         integer shift;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              shift = SInt(Elem[operand2, e, esize]<7:0>);
                              if rounding then
                                   round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                              element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                              if saturating then
                                   (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                                   if sat then FPSR.QC = '1';
                              else
                                   Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1288                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.258    SQSHLU

                Signed saturating shift left unsigned (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22         19 18     16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0               !=0000     immb      0 1 1 0 0 1              Rn             Rd
                        U                          immh                       op


                Scalar variant

                SQSHLU <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = UInt(immh:immb) - esize;

                 boolean src_unsigned;
                 boolean dst_unsigned;
                 case op:U of
                     when '00' UnallocatedEncoding();
                     when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                     when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                     when '11' src_unsigned = TRUE;     dst_unsigned = TRUE;


                Vector


                  31 30 29 28 27 26 25 24 23 22         19 18     16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0               !=0000     immb      0 1 1 0 0 1              Rn             Rd
                        U                          immh                       op


                Vector variant

                SQSHLU <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = UInt(immh:immb) - esize;

                 boolean src_unsigned;
                 boolean dst_unsigned;
                 case op:U of
                     when '00' UnallocatedEncoding();




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1289
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                              when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                              when '11' src_unsigned = TRUE;       dst_unsigned = TRUE;


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "immh" field. It can have the following values:

                                         B           when immh = 0001

                                         H           when immh = 001x

                                         S           when immh = 01xx

                                         D           when immh = 1xxx

                                         It is RESERVED when immh = 0000.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B          when immh = 0001, Q = 0

                                         16B         when immh = 0001, Q = 1

                                         4H          when immh = 001x, Q = 0

                                         8H          when immh = 001x, Q = 1

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         2D          when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the left shift amount, in the range 0 to the operand width in bits minus 1,
                                         encoded in the "immh:immb" field. It can have the following values:

                                         (UInt(immh:immb)-8)when immh = 0001

                                         (UInt(immh:immb)-16)when immh = 001x

                                         (UInt(immh:immb)-32)when immh = 01xx

                                         (UInt(immh:immb)-64)when immh = 1xxx

                                         It is RESERVED when immh = 0000.

                                         For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
                                         encoded in the "immh:immb" field. It can have the following values:

                                         (UInt(immh:immb)-8)when immh = 0001

                                         (UInt(immh:immb)-16)when immh = 001x

                                         (UInt(immh:immb)-32)when immh = 01xx

                                         (UInt(immh:immb)-64)when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand     = V[n];
                         bits(datasize) result;



C7-1290                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = Int(Elem[operand, e, esize], src_unsigned) << shift;
                     (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
                    if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1291
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.259       SQSHRN, SQSHRN2

                       Signed saturating shift right narrow (immediate)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 1 0 1 1 1 1 1 0            !=0000      immb     1 0 0 1 0 1           Rn     Rd
                                  U                       immh                            op


                       Scalar variant

                       SQSHRN <Vb><d>, <Va><n>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then ReservedValue();
                         if immh<3> == '1' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = esize;
                         integer elements = 1;
                         integer part = 0;

                         integer shift = (2 * esize) - UInt(immh:immb);
                         boolean round = (op == '1');
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 Q 0 0 1 1 1 1 0            !=0000      immb     1 0 0 1 0 1           Rn     Rd
                                  U                       immh                            op


                       Vector variant

                       SQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3> == '1' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         integer shift = (2 * esize) - UInt(immh:immb);
                         boolean round = (op == '1');
                         boolean unsigned = (U == '1');




C7-1292                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                               ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Assembler symbols

                2         Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                          64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                          the following values:

                          [absent]    when Q = 0

                          [present]   when Q = 1

                <Vd>      Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>      Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                          8B          when immh = 0001, Q = 0

                          16B         when immh = 0001, Q = 1

                          4H          when immh = 001x, Q = 0

                          8H          when immh = 001x, Q = 1

                          2S          when immh = 01xx, Q = 0

                          4S          when immh = 01xx, Q = 1

                          See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                          It is RESERVED when immh = 1xxx, Q = x.

                <Vn>      Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>      Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                          8H          when immh = 0001

                          4S          when immh = 001x

                          2D          when immh = 01xx

                          See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                          It is RESERVED when immh = 1xxx.

                <Vb>      Is the destination width specifier, encoded in the "immh" field. It can have the following values:

                          B           when immh = 0001

                          H           when immh = 001x

                          S           when immh = 01xx

                          It is RESERVED when:

                          ·      immh = 0000.

                          ·      immh = 1xxx.

                <d>       Is the number of the SIMD&FP destination register, in the "Rd" field.

                <Va>      Is the source width specifier, encoded in the "immh" field. It can have the following values:

                          H           when immh = 0001

                          S           when immh = 001x

                          D           when immh = 01xx

                          It is RESERVED when:

                          ·      immh = 0000.

                          ·      immh = 1xxx.

                <n>       Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <shift>   For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
                          bits, encoded in the "immh:immb" field. It can have the following values:

                          (16-UInt(immh:immb))when immh = 0001



ARM DDI 0487A.e             Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1293
ID121714                                     Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the destination element width in
                                         bits, encoded in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize*2) operand = V[n];
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
                              (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                              if sat then FPSR.QC = '1';

                         Vpart[d, part] = result;




C7-1294                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.260    SQSHRUN, SQSHRUN2

                Signed saturating shift right unsigned narrow (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 1 1 1 1 1 1 1 0               !=0000     immb      1 0 0 0 0 1               Rn               Rd
                                                   immh                              op


                Scalar variant

                SQSHRUN <Vb><d>, <Va><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then ReservedValue();
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 1 0               !=0000     immb      1 0 0 0 0 1               Rn               Rd
                                                   immh                              op


                Vector variant

                SQSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');


                Assembler symbols

                2              Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                               64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                               the following values:

                               [absent]     when Q = 0



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1295
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B          when immh = 0001, Q = 0

                                         16B         when immh = 0001, Q = 1

                                         4H          when immh = 001x, Q = 0

                                         8H          when immh = 001x, Q = 1

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                         8H          when immh = 0001

                                         4S          when immh = 001x

                                         2D          when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.

                       <Vb>              Is the destination width specifier, encoded in the "immh" field. It can have the following values:

                                         B           when immh = 0001

                                         H           when immh = 001x

                                         S           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <Va>              Is the source width specifier, encoded in the "immh" field. It can have the following values:

                                         H           when immh = 0001

                                         S           when immh = 001x

                                         D           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
                                         bits, encoded in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.


C7-1296                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              For the vector variant: is the right shift amount, in the range 1 to the destination element width in
                              bits, encoded in the "immh:immb" field. It can have the following values:

                              (16-UInt(immh:immb))when immh = 0001

                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when immh = 1xxx.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize*2) operand = V[n];
                 bits(datasize) result;
                 integer round_const = if round then (1 << (shift - 1)) else 0;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
                     (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
                    if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1297
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.261       SQSUB

                       Signed saturating subtract


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 0 1 1 1 1 0 size 1                   Rm         0 0 1 0 1 1               Rn             Rd
                                  U


                       Scalar variant

                       SQSUB <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 0 0 1 1 1 0 size 1                   Rm         0 0 1 0 1 1               Rn             Rd
                                  U


                       Vector variant

                       SQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         D           when size = 11

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.



C7-1298                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer diff;
                 boolean sat;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     diff = element1 - element2;
                     (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
                    if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1299
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.262       SQXTN, SQXTN2

                       Signed saturating extract narrow


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 1 0 1 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0                                   Rn               Rd
                                  U


                       Scalar variant

                       SQXTN <Vb><d>, <Va><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer part = 0;
                         integer elements = 1;

                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 Q 0 0 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0                                   Rn               Rd
                                  U


                       Vector variant

                       SQXTN{2} <Vd>.<Tb>, <Vn>.<Ta>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.



C7-1300                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vb>          Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Va>          Is the source width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 00

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when size = 11.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand = V[n];
                 bits(datasize) result;
                 bits(2*esize) element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = Elem[operand, e, 2*esize];
                     (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
                     if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1301
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.263       SQXTUN, SQXTUN2

                       Signed saturating extract unsigned narrow


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 1 1 1 1 1 1 0 size 1 0 0 0 0 1 0 0 1 0 1 0                                   Rn               Rd




                       Scalar variant

                       SQXTUN <Vb><d>, <Va><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer part = 0;
                         integer elements = 1;


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 Q 1 0 1 1 1 0 size 1 0 0 0 0 1 0 0 1 0 1 0                                   Rn               Rd




                       Vector variant

                       SQXTUN{2} <Vd>.<Tb>, <Vn>.<Ta>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0




C7-1302                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vb>          Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Va>          Is the source width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 00

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when size = 11.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand = V[n];
                 bits(datasize) result;
                 bits(2*esize) element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = Elem[operand, e, 2*esize];
                     (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);
                    if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1303
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.264       SRHADD

                       Signed rounding halving add




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 1                  Rm         0 0 0 1 0 1               Rn              Rd
                                  U


                       Three registers of the same type variant

                       SRHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;

                         V[d] = result;




C7-1304                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.265    SRI

                Shift right and insert (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0                !=0000     immb      0 1 0 0 0 1              Rn             Rd
                                                    immh


                Scalar variant

                SRI <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);


                Vector


                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0                !=0000     immb      0 1 0 0 0 1              Rn             Rd
                                                    immh


                Vector variant

                SRI <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);


                Assembler symbols

                <V>              Is a width specifier, encoded in the "immh" field. It can have the following values:

                                 D           when immh = 1xxx

                                 It is RESERVED when immh = 0xxx.

                <d>              Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>              Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>             Is the name of the SIMD&FP destination register, encoded in the "Rd" field.


ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1305
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2 = V[d];
                         bits(datasize) result;
                         bits(esize) mask = LSR(Ones(esize), shift);
                         bits(esize) shifted;

                         for e = 0 to elements-1
                              shifted = LSR(Elem[operand, e, esize], shift);
                              Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
                         V[d] = result;




C7-1306                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.266    SRSHL

                Signed rounding shift left (register)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 size 1                  Rm          0 1 0 1 0 1              Rn             Rd
                        U                                                      R S


                Scalar variant

                SRSHL <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');
                 if S == '0' && size != '11' then ReservedValue();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 0 size 1                  Rm          0 1 0 1 0 1              Rn             Rd
                        U                                                      R S


                Vector variant

                SRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              D             when size = 11

                              It is RESERVED when:

                              ·       size = 0x.

                              ·       size = 10.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1307
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         integer round_const = 0;
                         integer shift;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              shift = SInt(Elem[operand2, e, esize]<7:0>);
                              if rounding then
                                   round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                              element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                              if saturating then
                                   (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                                   if sat then FPSR.QC = '1';
                              else
                                   Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1308                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.267    SRSHR

                Signed rounding shift right (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 0             !=0000     immb      0 0 1 0 0 1              Rn             Rd
                        U                        immh                    o1 o0


                Scalar variant

                SRSHR <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 0             !=0000     immb      0 0 1 0 0 1              Rn             Rd
                        U                        immh                    o1 o0


                Vector variant

                SRSHR <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "immh" field. It can have the following values:

                              D            when immh = 1xxx

                              It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1309
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1310                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.268    SRSRA

                Signed rounding shift right and accumulate (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22        19 18     16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 0              !=0000     immb      0 0 1 1 0 1              Rn             Rd
                        U                         immh                    o1 o0


                Scalar variant

                SRSRA <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22        19 18     16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 0              !=0000     immb      0 0 1 1 0 1              Rn             Rd
                        U                         immh                    o1 o0


                Vector variant

                SRSRA <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "immh" field. It can have the following values:

                              D            when immh = 1xxx

                              It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1311
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1312                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.269    SSHL

                Signed shift left (register)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 0 size 1                   Rm          0 1 0 0 0 1               Rn             Rd
                        U                                                        R S


                Scalar variant

                SSHL <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');
                 if S == '0' && size != '11' then ReservedValue();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 0 size 1                   Rm          0 1 0 0 0 1               Rn             Rd
                        U                                                        R S


                Vector variant

                SSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');


                Assembler symbols

                <V>             Is a width specifier, encoded in the "size" field. It can have the following values:

                                D            when size = 11

                                It is RESERVED when:

                                ·       size = 0x.

                                ·       size = 10.

                <d>             Is the number of the SIMD&FP destination register, in the "Rd" field.


ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1313
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         integer round_const = 0;
                         integer shift;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              shift = SInt(Elem[operand2, e, esize]<7:0>);
                              if rounding then
                                   round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                              element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                              if saturating then
                                   (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                                   if sat then FPSR.QC = '1';
                              else
                                   Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1314                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.270    SSHLL, SSHLL2

                Signed shift left long (immediate)

                This instruction is used by the alias SXTL. See the Alias conditions table for details of when each alias is preferred.




                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 1 0                !=0000     immb      1 0 1 0 0 1               Rn               Rd
                         U                          immh


                Vector variant

                SSHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = UInt(immh:immb) - esize;
                 boolean unsigned = (U == '1');


                Alias conditions


                                      Alias                   is preferred when

                                      SXTL                     immb == '000' && BitCount(immh) == 1



                Assembler symbols

                2               Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                the following values:

                                [absent]     when Q = 0

                                [present]    when Q = 1

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>            Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                8H           when immh = 0001

                                4S           when immh = 001x

                                2D           when immh = 01xx

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                It is RESERVED when immh = 1xxx.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.




ARM DDI 0487A.e                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1315
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <shift>           Is the left shift amount, in the range 0 to the source element width in bits minus 1, encoded in the
                                         "immh:immb" field. It can have the following values:

                                         (UInt(immh:immb)-8)when immh = 0001

                                         (UInt(immh:immb)-16)when immh = 001x

                                         (UInt(immh:immb)-32)when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = Vpart[n, part];
                         bits(datasize*2) result;
                         integer element;

                         for e = 0 to elements-1
                              element = Int(Elem[operand, e, esize], unsigned) << shift;
                              Elem[result, e, 2*esize] = element<2*esize-1:0>;

                         V[d] = result;




C7-1316                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.271    SSHR

                Signed shift right (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 0               !=0000     immb      0 0 0 0 0 1              Rn             Rd
                        U                          immh                    o1 o0


                Scalar variant

                SSHR <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 0               !=0000     immb      0 0 0 0 0 1              Rn             Rd
                        U                          immh                    o1 o0


                Vector variant

                SSHR <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>             Is a width specifier, encoded in the "immh" field. It can have the following values:

                                D           when immh = 1xxx

                                It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1317
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1318                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.272    SSRA

                Signed shift right and accumulate (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 0 1 1 1 1 1 0               !=0000     immb      0 0 0 1 0 1              Rn             Rd
                        U                          immh                    o1 o0


                Scalar variant

                SSRA <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 0 0 1 1 1 1 0               !=0000     immb      0 0 0 1 0 1              Rn             Rd
                        U                          immh                    o1 o0


                Vector variant

                SSRA <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>             Is a width specifier, encoded in the "immh" field. It can have the following values:

                                D           when immh = 1xxx

                                It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1319
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1320                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.273    SSUBL, SSUBL2

                Signed subtract long




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 size 1                   Rm          0 0 1 0 0 0               Rn               Rd
                        U                                                    o1


                Three registers, not all the same type variant

                SSUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2              Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                               64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                               the following values:

                               [absent]    when Q = 0

                               [present]   when Q = 1

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>           Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                               8H          when size = 00

                               4S          when size = 01

                               2D          when size = 10

                               It is RESERVED when size = 11.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1

                               It is RESERVED when size = 11, Q = x.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1321
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                         V[d] = result;




C7-1322                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.274    SSUBW, SSUBW2

                Signed subtract wide




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 size 1                   Rm          0 0 1 1 0 0               Rn               Rd
                        U                                                    o1


                Three registers, not all the same type variant

                SSUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2              Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                               64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                               the following values:

                               [absent]    when Q = 0

                               [present]   when Q = 1

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>           Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                               8H          when size = 00

                               4S          when size = 01

                               2D          when size = 10

                               It is RESERVED when size = 11.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Tb>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1323
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(2*datasize) operand1 = V[n];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, 2*esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                         V[d] = result;




C7-1324                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.275    ST1 (multiple structures)

                Store multiple 1-element structures from one, two three or four registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15         12 11 10 9               5 4          0
                  0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 x x 1 x size                                Rn             Rt
                                               L                      opcode


                One register variant

                Applies when opcode = 0111.

                ST1 { <Vt>.<T> }, [<Xn|SP>]


                Two registers variant

                Applies when opcode = 1010.

                ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]


                Three registers variant

                Applies when opcode = 0110.

                ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]


                Four registers variant

                Applies when opcode = 0010.

                ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15        12 11 10 9               5 4          0
                  0 Q 0 0 1 1 0 0 1 0 0                   Rm         x x 1 x size             Rn             Rt
                                               L                      opcode


                One register, immediate offset variant

                Applies when Rm = 11111 && opcode = 0111.

                ST1 { <Vt>.<T> }, [<Xn|SP>], <imm>


                One register, register offset variant

                Applies when Rm != 11111 && opcode = 0111.

                ST1 { <Vt>.<T> }, [<Xn|SP>], <Xm>


                Two registers, immediate offset variant

                Applies when Rm = 11111 && opcode = 1010.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1325
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>


                       Two registers, register offset variant

                       Applies when Rm != 11111 && opcode = 1010.

                       ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>


                       Three registers, immediate offset variant

                       Applies when Rm = 11111 && opcode = 0110.

                       ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>


                       Three registers, register offset variant

                       Applies when Rm != 11111 && opcode = 0110.

                       ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>


                       Four registers, immediate offset variant

                       Applies when Rm = 11111 && opcode = 0010.

                       ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>


                       Four registers, register offset variant

                       Applies when Rm != 11111 && opcode = 0010.

                       ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         1D          when size = 11, Q = 0

                                         2D          when size = 11, Q = 1

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <Vt4>             Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.




C7-1326                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <imm>         For the one register, immediate offset variant: is the post-index immediate offset, encoded in the "Q"
                              field. It can have the following values:

                              #8           when Q = 0

                              #16          when Q = 1

                              For the two registers, immediate offset variant: is the post-index immediate offset, encoded in the
                              "Q" field. It can have the following values:

                              #16          when Q = 0

                              #32          when Q = 1

                              For the three registers, immediate offset variant: is the post-index immediate offset, encoded in the
                              "Q" field. It can have the following values:

                              #24          when Q = 0

                              #48          when Q = 1

                              For the four registers, immediate offset variant: is the post-index immediate offset, encoded in the
                              "Q" field. It can have the following values:

                              #32          when Q = 0

                              #64          when Q = 1

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << UInt(size);
                 integer elements = datasize DIV esize;

                 integer rpt;    // number of iterations
                 integer selem;  // structure elements

                 case opcode of
                    when '0000' rpt = 1; selem = 4;         // LD/ST4 (4 registers)
                    when '0010' rpt = 4; selem = 1;         // LD/ST1 (4 registers)
                    when '0100' rpt = 1; selem = 3;         // LD/ST3 (3 registers)
                    when '0110' rpt = 3; selem = 1;         // LD/ST1 (3 registers)
                    when '0111' rpt = 1; selem = 1;         // LD/ST1 (1 register)
                    when '1000' rpt = 1; selem = 2;         // LD/ST2 (2 registers)
                    when '1010' rpt = 2; selem = 1;         // LD/ST1 (2 registers)
                    otherwise UnallocatedEncoding();

                 // .1D format only permitted with LD1 & ST1
                 if size:Q == '110' && selem != 1 then ReservedValue();


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(datasize) rval;
                 integer e, r, s, tt;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1327
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         offs = Zeros();
                         for r = 0 to rpt-1
                              for e = 0 to elements-1
                                   tt = (t + r) MOD 32;
                                   for s = 0 to selem-1
                                       rval = V[tt];
                                       if memop == MemOp_LOAD then
                                           Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                           V[tt] = rval;
                                       else // memop == MemOp_STORE
                                           Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                                       offs = offs + ebytes;
                                       tt = (tt + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1328                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.276    ST1 (single structure)

                Store single 1-element structure from one lane of one register


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 0 0 0 0 0 0 0 0 x x 0 S size                                Rn             Rt
                                               L R                    opcode


                8-bit variant

                Applies when opcode = 000.

                ST1 { <Vt>.B }[<index>], [<Xn|SP>]


                16-bit variant

                Applies when opcode = 010 && size = x0.

                ST1 { <Vt>.H }[<index>], [<Xn|SP>]


                32-bit variant

                Applies when opcode = 100 && size = 00.

                ST1 { <Vt>.S }[<index>], [<Xn|SP>]


                64-bit variant

                Applies when opcode = 100 && S = 0 && size = 01.

                ST1 { <Vt>.D }[<index>], [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 1 0 0                  Rm          x x 0 S size             Rn             Rt
                                               L R                    opcode


                8-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 000.

                ST1 { <Vt>.B }[<index>], [<Xn|SP>], #1


                8-bit, register offset variant

                Applies when Rm != 11111 && opcode = 000.

                ST1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>


                16-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 010 && size = x0.



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1329
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       ST1 { <Vt>.H }[<index>], [<Xn|SP>], #2


                       16-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 010 && size = x0.

                       ST1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>


                       32-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 100 && size = 00.

                       ST1 { <Vt>.S }[<index>], [<Xn|SP>], #4


                       32-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 100 && size = 00.

                       ST1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>


                       64-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 100 && S = 0 && size = 01.

                       ST1 { <Vt>.D }[<index>], [<Xn|SP>], #8


                       64-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 100 && S = 0 && size = 01.

                       ST1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <index>           For the 8-bit variant: is the element index, encoded in "Q:S:size".

                                         For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                                         For the 32-bit variant: is the element index, encoded in "Q:S".

                                         For the 64-bit variant: is the element index, encoded in "Q".

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate
                                   if L == '0' || S == '1' then UnallocatedEncoding();
                                   scale = UInt(size);



C7-1330                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         replicate = TRUE;
                    when 0
                         index = UInt(Q:S:size);         // B[0-15]
                    when 1
                         if size<0> == '1' then UnallocatedEncoding();
                         index = UInt(Q:S:size<1>);      // H[0-7]
                    when 2
                         if size<1> == '1' then UnallocatedEncoding();
                         if size<0> == '0' then
                             index = UInt(Q:S);          // S[0-3]
                         else
                             if S == '1' then UnallocatedEncoding();
                             index = UInt(Q);            // D[0-1]
                             scale = 3;

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(128) rval;
                 bits(esize) element;
                 integer s;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                         element = Mem[address + offs, ebytes, AccType_VEC];
                         // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                         rval = V[t];
                         if memop == MemOp_LOAD then
                             // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                         else // memop == MemOp_STORE
                             // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                         offs = X[m];
                    if n == 31 then
                         SP[] = address + offs;
                    else
                         X[n] = address + offs;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1331
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.277       ST2 (multiple structures)

                       Store multiple 2-element structures from two registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15           12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 size                                 Rn              Rt
                                                        L                       opcode


                       No offset variant

                       ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]


                       Decode for this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15       12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 1 0 0                    Rm        1 0 0 0 size              Rn              Rt
                                                        L                       opcode


                       Immediate offset variant

                       Applies when Rm = 11111.

                       ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>


                       Register offset variant

                       Applies when Rm != 11111.

                       ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1



C7-1332                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2D           when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>         Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

                              #16          when Q = 0

                              #32          when Q = 1

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << UInt(size);
                 integer elements = datasize DIV esize;

                 integer rpt;    // number of iterations
                 integer selem;  // structure elements

                 case opcode of
                    when '0000' rpt = 1; selem = 4;        // LD/ST4 (4 registers)
                    when '0010' rpt = 4; selem = 1;        // LD/ST1 (4 registers)
                    when '0100' rpt = 1; selem = 3;        // LD/ST3 (3 registers)
                    when '0110' rpt = 3; selem = 1;        // LD/ST1 (3 registers)
                    when '0111' rpt = 1; selem = 1;        // LD/ST1 (1 register)
                    when '1000' rpt = 1; selem = 2;        // LD/ST2 (2 registers)
                    when '1010' rpt = 2; selem = 1;        // LD/ST1 (2 registers)
                    otherwise UnallocatedEncoding();

                 // .1D format only permitted with LD1 & ST1
                 if size:Q == '110' && selem != 1 then ReservedValue();


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(datasize) rval;
                 integer e, r, s, tt;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 for r = 0 to rpt-1
                     for e = 0 to elements-1
                         tt = (t + r) MOD 32;
                         for s = 0 to selem-1
                             rval = V[tt];
                             if memop == MemOp_LOAD then
                                 Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                 V[tt] = rval;
                             else // memop == MemOp_STORE
                                 Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                             offs = offs + ebytes;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1333
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                       tt = (tt + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1334                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.278    ST2 (single structure)

                Store single 2-element structure from one lane of two registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 0 0 1 0 0 0 0 0 x x 0 S size                                Rn             Rt
                                               L R                    opcode


                8-bit variant

                Applies when opcode = 000.

                ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]


                16-bit variant

                Applies when opcode = 010 && size = x0.

                ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]


                32-bit variant

                Applies when opcode = 100 && size = 00.

                ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]


                64-bit variant

                Applies when opcode = 100 && S = 0 && size = 01.

                ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 1 0 1                  Rm          x x 0 S size             Rn             Rt
                                               L R                    opcode


                8-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 000.

                ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2


                8-bit, register offset variant

                Applies when Rm != 11111 && opcode = 000.

                ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>


                16-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 010 && size = x0.



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1335
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4


                       16-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 010 && size = x0.

                       ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>


                       32-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 100 && size = 00.

                       ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8


                       32-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 100 && size = 00.

                       ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>


                       64-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 100 && S = 0 && size = 01.

                       ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16


                       64-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 100 && S = 0 && size = 01.

                       ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <index>           For the 8-bit variant: is the element index, encoded in "Q:S:size".

                                         For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                                         For the 32-bit variant: is the element index, encoded in "Q:S".

                                         For the 64-bit variant: is the element index, encoded in "Q".

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;

                         case scale of
                              when 3
                                   // load and replicate



C7-1336                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         if L == '0' || S == '1' then UnallocatedEncoding();
                         scale = UInt(size);
                         replicate = TRUE;
                    when 0
                         index = UInt(Q:S:size);        // B[0-15]
                    when 1
                         if size<0> == '1' then UnallocatedEncoding();
                         index = UInt(Q:S:size<1>);     // H[0-7]
                    when 2
                         if size<1> == '1' then UnallocatedEncoding();
                         if size<0> == '0' then
                            index = UInt(Q:S);           // S[0-3]
                         else
                            if S == '1' then UnallocatedEncoding();
                            index = UInt(Q);             // D[0-1]
                            scale = 3;

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(128) rval;
                 bits(esize) element;
                 integer s;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                         element = Mem[address + offs, ebytes, AccType_VEC];
                         // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                         rval = V[t];
                         if memop == MemOp_LOAD then
                             // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                         else // memop == MemOp_STORE
                             // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then
                         offs = X[m];
                    if n == 31 then




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1337
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1338                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.279    ST3 (multiple structures)

                Store multiple 3-element structures from three registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15          12 11 10 9                 5 4          0
                  0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 size                                   Rn             Rt
                                               L                       opcode


                No offset variant

                ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]


                Decode for this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15       12 11 10 9                 5 4          0
                  0 Q 0 0 1 1 0 0 1 0 0                    Rm        0 1 0 0 size                Rn             Rt
                                               L                       opcode


                Immediate offset variant

                Applies when Rm = 11111.

                ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>


                Register offset variant

                Applies when Rm != 11111.

                ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>           Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1339
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         2D           when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

                                         #24          when Q = 0

                                         #48          when Q = 1

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << UInt(size);
                         integer elements = datasize DIV esize;

                         integer rpt;       // number of iterations
                         integer selem;     // structure elements

                         case opcode of
                              when '0000' rpt = 1; selem = 4;         // LD/ST4 (4 registers)
                              when '0010' rpt = 4; selem = 1;         // LD/ST1 (4 registers)
                              when '0100' rpt = 1; selem = 3;         // LD/ST3 (3 registers)
                              when '0110' rpt = 3; selem = 1;         // LD/ST1 (3 registers)
                              when '0111' rpt = 1; selem = 1;         // LD/ST1 (1 register)
                              when '1000' rpt = 1; selem = 2;         // LD/ST2 (2 registers)
                              when '1010' rpt = 2; selem = 1;         // LD/ST1 (2 registers)
                              otherwise UnallocatedEncoding();

                         // .1D format only permitted with LD1 & ST1
                         if size:Q == '110' && selem != 1 then ReservedValue();


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(datasize) rval;
                         integer e, r, s, tt;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         offs = Zeros();
                         for r = 0 to rpt-1
                              for e = 0 to elements-1
                                   tt = (t + r) MOD 32;
                                   for s = 0 to selem-1
                                       rval = V[tt];
                                       if memop == MemOp_LOAD then
                                            Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                            V[tt] = rval;
                                       else // memop == MemOp_STORE



C7-1340                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                           C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                        C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                            offs = offs + ebytes;
                            tt = (tt + 1) MOD 32;

                 if wback then
                    if m != 31 then
                        offs = X[m];
                    if n == 31 then
                        SP[] = address + offs;
                    else
                        X[n] = address + offs;




ARM DDI 0487A.e                Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1341
ID121714                                      Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.280       ST3 (single structure)

                       Store single 3-element structure from one lane of three registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15      13 12 11 10 9       5 4     0
                            0 Q 0 0 1 1 0 1 0 0 0 0 0 0 0 0 x x 1 S size                            Rn     Rt
                                                       L R                   opcode


                       8-bit variant

                       Applies when opcode = 001.

                       ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]


                       16-bit variant

                       Applies when opcode = 011 && size = x0.

                       ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]


                       32-bit variant

                       Applies when opcode = 101 && size = 00.

                       ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]


                       64-bit variant

                       Applies when opcode = 101 && S = 0 && size = 01.

                       ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20          16 15      13 12 11 10 9       5 4     0
                            0 Q 0 0 1 1 0 1 1 0 0                 Rm         x x 1 S size           Rn     Rt
                                                       L R                   opcode


                       8-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 001.

                       ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3


                       8-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 001.

                       ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>


                       16-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 011 && size = x0.



C7-1342                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6


                16-bit, register offset variant

                Applies when Rm != 11111 && opcode = 011 && size = x0.

                ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>


                32-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 101 && size = 00.

                ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12


                32-bit, register offset variant

                Applies when Rm != 11111 && opcode = 101 && size = 00.

                ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>


                64-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 101 && S = 0 && size = 01.

                ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24


                64-bit, register offset variant

                Applies when Rm != 11111 && opcode = 101 && S = 0 && size = 01.

                ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 boolean wback = TRUE;


                Assembler symbols

                <Vt>          Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Vt3>         Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                <index>       For the 8-bit variant: is the element index, encoded in "Q:S:size".

                              For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                              For the 32-bit variant: is the element index, encoded in "Q:S".

                              For the 64-bit variant: is the element index, encoded in "Q".

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 integer scale = UInt(opcode<2:1>);
                 integer selem = UInt(opcode<0>:R) + 1;
                 boolean replicate = FALSE;
                 integer index;

                 case scale of



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1343
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              when 3
                                   // load and replicate
                                   if L == '0' || S == '1' then UnallocatedEncoding();
                                   scale = UInt(size);
                                   replicate = TRUE;
                              when 0
                                   index = UInt(Q:S:size);          // B[0-15]
                              when 1
                                   if size<0> == '1' then UnallocatedEncoding();
                                   index = UInt(Q:S:size<1>);       // H[0-7]
                              when 2
                                   if size<1> == '1' then UnallocatedEncoding();
                                   if size<0> == '0' then
                                       index = UInt(Q:S);           // S[0-3]
                                   else
                                       if S == '1' then UnallocatedEncoding();
                                       index = UInt(Q);             // D[0-1]
                                       scale = 3;

                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer esize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(64) offs;
                         bits(128) rval;
                         bits(esize) element;
                         integer s;
                         constant integer ebytes = esize DIV 8;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         offs = Zeros();
                         if replicate then
                              // load and replicate to all elements
                              for s = 0 to selem-1
                                   element = Mem[address + offs, ebytes, AccType_VEC];
                                   // replicate to fill 128- or 64-bit register
                                   V[t] = Replicate(element, datasize DIV esize);
                                   offs = offs + ebytes;
                                   t = (t + 1) MOD 32;
                         else
                              // load/store one element per register
                              for s = 0 to selem-1
                                   rval = V[t];
                                   if memop == MemOp_LOAD then
                                       // insert into one lane of 128-bit register
                                       Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                                       V[t] = rval;
                                   else // memop == MemOp_STORE
                                       // extract from one lane of 128-bit register
                                       Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                                   offs = offs + ebytes;
                                   t = (t + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then



C7-1344                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                         C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                      C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       SP[] = address + offs;
                   else
                       X[n] = address + offs;




ARM DDI 0487A.e               Copyright © 2013, 2014 ARM Limited. All rights reserved.                             C7-1345
ID121714                                     Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.281       ST4 (multiple structures)

                       Store multiple 4-element structures from four registers


                       No offset


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15           12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 size                                 Rn              Rt
                                                        L                       opcode


                       No offset variant

                       ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]


                       Decode for this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = integer UNKNOWN;
                         boolean wback = FALSE;


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20              16 15       12 11 10 9             5 4             0
                            0 Q 0 0 1 1 0 0 1 0 0                    Rm        0 0 0 0 size              Rn              Rt
                                                        L                       opcode


                       Immediate offset variant

                       Applies when Rm = 11111.

                       ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>


                       Register offset variant

                       Applies when Rm != 11111.

                       ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1



C7-1346                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              2D           when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vt2>         Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                <Vt3>         Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                <Vt4>         Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>         Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

                              #32          when Q = 0

                              #64          when Q = 1

                <Xm>          Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                              field.


                Shared decode for all encodings

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << UInt(size);
                 integer elements = datasize DIV esize;

                 integer rpt;    // number of iterations
                 integer selem;  // structure elements

                 case opcode of
                    when '0000' rpt = 1; selem = 4;        // LD/ST4 (4 registers)
                    when '0010' rpt = 4; selem = 1;        // LD/ST1 (4 registers)
                    when '0100' rpt = 1; selem = 3;        // LD/ST3 (3 registers)
                    when '0110' rpt = 3; selem = 1;        // LD/ST1 (3 registers)
                    when '0111' rpt = 1; selem = 1;        // LD/ST1 (1 register)
                    when '1000' rpt = 1; selem = 2;        // LD/ST2 (2 registers)
                    when '1010' rpt = 2; selem = 1;        // LD/ST1 (2 registers)
                    otherwise UnallocatedEncoding();

                 // .1D format only permitted with LD1 & ST1
                 if size:Q == '110' && selem != 1 then ReservedValue();


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(datasize) rval;
                 integer e, r, s, tt;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 for r = 0 to rpt-1
                     for e = 0 to elements-1
                         tt = (t + r) MOD 32;
                         for s = 0 to selem-1
                             rval = V[tt];
                             if memop == MemOp_LOAD then
                                 Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1347
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                           V[tt] = rval;
                                       else // memop == MemOp_STORE
                                           Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
                                       offs = offs + ebytes;
                                       tt = (tt + 1) MOD 32;

                         if wback then
                              if m != 31 then
                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1348                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.           ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                  ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.282    ST4 (single structure)

                Store single 4-element structure from one lane of four registers


                No offset


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15       13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 0 0 1 0 0 0 0 0 x x 1 S size                                Rn             Rt
                                               L R                    opcode


                8-bit variant

                Applies when opcode = 001.

                ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]


                16-bit variant

                Applies when opcode = 011 && size = x0.

                ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]


                32-bit variant

                Applies when opcode = 101 && size = 00.

                ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]


                64-bit variant

                Applies when opcode = 101 && S = 0 && size = 01.

                ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]


                Decode for all variants of this encoding

                 integer t = UInt(Rt);
                 integer n = UInt(Rn);
                 integer m = integer UNKNOWN;
                 boolean wback = FALSE;


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15     13 12 11 10 9               5 4          0
                   0 Q 0 0 1 1 0 1 1 0 1                  Rm          x x 1 S size             Rn             Rt
                                               L R                    opcode


                8-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 001.

                ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4


                8-bit, register offset variant

                Applies when Rm != 11111 && opcode = 001.

                ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>


                16-bit, immediate offset variant

                Applies when Rm = 11111 && opcode = 011 && size = x0.



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1349
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8


                       16-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 011 && size = x0.

                       ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>


                       32-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 101 && size = 00.

                       ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16


                       32-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 101 && size = 00.

                       ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>


                       64-bit, immediate offset variant

                       Applies when Rm = 11111 && opcode = 101 && S = 0 && size = 01.

                       ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32


                       64-bit, register offset variant

                       Applies when Rm != 11111 && opcode = 101 && S = 0 && size = 01.

                       ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>


                       Decode for all variants of this encoding

                         integer t = UInt(Rt);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         boolean wback = TRUE;


                       Assembler symbols

                       <Vt>              Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Vt2>             Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

                       <Vt3>             Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

                       <Vt4>             Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

                       <index>           For the 8-bit variant: is the element index, encoded in "Q:S:size".

                                         For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".

                                         For the 32-bit variant: is the element index, encoded in "Q:S".

                                         For the 64-bit variant: is the element index, encoded in "Q".

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <Xm>              Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
                                         field.


                       Shared decode for all encodings

                         integer scale = UInt(opcode<2:1>);
                         integer selem = UInt(opcode<0>:R) + 1;
                         boolean replicate = FALSE;
                         integer index;



C7-1350                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                 case scale of
                    when 3
                         // load and replicate
                         if L == '0' || S == '1' then UnallocatedEncoding();
                         scale = UInt(size);
                         replicate = TRUE;
                    when 0
                         index = UInt(Q:S:size);        // B[0-15]
                    when 1
                         if size<0> == '1' then UnallocatedEncoding();
                         index = UInt(Q:S:size<1>);     // H[0-7]
                    when 2
                         if size<1> == '1' then UnallocatedEncoding();
                         if size<0> == '0' then
                            index = UInt(Q:S);           // S[0-3]
                         else
                            if S == '1' then UnallocatedEncoding();
                            index = UInt(Q);             // D[0-1]
                            scale = 3;

                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = if Q == '1' then 128 else 64;
                 integer esize = 8 << scale;


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(64) offs;
                 bits(128) rval;
                 bits(esize) element;
                 integer s;
                 constant integer ebytes = esize DIV 8;

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 offs = Zeros();
                 if replicate then
                    // load and replicate to all elements
                    for s = 0 to selem-1
                         element = Mem[address + offs, ebytes, AccType_VEC];
                         // replicate to fill 128- or 64-bit register
                         V[t] = Replicate(element, datasize DIV esize);
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;
                 else
                    // load/store one element per register
                    for s = 0 to selem-1
                         rval = V[t];
                         if memop == MemOp_LOAD then
                             // insert into one lane of 128-bit register
                             Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
                             V[t] = rval;
                         else // memop == MemOp_STORE
                             // extract from one lane of 128-bit register
                             Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
                         offs = offs + ebytes;
                         t = (t + 1) MOD 32;

                 if wback then
                    if m != 31 then



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1351
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   offs = X[m];
                              if n == 31 then
                                   SP[] = address + offs;
                              else
                                   X[n] = address + offs;




C7-1352                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                   C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                               C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.283    STNP (SIMD&FP)

                Store pair of SIMD&FP registers, with non-temporal hint




                  31 30 29 28 27 26 25 24 23 22 21                      15 14           10 9              5 4             0
                  opc 1 0 1 1 0 0 0 0                       imm7                Rt2               Rn             Rt
                                                L


                32-bit variant

                Applies when opc = 00.

                STNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]


                64-bit variant

                Applies when opc = 01.

                STNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]


                128-bit variant

                Applies when opc = 10.

                STNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]


                Decode for all variants of this encoding

                 boolean wback   = FALSE;
                 boolean postindex = FALSE;


                Assembler symbols

                <Dt1>           Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Dt2>           Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                <Qt1>           Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Qt2>           Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                <St1>           Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                <St2>           Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                <Xn|SP>         Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <imm>           For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
                                to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                                For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
                                to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

                                For the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range
                                -1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2);
                 AccType acctype = AccType_VECSTREAM;



ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1353
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                         if opc == '11' then UnallocatedEncoding();
                         integer scale = 2 + UInt(opc);
                         integer datasize = 8 << scale;
                         bits(64) offset = LSL(SignExtend(imm7, 64), scale);


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(datasize) data1;
                         bits(datasize) data2;
                         constant integer dbytes = datasize DIV 8;
                         boolean rt_unknown = FALSE;

                         if memop == MemOp_LOAD && t == t2 then
                              Constraint c = ConstrainUnpredictable();
                              assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                              case c of
                                   when Constraint_UNKNOWN     rt_unknown = TRUE;      // result is UNKNOWN
                                   when Constraint_UNDEF       UnallocatedEncoding();
                                   when Constraint_NOP         EndOfInstruction();

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   data1 = V[t];
                                   data2 = V[t2];
                                   Mem[address + 0      , dbytes, acctype] = data1;
                                   Mem[address + dbytes, dbytes, acctype] = data2;

                              when MemOp_LOAD
                                   data1 = Mem[address + 0      , dbytes, acctype];
                                   data2 = Mem[address + dbytes, dbytes, acctype];
                                   if rt_unknown then
                                       data1 = bits(datasize) UNKNOWN;
                                       data2 = bits(datasize) UNKNOWN;
                                   V[t]   = data1;
                                   V[t2] = data2;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C7-1354                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.            ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                   ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.284    STP (SIMD&FP)

                Store pair of SIMD&FP registers


                Post-index


                  31 30 29 28 27 26 25 24 23 22 21                15 14            10 9             5 4          0
                   opc 1 0 1 1 0 0 1 0                 imm7                 Rt2             Rn             Rt
                                             L


                32-bit variant

                Applies when opc = 00.

                STP <St1>, <St2>, [<Xn|SP>], #<imm>


                64-bit variant

                Applies when opc = 01.

                STP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>


                128-bit variant

                Applies when opc = 10.

                STP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>


                Decode for all variants of this encoding

                 boolean wback  = TRUE;
                 boolean postindex = TRUE;


                Pre-index


                  31 30 29 28 27 26 25 24 23 22 21                15 14            10 9             5 4          0
                   opc 1 0 1 1 0 1 1 0                 imm7                 Rt2             Rn             Rt
                                             L


                32-bit variant

                Applies when opc = 00.

                STP <St1>, <St2>, [<Xn|SP>, #<imm>]!


                64-bit variant

                Applies when opc = 01.

                STP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!


                128-bit variant

                Applies when opc = 10.

                STP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!


                Decode for all variants of this encoding

                 boolean wback  = TRUE;
                 boolean postindex = FALSE;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                             C7-1355
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Signed offset


                           31 30 29 28 27 26 25 24 23 22 21                     15 14            10 9           5 4             0
                            opc 1 0 1 1 0 1 0 0                    imm7                   Rt2            Rn              Rt
                                                         L


                       32-bit variant

                       Applies when opc = 00.

                       STP <St1>, <St2>, [<Xn|SP>{, #<imm>}]


                       64-bit variant

                       Applies when opc = 01.

                       STP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]


                       128-bit variant

                       Applies when opc = 10.

                       STP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]


                       Decode for all variants of this encoding

                         boolean wback     = FALSE;
                         boolean postindex = FALSE;


                       Assembler symbols

                       <Dt1>             Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Dt2>             Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                       <Qt1>             Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Qt2>             Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                       <St1>             Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <St2>             Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <imm>             For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
                                         multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.

                                         For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
                                         the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

                                         For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
                                         multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.

                                         For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
                                         the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

                                         For the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a
                                         multiple of 16 in the range -1024 to 1008, encoded in the "imm7" field as <imm>/16.

                                         For the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16
                                         in the range -1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.




C7-1356                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer t2 = UInt(Rt2);
                 AccType acctype = AccType_VEC;
                 MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
                 if opc == '11' then UnallocatedEncoding();
                 integer scale = 2 + UInt(opc);
                 integer datasize = 8 << scale;
                 bits(64) offset = LSL(SignExtend(imm7, 64), scale);


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();

                 bits(64) address;
                 bits(datasize) data1;
                 bits(datasize) data2;
                 constant integer dbytes = datasize DIV 8;
                 boolean rt_unknown = FALSE;

                 if memop == MemOp_LOAD && t == t2 then
                     Constraint c = ConstrainUnpredictable();
                    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
                    case c of
                         when Constraint_UNKNOWN    rt_unknown = TRUE;      // result is UNKNOWN
                         when Constraint_UNDEF      UnallocatedEncoding();
                         when Constraint_NOP        EndOfInstruction();

                 if n == 31 then
                     CheckSPAlignment();
                    address = SP[];
                 else
                    address = X[n];

                 if ! postindex then
                    address = address + offset;

                 case memop of
                    when MemOp_STORE
                        data1 = V[t];
                        data2 = V[t2];
                         Mem[address + 0     , dbytes, acctype] = data1;
                         Mem[address + dbytes, dbytes, acctype] = data2;

                    when MemOp_LOAD
                        data1 = Mem[address + 0      , dbytes, acctype];
                        data2 = Mem[address + dbytes, dbytes, acctype];
                        if rt_unknown then
                            data1 = bits(datasize) UNKNOWN;
                            data2 = bits(datasize) UNKNOWN;
                         V[t]  = data1;
                         V[t2] = data2;

                 if wback then
                    if postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1357
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.285       STR (immediate, SIMD&FP)

                       Store SIMD&FP register (immediate offset)


                       Post-index


                           31 30 29 28 27 26 25 24 23 22 21 20                        12 11 10 9       5 4     0
                            size 1 1 1 1 0 0 x 0 0                     imm9                0 1      Rn     Rt
                                                     opc


                       8-bit variant

                       Applies when size = 00 && opc = 00.

                       STR <Bt>, [<Xn|SP>], #<simm>


                       16-bit variant

                       Applies when size = 01 && opc = 00.

                       STR <Ht>, [<Xn|SP>], #<simm>


                       32-bit variant

                       Applies when size = 10 && opc = 00.

                       STR <St>, [<Xn|SP>], #<simm>


                       64-bit variant

                       Applies when size = 11 && opc = 00.

                       STR <Dt>, [<Xn|SP>], #<simm>


                       128-bit variant

                       Applies when size = 00 && opc = 10.

                       STR <Qt>, [<Xn|SP>], #<simm>


                       Decode for all variants of this encoding

                         boolean wback = TRUE;
                         boolean postindex = TRUE;
                         integer scale = UInt(opc<1>:size);
                         if scale > 4 then UnallocatedEncoding();
                         bits(64) offset = SignExtend(imm9, 64);


                       Pre-index


                           31 30 29 28 27 26 25 24 23 22 21 20                        12 11 10 9       5 4     0
                            size 1 1 1 1 0 0 x 0 0                     imm9                1 1      Rn     Rt
                                                     opc


                       8-bit variant

                       Applies when size = 00 && opc = 00.

                       STR <Bt>, [<Xn|SP>, #<simm>]!




C7-1358                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.          ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                 ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                16-bit variant

                Applies when size = 01 && opc = 00.

                STR <Ht>, [<Xn|SP>, #<simm>]!


                32-bit variant

                Applies when size = 10 && opc = 00.

                STR <St>, [<Xn|SP>, #<simm>]!


                64-bit variant

                Applies when size = 11 && opc = 00.

                STR <Dt>, [<Xn|SP>, #<simm>]!


                128-bit variant

                Applies when size = 00 && opc = 10.

                STR <Qt>, [<Xn|SP>, #<simm>]!


                Decode for all variants of this encoding

                 boolean wback = TRUE;
                 boolean postindex = FALSE;
                 integer scale = UInt(opc<1>:size);
                 if scale > 4 then UnallocatedEncoding();
                 bits(64) offset = SignExtend(imm9, 64);


                Unsigned offset


                  31 30 29 28 27 26 25 24 23 22 21                                10 9              5 4          0
                  size 1 1 1 1 0 1 x 0                       imm12                          Rn             Rt
                                          opc


                8-bit variant

                Applies when size = 00 && opc = 00.

                STR <Bt>, [<Xn|SP>{, #<pimm>}]


                16-bit variant

                Applies when size = 01 && opc = 00.

                STR <Ht>, [<Xn|SP>{, #<pimm>}]


                32-bit variant

                Applies when size = 10 && opc = 00.

                STR <St>, [<Xn|SP>{, #<pimm>}]


                64-bit variant

                Applies when size = 11 && opc = 00.

                STR <Dt>, [<Xn|SP>{, #<pimm>}]


                128-bit variant

                Applies when size = 00 && opc = 10.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1359
ID121714                                        Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       STR <Qt>, [<Xn|SP>{, #<pimm>}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(opc<1>:size);
                         if scale > 4 then UnallocatedEncoding();
                         bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);


                       Assembler symbols

                       <Bt>              Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Dt>              Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Ht>              Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Qt>              Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <St>              Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                       <simm>            Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

                       <pimm>            For the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting
                                         to 0 and encoded in the "imm12" field.

                                         For the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0
                                         to 8190, defaulting to 0 and encoded in the "imm12" field as <pimm>/2.

                                         For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
                                         to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.

                                         For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
                                         to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.

                                         For the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range
                                         0 to 65520, defaulting to 0 and encoded in the "imm12" field as <pimm>/16.


                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_VEC;
                         MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = 8 << scale;


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(datasize) data;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE



C7-1360                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                             ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                     ID121714

                                                            C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                         C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                        data = V[t];
                         Mem[address, datasize DIV 8, acctype] = data;

                    when MemOp_LOAD
                        data = Mem[address, datasize DIV 8, acctype];
                         V[t] = data;

                 if wback then
                    if postindex then
                        address = address + offset;
                    if n == 31 then
                         SP[] = address;
                    else
                         X[n] = address;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                              C7-1361
ID121714                                       Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.286       STR (register, SIMD&FP)

                       Store SIMD&FP register (register offset)




                           31 30 29 28 27 26 25 24 23 22 21 20             16 15    13 12 11 10 9              5 4             0
                            size 1 1 1 1 0 0 x 0 1                  Rm         option  S 1 0            Rn              Rt
                                                      opc


                       8-bit variant

                       Applies when size = 00 && opc = 00.

                       STR <Bt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       16-bit variant

                       Applies when size = 01 && opc = 00.

                       STR <Ht>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       32-bit variant

                       Applies when size = 10 && opc = 00.

                       STR <St>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       64-bit variant

                       Applies when size = 11 && opc = 00.

                       STR <Dt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       128-bit variant

                       Applies when size = 00 && opc = 10.

                       STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]


                       Decode for all variants of this encoding

                         boolean wback = FALSE;
                         boolean postindex = FALSE;
                         integer scale = UInt(opc<1>:size);
                         if scale > 4 then UnallocatedEncoding();
                         if option<1> == '0' then UnallocatedEncoding(); // sub-word index
                         ExtendType extend_type = DecodeRegExtend(option);
                         integer shift = if S == '1' then scale else 0;


                       Assembler symbols

                       <Bt>              Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Dt>              Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Ht>              Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Qt>              Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <St>              Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                       <Xn|SP>           Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.




C7-1362                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                                 ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <R>           Is the index width specifier, encoded in the "option" field. It can have the following values:

                              W           when option = x10

                              X           when option = x11

                              It is RESERVED when:

                              ·      option = 00x.

                              ·      option = 10x.

                <m>           Is the number [0-30] of the general-purpose index register or the name ZR (31), encoded in the "Rm"
                              field.

                <extend>      Is the index extend/shift specifier, defaulting to LSL and encoded in the "option" field. It can have
                              the following values:

                              UXTW        when option = 010

                              LSL         when option = 011

                              SXTW        when option = 110

                              SXTX        when option = 111

                              It is RESERVED when:

                              ·      option = 00x.

                              ·      option = 10x.

                <amount>      For the 8-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              [absent]    when S = 0

                              #0          when S = 1

                              For the 16-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #1          when S = 1

                              For the 32-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #2          when S = 1

                              For the 64-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is not
                              LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #3          when S = 1

                              For the 128-bit variant: is the index shift amount, optional and defaulting to #0 when <extend> is
                              not LSL, encoded in the "S" field. It can have the following values:

                              #0          when S = 0

                              #4          when S = 1


                Shared decode for all encodings

                 integer n = UInt(Rn);
                 integer t = UInt(Rt);
                 integer m = UInt(Rm);
                 AccType acctype = AccType_VEC;
                 MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                 integer datasize = 8 << scale;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1363
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         bits(64) offset = ExtendReg(m, extend_type, shift);
                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(datasize) data;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   data = V[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   V[t] = data;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C7-1364                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.287    STUR (SIMD&FP)

                Store SIMD&FP register (unscaled offset)




                  31 30 29 28 27 26 25 24 23 22 21 20                        12 11 10 9               5 4            0
                  size 1 1 1 1 0 0 x 0 0                      imm9               0 0          Rn              Rt
                                           opc


                8-bit variant

                Applies when size = 00 && opc = 00.

                STUR <Bt>, [<Xn|SP>{, #<simm>}]


                16-bit variant

                Applies when size = 01 && opc = 00.

                STUR <Ht>, [<Xn|SP>{, #<simm>}]


                32-bit variant

                Applies when size = 10 && opc = 00.

                STUR <St>, [<Xn|SP>{, #<simm>}]


                64-bit variant

                Applies when size = 11 && opc = 00.

                STUR <Dt>, [<Xn|SP>{, #<simm>}]


                128-bit variant

                Applies when size = 00 && opc = 10.

                STUR <Qt>, [<Xn|SP>{, #<simm>}]


                Decode for all variants of this encoding

                 boolean wback = FALSE;
                 boolean postindex = FALSE;
                 integer scale = UInt(opc<1>:size);
                 if scale > 4 then UnallocatedEncoding();
                 bits(64) offset = SignExtend(imm9, 64);


                Assembler symbols

                <Bt>          Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Dt>          Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Ht>          Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Qt>          Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <St>          Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

                <Xn|SP>       Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

                <simm>        Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
                              in the "imm9" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1365
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Shared decode for all encodings

                         integer n = UInt(Rn);
                         integer t = UInt(Rt);
                         AccType acctype = AccType_VEC;
                         MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
                         integer datasize = 8 << scale;


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(64) address;
                         bits(datasize) data;

                         if n == 31 then
                              CheckSPAlignment();
                              address = SP[];
                         else
                              address = X[n];

                         if ! postindex then
                              address = address + offset;

                         case memop of
                              when MemOp_STORE
                                   data = V[t];
                                   Mem[address, datasize DIV 8, acctype] = data;

                              when MemOp_LOAD
                                   data = Mem[address, datasize DIV 8, acctype];
                                   V[t] = data;

                         if wback then
                              if postindex then
                                   address = address + offset;
                              if n == 31 then
                                   SP[] = address;
                              else
                                   X[n] = address;




C7-1366                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.288    SUB (vector)

                Subtract (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 0 size 1                   Rm         1 0 0 0 0 1               Rn             Rd
                        U


                Scalar variant

                SUB <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size != '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean sub_op = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 0 size 1                   Rm         1 0 0 0 0 1               Rn             Rd
                        U


                Vector variant

                SUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean sub_op = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               D           when size = 11

                               It is RESERVED when:

                               ·      size = 0x.

                               ·      size = 10.

                <d>            Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>            Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>            Is the number of the second SIMD&FP source register, encoded in the "Rm" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1367
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         bits(esize) element1;
                         bits(esize) element2;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, esize];
                              element2 = Elem[operand2, e, esize];
                              if sub_op then
                                   Elem[result, e, esize] = element1 - element2;
                              else
                                   Elem[result, e, esize] = element1 + element2;

                         V[d] = result;




C7-1368                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.289    SUBHN, SUBHN2

                Subtract returning high narrow




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4             0
                  0 Q 0 0 1 1 1 0 size 1                    Rm          0 1 1 0 0 0               Rn               Rd
                        U                                                     o1


                Three registers, not all the same type variant

                SUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean round = (U == '1');


                Assembler symbols

                2               Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                the following values:

                                [absent]    when Q = 0

                                [present]   when Q = 1

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                8B          when size = 00, Q = 0

                                16B         when size = 00, Q = 1

                                4H          when size = 01, Q = 0

                                8H          when size = 01, Q = 1

                                2S          when size = 10, Q = 0

                                4S          when size = 10, Q = 1

                                It is RESERVED when size = 11, Q = x.

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Ta>            Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                                8H          when size = 00

                                4S          when size = 01

                                2D          when size = 10

                                It is RESERVED when size = 11.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1369
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(2*datasize) operand1 = V[n];
                         bits(2*datasize) operand2 = V[m];
                         bits(datasize)      result;
                         integer round_const = if round then 1 << (esize - 1) else 0;
                         bits(2*esize) element1;
                         bits(2*esize) element2;
                         bits(2*esize) sum;

                         for e = 0 to elements-1
                              element1 = Elem[operand1, e, 2*esize];
                              element2 = Elem[operand2, e, 2*esize];
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              sum = sum + round_const;
                              Elem[result, e, esize] = sum<2*esize-1:esize>;

                         Vpart[d, part] = result;




C7-1370                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.290    SUQADD

                Signed saturating accumulate of unsigned value


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0                                  Rn             Rd
                        U


                Scalar variant

                SUQADD <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0                                  Rn             Rd
                        U


                Vector variant

                SUQADD <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               B           when size = 00

                               H           when size = 01

                               S           when size = 10

                               D           when size = 11

                <d>            Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>            Is the number of the SIMD&FP source register, encoded in the "Rn" field.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1371
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;

                         bits(datasize) operand2 = V[d];
                         integer op1;
                         integer op2;
                         boolean sat;

                         for e = 0 to elements-1
                              op1 = Int(Elem[operand, e, esize], !unsigned);
                              op2 = Int(Elem[operand2, e, esize], unsigned);
                              (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
                              if sat then FPSR.QC = '1';
                         V[d] = result;




C7-1372                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.291    SXTL

                Signed extend long

                This instruction is an alias of the SSHLL, SSHLL2 instruction. This means that:

                ·      The encodings in this description are named to match the encodings of SSHLL, SSHLL2.

                ·      The description of SSHLL, SSHLL2 gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4             0
                   0 Q 0 0 1 1 1 1 0               !=0000     0 0 0 1 0 1 0 0 1                   Rn               Rd
                         U                          immh      immb


                Vector variant

                SXTL{2} <Vd>.<Ta>, <Vn>.<Tb>

                is equivalent to

                SSHLL{2}   <Vd>.<Ta>, <Vn>.<Tb>, #0

                and is the preferred disassembly when BitCount(immh) == 1.


                Assembler symbols

                2               Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                the following values:

                                [absent]     when Q = 0

                                [present]    when Q = 1

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>            Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                8H           when immh = 0001

                                4S           when immh = 001x

                                2D           when immh = 01xx

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                It is RESERVED when immh = 1xxx.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Tb>            Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                8B           when immh = 0001, Q = 0

                                16B          when immh = 0001, Q = 1

                                4H           when immh = 001x, Q = 0

                                8H           when immh = 001x, Q = 1

                                2S           when immh = 01xx, Q = 0

                                4S           when immh = 01xx, Q = 1

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                It is RESERVED when immh = 1xxx, Q = x.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1373
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                       The description of SSHLL, SSHLL2 gives the operational pseudocode for this instruction.




C7-1374                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.             ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                    ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.292    TBL

                Table vector lookup




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4              0
                  0 Q 0 0 1 1 1 0 0 0 0                     Rm          0    len  0 0 0          Rn                Rd
                                                                                 op


                Two register table variant

                Applies when len = 01.

                TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>


                Three register table variant

                Applies when len = 10.

                TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>


                Four register table variant

                Applies when len = 11.

                TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>


                Single register table variant

                Applies when len = 00.

                TBL <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV 8;
                 integer regs = UInt(len) + 1;
                 boolean is_tbl = (op == '0');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>           Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                               8B          when Q = 0

                               16B         when Q = 1

                <Vn>           For the four register table, three register table and two register table variant: is the name of the first
                               SIMD&FP table register, encoded in the "Rn" field.

                               For the single register table variant: is the name of the SIMD&FP table register, encoded in the "Rn"
                               field.

                <Vn+1>         Is the name of the second SIMD&FP table register, encoded as "Rn" plus 1 modulo 32.

                <Vn+2>         Is the name of the third SIMD&FP table register, encoded as "Rn" plus 2 modulo 32.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-1375
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vn+3>            Is the name of the fourth SIMD&FP table register, encoded as "Rn" plus 3 modulo 32.

                       <Vm>              Is the name of the SIMD&FP index register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) indices = V[m];
                         bits(128*regs) table = Zeros();
                         bits(datasize) result;
                         integer index;
                         integer i;

                         // Create table from registers
                         for i = 0 to regs - 1
                              table<128*i+127:128*i> = V[n];
                              n = (n + 1) MOD 32;

                         result = if is_tbl then Zeros() else V[d];
                         for i = 0 to elements - 1
                              index = UInt(Elem[indices, i, 8]);
                              if index < 16 * regs then
                                   Elem[result, i, 8] = Elem[table, index, 8];

                         V[d] = result;




C7-1376                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                          ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.293    TBX

                Table vector lookup extension




                  31 30 29 28 27 26 25 24 23 22 21 20              16 15 14 13 12 11 10 9                5 4              0
                  0 Q 0 0 1 1 1 0 0 0 0                     Rm          0    len  1 0 0          Rn                Rd
                                                                                 op


                Two register table variant

                Applies when len = 01.

                TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>


                Three register table variant

                Applies when len = 10.

                TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>


                Four register table variant

                Applies when len = 11.

                TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>


                Single register table variant

                Applies when len = 00.

                TBX <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV 8;
                 integer regs = UInt(len) + 1;
                 boolean is_tbl = (op == '0');


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>           Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

                               8B          when Q = 0

                               16B         when Q = 1

                <Vn>           For the four register table, three register table and two register table variant: is the name of the first
                               SIMD&FP table register, encoded in the "Rn" field.

                               For the single register table variant: is the name of the SIMD&FP table register, encoded in the "Rn"
                               field.

                <Vn+1>         Is the name of the second SIMD&FP table register, encoded as "Rn" plus 1 modulo 32.

                <Vn+2>         Is the name of the third SIMD&FP table register, encoded as "Rn" plus 2 modulo 32.




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-1377
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vn+3>            Is the name of the fourth SIMD&FP table register, encoded as "Rn" plus 3 modulo 32.

                       <Vm>              Is the name of the SIMD&FP index register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) indices = V[m];
                         bits(128*regs) table = Zeros();
                         bits(datasize) result;
                         integer index;
                         integer i;

                         // Create table from registers
                         for i = 0 to regs - 1
                              table<128*i+127:128*i> = V[n];
                              n = (n + 1) MOD 32;

                         result = if is_tbl then Zeros() else V[d];
                         for i = 0 to elements - 1
                              index = UInt(Elem[indices, i, 8]);
                              if index < 16 * regs then
                                   Elem[result, i, 8] = Elem[table, index, 8];

                         V[d] = result;




C7-1378                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                  ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                          ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.294    TRN1

                Transpose vectors (primary)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 0                 Rm         0 0 1 0 1 0               Rn              Rd
                                                                      op


                Advanced SIMD variant

                TRN1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 integer part = UInt(op);
                 integer pairs = elements DIV 2;


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer p;

                 for p = 0 to pairs-1
                     Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
                     Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1379
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.295       TRN2

                       Transpose vectors (secondary)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 0                  Rm         0 1 1 0 1 0               Rn              Rd
                                                                                 op


                       Advanced SIMD variant

                       TRN2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         integer part = UInt(op);
                         integer pairs = elements DIV 2;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer p;

                         for p = 0 to pairs-1
                              Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
                              Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];

                         V[d] = result;




C7-1380                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.296    UABA

                Unsigned absolute difference and accumulate




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         0 1 1 1 1 1               Rn              Rd
                        U                                                       ac


                Three registers of the same type variant

                UABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean accumulate = (ac == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 bits(esize) absdiff;

                 result = if accumulate then V[d] else Zeros();
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1381
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              absdiff = Abs(element1 - element2)<esize-1:0>;
                              Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
                         V[d] = result;




C7-1382                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.297    UABAL, UABAL2

                Unsigned absolute difference and accumulate long




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 1 0 1 0 0               Rn               Rd
                        U                                                   op


                Three registers, not all the same type variant

                UABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean accumulate = (op == '0');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1383
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) absdiff;

                         result = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              absdiff = Abs(element1 - element2)<2*esize-1:0>;
                              Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
                         V[d] = result;




C7-1384                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.298    UABD

                Unsigned absolute difference (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         0 1 1 1 0 1               Rn              Rd
                        U                                                       ac


                Three registers of the same type variant

                UABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean accumulate = (ac == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 bits(esize) absdiff;

                 result = if accumulate then V[d] else Zeros();
                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1385
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              absdiff = Abs(element1 - element2)<esize-1:0>;
                              Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
                         V[d] = result;




C7-1386                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.299    UABDL, UABDL2

                Unsigned absolute difference long




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 1 1 1 0 0               Rn               Rd
                        U                                                   op


                Three registers, not all the same type variant

                UABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean accumulate = (op == '0');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1387
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) absdiff;

                         result = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              absdiff = Abs(element1 - element2)<2*esize-1:0>;
                              Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
                         V[d] = result;




C7-1388                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.300    UADALP

                Unsigned add and accumulate long pairwise




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 0 1 0                                Rn              Rd
                        U                                             op


                Vector variant

                UADALP <Vd>.<Ta>, <Vn>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV (2*esize);
                 boolean acc = (op == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 00, Q = 0

                              8H          when size = 00, Q = 1

                              2S          when size = 01, Q = 0

                              4S          when size = 01, Q = 1

                              1D          when size = 10, Q = 0

                              2D          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1389
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                         bits(2*esize) sum;
                         integer op1;
                         integer op2;

                         result = if acc then V[d] else Zeros();
                         for e = 0 to elements-1
                              op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
                              op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
                              sum = (op1 + op2)<2*esize-1:0>;
                              Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;

                         V[d] = result;




C7-1390                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.301    UADDL, UADDL2

                Unsigned add long (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 0 0 0 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                UADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1391
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                         V[d] = result;




C7-1392                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.302    UADDLP

                Unsigned add long pairwise




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 0 1 0                                Rn              Rd
                        U                                             op


                Vector variant

                UADDLP <Vd>.<Ta>, <Vn>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV (2*esize);
                 boolean acc = (op == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 00, Q = 0

                              8H          when size = 00, Q = 1

                              2S          when size = 01, Q = 0

                              4S          when size = 01, Q = 1

                              1D          when size = 10, Q = 0

                              2D          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 bits(datasize) result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1393
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                         bits(2*esize) sum;
                         integer op1;
                         integer op2;

                         result = if acc then V[d] else Zeros();
                         for e = 0 to elements-1
                              op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
                              op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
                              sum = (op1 + op2)<2*esize-1:0>;
                              Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;

                         V[d] = result;




C7-1394                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.303    UADDLV

                Unsigned sum long across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                  0 Q 1 0 1 1 1 0 size 1 1 0 0 0 0 0 0 1 1 1 0                                 Rn               Rd
                        U


                Advanced SIMD variant

                UADDLV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '100' then ReservedValue();
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>           Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 00

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 10, Q = 0.

                              ·      size = 11, Q = x.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 integer sum;

                 sum = Int(Elem[operand, 0, esize], unsigned);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1395
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         for e = 1 to elements-1
                              sum = sum + Int(Elem[operand, e, esize], unsigned);

                         V[d] = sum<2*esize-1:0>;




C7-1396                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.304    UADDW, UADDW2

                Unsigned add wide




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 0 0 1 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                UADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1397
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(2*datasize) operand1 = V[n];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, 2*esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                         V[d] = result;




C7-1398                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.305    UCVTF (vector, fixed-point)

                Unsigned fixed-point convert to floating-point (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22        19 18     16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0             !=0000      immb     1 1 1 0 0 1               Rn             Rd
                        U                        immh


                Scalar variant

                UCVTF <V><d>, <V><n>, #<fbits>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '00xx' then ReservedValue();
                 integer esize = 32 << UInt(immh<3>);
                 integer datasize = esize;
                 integer elements = 1;

                 integer fracbits = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 FPRounding rounding = FPRoundingMode(FPCR);


                Vector


                  31 30 29 28 27 26 25 24 23 22        19 18     16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0             !=0000      immb     1 1 1 0 0 1               Rn             Rd
                        U                        immh


                Vector variant

                UCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh == '00xx' then ReservedValue();
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(immh<3>);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer fracbits = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 FPRounding rounding = FPRoundingMode(FPCR);


                Assembler symbols

                <V>           Is a width specifier, encoded in the "immh" field. It can have the following values:

                              S           when immh = 01xx

                              D           when immh = 1xxx



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1399
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when immh = 00xx.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         2D          when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when:

                                         ·      immh = 0001, Q = x.

                                         ·      immh = 001x, Q = x.

                                         ·      immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <fbits>           For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 00xx.

                                         For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when:

                                         ·      immh = 0001.

                                         ·      immh = 001x.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand     = V[n];
                         bits(datasize) result;
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);

                         V[d] = result;




C7-1400                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                           ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.306    UCVTF (vector, integer)

                Unsigned integer convert to floating-point (vector)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0                                 Rn             Rd
                        U


                Scalar variant

                UCVTF <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 32 << UInt(sz);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4          0
                  0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0                                 Rn             Rd
                        U


                Vector variant

                UCVTF <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if sz:Q == '10' then ReservedValue();
                 integer esize = 32 << UInt(sz);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "sz" field. It can have the following values:

                              S           when sz = 0

                              D           when sz = 1

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                              2S          when sz = 0, Q = 0



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1401
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         4S         when sz = 0, Q = 1

                                         2D         when sz = 1, Q = 1

                                         It is RESERVED when sz = 1, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         FPRounding rounding = FPRoundingMode(FPCR);
                         bits(esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, esize];
                              Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);

                         V[d] = result;




C7-1402                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.               ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                    ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.307    UCVTF (scalar, fixed-point)

                Unsigned fixed-point convert to floating-point (scalar) : Vd = unsigned_convertFromInt(Rn/(2^fbits))




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15               10 9              5 4          0
                  sf 0 0 1 1 1 1 0 0 x 0 0 0 0 1 1                          scale              Rn             Rd
                                          type      rmode opcode


                32-bit to single-precision variant

                Applies when sf = 0 && type = 00.

                UCVTF <Sd>, <Wn>, #<fbits>


                32-bit to double-precision variant

                Applies when sf = 0 && type = 01.

                UCVTF <Dd>, <Wn>, #<fbits>


                64-bit to single-precision variant

                Applies when sf = 1 && type = 00.

                UCVTF <Sd>, <Xn>, #<fbits>


                64-bit to double-precision variant

                Applies when sf = 1 && type = 01.

                UCVTF <Dd>, <Xn>, #<fbits>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer intsize = if sf == '1' then 64 else 32;
                 integer fltsize;
                 FPConvOp op;
                 FPRounding rounding;
                 boolean unsigned;

                 case type of
                     when '00' fltsize = 32;
                     when '01' fltsize = 64;
                     when '1x' UnallocatedEncoding();

                 if sf == '0' && scale<5> == '0' then UnallocatedEncoding();
                 integer fracbits = 64 - UInt(scale);

                 case opcode<2:1>:rmode of
                     when '00 11'        // FCVTZ
                         rounding = FPRounding_ZERO;
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                     when '01 00'        // [US]CVTF
                         rounding = FPRoundingMode(FPCR);
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_ItoF;
                     otherwise
                         UnallocatedEncoding();




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1403
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Xn>              Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Wn>              Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <fbits>           For the 32-bit to double-precision and 32-bit to single-precision variant: is the number of bits after
                                         the binary point in the fixed-point source, in the range 1 to 32, encoded as 64 minus "scale".

                                         For the 64-bit to double-precision and 64-bit to single-precision variant: is the number of bits after
                                         the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus "scale".


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(fltsize) fltval;
                         bits(intsize) intval;

                         case op of
                              when FPConvOp_CVT_FtoI
                                   fltval = V[n];
                                   intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
                                   X[d] = intval;
                              when FPConvOp_CVT_ItoF
                                   intval = X[n];
                                   fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
                                   V[d] = fltval;




C7-1404                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                 ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.308    UCVTF (scalar, integer)

                Unsigned integer convert to floating-point (scalar): Vd = unsigned_convertFromInt(Rn)




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18      16 15 14 13 12 11 10 9                 5 4          0
                  sf 0 0 1 1 1 1 0 0 x 1 0 0 0 1 1 0 0 0 0 0 0                                  Rn             Rd
                                           type     rmode opcode


                32-bit to single-precision variant

                Applies when sf = 0 && type = 00.

                UCVTF <Sd>, <Wn>


                32-bit to double-precision variant

                Applies when sf = 0 && type = 01.

                UCVTF <Dd>, <Wn>


                64-bit to single-precision variant

                Applies when sf = 1 && type = 00.

                UCVTF <Sd>, <Xn>


                64-bit to double-precision variant

                Applies when sf = 1 && type = 01.

                UCVTF <Dd>, <Xn>


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer intsize = if sf == '1' then 64 else 32;
                 integer fltsize;
                 FPConvOp op;
                 FPRounding rounding;
                 boolean unsigned;
                 integer part;

                 case type of
                     when '00'
                         fltsize = 32;
                     when '01'
                         fltsize = 64;
                     when '10'
                         if opcode<2:1>:rmode != '11 01' then UnallocatedEncoding();
                         fltsize = 128;
                     when '11'
                         UnallocatedEncoding();

                 case opcode<2:1>:rmode of
                     when '00 xx'         // FCVT[NPMZ][US]
                         rounding = FPDecodeRounding(rmode);
                         unsigned = (opcode<0> == '1');
                         op = FPConvOp_CVT_FtoI;
                     when '01 00'         // [US]CVTF
                         rounding = FPRoundingMode(FPCR);
                         unsigned = (opcode<0> == '1');



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1405
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                   op = FPConvOp_CVT_ItoF;
                              when '10 00'          // FCVTA[US]
                                   rounding = FPRounding_TIEAWAY;
                                   unsigned = (opcode<0> == '1');
                                   op = FPConvOp_CVT_FtoI;
                              when '11 00'          // FMOV
                                   if fltsize != intsize then UnallocatedEncoding();
                                   op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                                   part = 0;
                              when '11 01'          // FMOV D[1]
                                   if intsize != 64 || fltsize != 128 then UnallocatedEncoding();
                                   op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
                                   part = 1;
                              otherwise
                                   UnallocatedEncoding();


                       Assembler symbols

                       <Dd>              Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Sd>              Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Xn>              Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

                       <Wn>              Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();

                         bits(fltsize) fltval;
                         bits(intsize) intval;

                         case op of
                              when FPConvOp_CVT_FtoI
                                   fltval = V[n];
                                   intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
                                   X[d] = intval;
                              when FPConvOp_CVT_ItoF
                                   intval = X[n];
                                   fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
                                   V[d] = fltval;
                              when FPConvOp_MOV_FtoI
                                   intval = Vpart[n,part];
                                   X[d] = intval;
                              when FPConvOp_MOV_ItoF
                                   intval = X[n];
                                   Vpart[d,part] = intval;




C7-1406                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                           Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.309    UHADD

                Unsigned halving add




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         0 0 0 0 0 1               Rn              Rd
                        U


                Three registers of the same type variant

                UHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer sum;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     sum = element1 + element2;
                     Elem[result, e, esize] = sum<esize:1>;

                 V[d] = result;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1407
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.310       UHSUB

                       Unsigned halving subtract




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 1 0 1 1 1 0 size 1                  Rm         0 0 1 0 0 1               Rn              Rd
                                  U


                       Three registers of the same type variant

                       UHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when size = 11, Q = x.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         integer diff;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              diff = element1 - element2;
                              Elem[result, e, esize] = diff<esize:1>;

                         V[d] = result;



C7-1408                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.311    UMAX

                Unsigned maximum (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         0 1 1 0 0 1               Rn              Rd
                        U                                                       o1


                Three registers of the same type variant

                UMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer maxmin;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     maxmin = if minimum then Min(element1, element2) else Max(element1, element2);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1409
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, e, esize] = maxmin<esize-1:0>;

                         V[d] = result;




C7-1410                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.312    UMAXP

                Unsigned maximum pairwise




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         1 0 1 0 0 1               Rn              Rd
                        U                                                       o1


                Three registers of the same type variant

                UMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 integer element1;
                 integer element2;
                 integer maxmin;

                 for e = 0 to elements-1
                     element1 = Int(Elem[concat, 2*e, esize], unsigned);
                     element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
                     maxmin = if minimum then Min(element1, element2) else Max(element1, element2);



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1411
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, e, esize] = maxmin<esize-1:0>;

                         V[d] = result;




C7-1412                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.313    UMAXV

                Unsigned maximum across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                  0 Q 1 0 1 1 1 0 size 1 1 0 0 0 0 1 0 1 0 1 0                                 Rn               Rd
                        U                                        op


                Advanced SIMD variant

                UMAXV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '100' then ReservedValue();
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean min = (op == '1');


                Assembler symbols

                <V>           Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 10, Q = 0.

                              ·      size = 11, Q = x.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 integer maxmin;
                 integer element;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1413
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                         maxmin = Int(Elem[operand, 0, esize], unsigned);
                         for e = 1 to elements-1
                              element = Int(Elem[operand, e, esize], unsigned);
                              maxmin = if min then Min(maxmin, element) else Max(maxmin, element);

                         V[d] = maxmin<esize-1:0>;




C7-1414                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.314    UMIN

                Unsigned minimum (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         0 1 1 0 1 1               Rn              Rd
                        U                                                       o1


                Three registers of the same type variant

                UMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer maxmin;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     maxmin = if minimum then Min(element1, element2) else Max(element1, element2);




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1415
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, e, esize] = maxmin<esize-1:0>;

                         V[d] = result;




C7-1416                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.315    UMINP

                Unsigned minimum pairwise




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         1 0 1 0 1 1               Rn              Rd
                        U                                                       o1


                Three registers of the same type variant

                UMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean minimum = (o1 == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 bits(2*datasize) concat = operand2:operand1;
                 integer element1;
                 integer element2;
                 integer maxmin;

                 for e = 0 to elements-1
                     element1 = Int(Elem[concat, 2*e, esize], unsigned);
                     element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
                     maxmin = if minimum then Min(element1, element2) else Max(element1, element2);



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1417
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, e, esize] = maxmin<esize-1:0>;

                         V[d] = result;




C7-1418                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.316    UMINV

                Unsigned minimum across vector




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                  0 Q 1 0 1 1 1 0 size 1 1 0 0 0 1 1 0 1 0 1 0                                 Rn               Rd
                        U                                        op


                Advanced SIMD variant

                UMINV <V><d>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '100' then ReservedValue();
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean min = (op == '1');


                Assembler symbols

                <V>           Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              4S          when size = 10, Q = 1

                              It is RESERVED when:

                              ·      size = 10, Q = 0.

                              ·      size = 11, Q = x.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand = V[n];
                 integer maxmin;
                 integer element;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1419
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions




                         maxmin = Int(Elem[operand, 0, esize], unsigned);
                         for e = 1 to elements-1
                              element = Int(Elem[operand, e, esize], unsigned);
                              maxmin = if min then Min(maxmin, element) else Max(maxmin, element);

                         V[d] = maxmin<esize-1:0>;




C7-1420                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.317    UMLAL, UMLAL2 (by element)

                Unsigned multiply-add long (vector, by element)




                  31 30 29 28 27 26 25 24 23 22 21 20 19         16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 1 size L M                  Rm        0 0 1 0 H 0               Rn               Rd
                        U                                                o2


                Vector variant

                UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);      Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean sub_op = (o2 == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1421
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.

                       <Ts>              Is an element size specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <index>           Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(idxdsize)      operand2 = V[m];
                         bits(2*datasize) operand3 = V[d];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;

                         element2 = Int(Elem[operand2, index, esize], unsigned);
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              product = (element1 * element2)<2*esize-1:0>;
                              if sub_op then
                                   Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
                              else
                                   Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;

                         V[d] = result;




C7-1422                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.318    UMLAL, UMLAL2 (vector)

                Unsigned multiply-add long (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          1 0 0 0 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;
                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1423
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) operand3 = V[d];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;
                         bits(2*esize) accum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              product = (element1 * element2)<2*esize-1:0>;
                              if sub_op then
                                   accum = Elem[operand3, e, 2*esize] - product;
                              else
                                   accum = Elem[operand3, e, 2*esize] + product;
                              Elem[result, e, 2*esize] = accum;

                         V[d] = result;




C7-1424                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.319    UMLSL, UMLSL2 (by element)

                Unsigned multiply-subtract long (vector, by element)




                  31 30 29 28 27 26 25 24 23 22 21 20 19         16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 1 size L M                  Rm        0 1 1 0 H 0               Rn               Rd
                        U                                                o2


                Vector variant

                UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);      Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');
                 boolean sub_op = (o2 == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1425
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.

                       <Ts>              Is an element size specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <index>           Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(idxdsize)      operand2 = V[m];
                         bits(2*datasize) operand3 = V[d];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;

                         element2 = Int(Elem[operand2, index, esize], unsigned);
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              product = (element1 * element2)<2*esize-1:0>;
                              if sub_op then
                                   Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
                              else
                                   Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;

                         V[d] = result;




C7-1426                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.320    UMLSL, UMLSL2 (vector)

                Unsigned multiply-subtract long (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          1 0 1 0 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;
                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1427
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) operand3 = V[d];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;
                         bits(2*esize) accum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              product = (element1 * element2)<2*esize-1:0>;
                              if sub_op then
                                   accum = Elem[operand3, e, 2*esize] - product;
                              else
                                   accum = Elem[operand3, e, 2*esize] + product;
                              Elem[result, e, 2*esize] = accum;

                         V[d] = result;




C7-1428                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                               C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.321    UMOV

                Unsigned move vector element to general-purpose register

                This instruction is used by the alias MOV (to general). The alias is always the preferred disassembly.




                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                  5 4           0
                  0 Q 0 0 1 1 1 0 0 0 0                    imm5        0 0 1 1 1 1                Rn             Rd




                32-bit variant

                Applies when Q = 0.

                UMOV <Wd>, <Vn>.<Ts>[<index>]


                64-bit variant

                Applies when Q = 1.

                UMOV <Xd>, <Vn>.<Ts>[<index>]


                Decode for all variants of this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer size;
                 case Q:imm5 of
                     when '0xxxx1' size = 0;         // UMOV Wd, Vn.B
                     when '0xxx10' size = 1;         // UMOV Wd, Vn.H
                     when '0xx100' size = 2;         // UMOV Wd, Vn.S
                     when '1x1000' size = 3;         // UMOV Xd, Vn.D
                     otherwise        UnallocatedEncoding();

                 integer idxdsize = if imm5<4> == '1' then 128 else 64;
                 integer index = UInt(imm5<4:size+1>);
                 integer esize = 8 << size;
                 integer datasize = if Q == '1' then 64 else 32;


                Assembler symbols

                <Wd>            Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Xd>            Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ts>            For the 32-bit variant: is an element size specifier, encoded in the "imm5" field. It can have the
                                following values:

                                B           when imm5 = xxxx1

                                H           when imm5 = xxx10

                                S           when imm5 = xx100

                                It is RESERVED when imm5 = xx000.

                                For the 64-bit variant: is an element size specifier, encoded in the "imm5" field. It can have the
                                following values:

                                D           when imm5 = x1000




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                  C7-1429
ID121714                                            Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when:

                                         ·      imm5 = x0000.

                                         ·      imm5 = xxxx1.

                                         ·      imm5 = xxx10.

                                         ·      imm5 = xx100.

                       <index>           For the 32-bit variant: is the element index encoded in the "imm5" field. It can have the following
                                         values:

                                         imm5<4:1>  when imm5 = xxxx1

                                         imm5<4:2>  when imm5 = xxx10

                                         imm5<4:3>  when imm5 = xx100

                                         It is RESERVED when imm5 = xx000.

                                         For the 64-bit variant: is the element index encoded in "imm5<4>".


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(idxdsize) operand = V[n];

                         X[d] = ZeroExtend(Elem[operand, index, esize], datasize);




C7-1430                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.322    UMULL, UMULL2 (by element)

                Unsigned multiply long (vector, by element)




                  31 30 29 28 27 26 25 24 23 22 21 20 19         16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 1 size L M                  Rm        1 0 1 0 H 0               Rn               Rd
                        U


                Vector variant

                UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]


                Decode for this encoding

                 integer idxdsize = if H == '1' then 128 else 64;
                 integer index;
                 bit Rmhi;
                 case size of
                     when '01' index = UInt(H:L:M); Rmhi = '0';
                     when '10' index = UInt(H:L);      Rmhi = M;
                     otherwise UnallocatedEncoding();

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rmhi:Rm);

                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when:

                              ·      size = 00.

                              ·      size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1431
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when:

                                         ·      size = 00, Q = x.

                                         ·      size = 11, Q = x.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
                                         the following values:

                                         0:Rm        when size = 01

                                         M:Rm        when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                                         Restricted to V0-V15 when element size <Ts> is H.

                       <Ts>              Is an element size specifier, encoded in the "size" field. It can have the following values:

                                         H           when size = 01

                                         S           when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.

                       <index>           Is the element index encoded in the "size:L:H:M" field. It can have the following values:

                                         H:L:M       when size = 01

                                         H:L         when size = 10

                                         It is RESERVED when:

                                         ·      size = 00.

                                         ·      size = 11.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(idxdsize)      operand2 = V[m];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         bits(2*esize) product;

                         element2 = Int(Elem[operand2, index, esize], unsigned);
                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              product = (element1 * element2)<2*esize-1:0>;
                              Elem[result, e, 2*esize] = product;

                         V[d] = result;




C7-1432                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                  ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.323    UMULL, UMULL2 (vector)

                Unsigned multiply long (vector)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          1 1 0 0 0 0               Rn               Rd
                        U


                Three registers, not all the same type variant

                UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1433
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;

                         V[d] = result;




C7-1434                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.324    UQADD

                Unsigned saturating add


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 0 size 1                  Rm         0 0 0 0 1 1               Rn             Rd
                        U


                Scalar variant

                UQADD <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 0 size 1                  Rm         0 0 0 0 1 1               Rn             Rd
                        U


                Vector variant

                UQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              D           when size = 11

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1435
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;
                         boolean sat;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              sum = element1 + element2;
                              (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1436                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.325    UQRSHL

                Unsigned saturating rounding shift left (register)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 0 size 1                   Rm        0 1 0 1 1 1                Rn             Rd
                        U                                                      R S


                Scalar variant

                UQRSHL <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');
                 if S == '0' && size != '11' then ReservedValue();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 0 size 1                   Rm        0 1 0 1 1 1                Rn             Rd
                        U                                                      R S


                Vector variant

                UQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              D           when size = 11

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1437
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         integer round_const = 0;
                         integer shift;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              shift = SInt(Elem[operand2, e, esize]<7:0>);
                              if rounding then
                                   round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                              element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                              if saturating then
                                   (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                                   if sat then FPSR.QC = '1';
                              else
                                   Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1438                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.326    UQRSHRN, UQRSHRN2

                Unsigned saturating rounded shift right narrow (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0            !=0000       immb    1 0 0 1 1 1                Rn             Rd
                        U                       immh                             op


                Scalar variant

                UQRSHRN <Vb><d>, <Va><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then ReservedValue();
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');
                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0            !=0000       immb    1 0 0 1 1 1                Rn             Rd
                        U                       immh                             op


                Vector variant

                UQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');
                 boolean unsigned = (U == '1');




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1439
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B          when immh = 0001, Q = 0

                                         16B         when immh = 0001, Q = 1

                                         4H          when immh = 001x, Q = 0

                                         8H          when immh = 001x, Q = 1

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                         8H          when immh = 0001

                                         4S          when immh = 001x

                                         2D          when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.

                       <Vb>              Is the destination width specifier, encoded in the "immh" field. It can have the following values:

                                         B           when immh = 0001

                                         H           when immh = 001x

                                         S           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <Va>              Is the source width specifier, encoded in the "immh" field. It can have the following values:

                                         H           when immh = 0001

                                         S           when immh = 001x

                                         D           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
                                         bits, encoded in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001



C7-1440                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              It is RESERVED when:

                              ·      immh = 0000.

                              ·      immh = 1xxx.

                              For the vector variant: is the right shift amount, in the range 1 to the destination element width in
                              bits, encoded in the "immh:immb" field. It can have the following values:

                              (16-UInt(immh:immb))when immh = 0001

                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when immh = 1xxx.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize*2) operand = V[n];
                 bits(datasize) result;
                 integer round_const = if round then (1 << (shift - 1)) else 0;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
                     (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                    if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1441
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.327       UQSHL (immediate)

                       Unsigned saturating shift left (immediate)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 1 1 1 1 1 1 1 0            !=0000      immb     0 1 1 1 0 1           Rn     Rd
                                  U                       immh                        op


                       Scalar variant

                       UQSHL <V><d>, <V><n>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = esize;
                         integer elements = 1;

                         integer shift = UInt(immh:immb) - esize;

                         boolean src_unsigned;
                         boolean dst_unsigned;
                         case op:U of
                              when '00' UnallocatedEncoding();
                              when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                              when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                              when '11' src_unsigned = TRUE;    dst_unsigned = TRUE;


                       Vector


                           31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9        5 4    0
                            0 Q 1 0 1 1 1 1 0            !=0000      immb     0 1 1 1 0 1           Rn     Rd
                                  U                       immh                        op


                       Vector variant

                       UQSHL <Vd>.<T>, <Vn>.<T>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer shift = UInt(immh:immb) - esize;

                         boolean src_unsigned;
                         boolean dst_unsigned;
                         case op:U of
                              when '00' UnallocatedEncoding();




C7-1442                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.         ARM DDI 0487A.e
                                                           Non-Confidential - Beta                               ID121714

                                                                 C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
                    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
                    when '11' src_unsigned = TRUE;      dst_unsigned = TRUE;


                Assembler symbols

                <V>           Is a width specifier, encoded in the "immh" field. It can have the following values:

                              B           when immh = 0001

                              H           when immh = 001x

                              S           when immh = 01xx

                              D           when immh = 1xxx

                              It is RESERVED when immh = 0000.

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              8B          when immh = 0001, Q = 0

                              16B         when immh = 0001, Q = 1

                              4H          when immh = 001x, Q = 0

                              8H          when immh = 001x, Q = 1

                              2S          when immh = 01xx, Q = 0

                              4S          when immh = 01xx, Q = 1

                              2D          when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <shift>       For the scalar variant: is the left shift amount, in the range 0 to the operand width in bits minus 1,
                              encoded in the "immh:immb" field. It can have the following values:

                              (UInt(immh:immb)-8)when immh = 0001

                              (UInt(immh:immb)-16)when immh = 001x

                              (UInt(immh:immb)-32)when immh = 01xx

                              (UInt(immh:immb)-64)when immh = 1xxx

                              It is RESERVED when immh = 0000.

                              For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
                              encoded in the "immh:immb" field. It can have the following values:

                              (UInt(immh:immb)-8)when immh = 0001

                              (UInt(immh:immb)-16)when immh = 001x

                              (UInt(immh:immb)-32)when immh = 01xx

                              (UInt(immh:immb)-64)when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand  = V[n];
                 bits(datasize) result;



ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                    C7-1443
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              element = Int(Elem[operand, e, esize], src_unsigned) << shift;
                              (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
                              if sat then FPSR.QC = '1';

                         V[d] = result;




C7-1444                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.328    UQSHL (register)

                Unsigned saturating shift left (register)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 0 size 1                  Rm          0 1 0 0 1 1              Rn             Rd
                        U                                                      R S


                Scalar variant

                UQSHL <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');
                 if S == '0' && size != '11' then ReservedValue();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 1 0 0 1 1              Rn             Rd
                        U                                                      R S


                Vector variant

                UQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              B             when size = 00

                              H             when size = 01

                              S             when size = 10

                              D             when size = 11

                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1445
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         integer round_const = 0;
                         integer shift;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              shift = SInt(Elem[operand2, e, esize]<7:0>);
                              if rounding then
                                   round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                              element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                              if saturating then
                                   (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                                   if sat then FPSR.QC = '1';
                              else
                                   Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1446                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.329    UQSHRN

                Unsigned saturating shift right narrow (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0              !=0000     immb      1 0 0 1 0 1              Rn             Rd
                        U                         immh                           op


                Scalar variant

                UQSHRN <Vb><d>, <Va><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then ReservedValue();
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = esize;
                 integer elements = 1;
                 integer part = 0;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');
                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0              !=0000     immb      1 0 0 1 0 1              Rn             Rd
                        U                         immh                           op


                Vector variant

                UQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = (2 * esize) - UInt(immh:immb);
                 boolean round = (op == '1');
                 boolean unsigned = (U == '1');




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1447
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B          when immh = 0001, Q = 0

                                         16B         when immh = 0001, Q = 1

                                         4H          when immh = 001x, Q = 0

                                         8H          when immh = 001x, Q = 1

                                         2S          when immh = 01xx, Q = 0

                                         4S          when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <Ta>              Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                         8H          when immh = 0001

                                         4S          when immh = 001x

                                         2D          when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.

                       <Vb>              Is the destination width specifier, encoded in the "immh" field. It can have the following values:

                                         B           when immh = 0001

                                         H           when immh = 001x

                                         S           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <Va>              Is the source width specifier, encoded in the "immh" field. It can have the following values:

                                         H           when immh = 0001

                                         S           when immh = 001x

                                         D           when immh = 01xx

                                         It is RESERVED when:

                                         ·      immh = 0000.

                                         ·      immh = 1xxx.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
                                         bits, encoded in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001



C7-1448                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              It is RESERVED when:

                              ·      immh = 0000.

                              ·      immh = 1xxx.

                              For the vector variant: is the right shift amount, in the range 1 to the destination element width in
                              bits, encoded in the "immh:immb" field. It can have the following values:

                              (16-UInt(immh:immb))when immh = 0001

                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                              It is RESERVED when immh = 1xxx.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize*2) operand = V[n];
                 bits(datasize) result;
                 integer round_const = if round then (1 << (shift - 1)) else 0;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
                     (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                    if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1449
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.330       UQSUB

                       Unsigned saturating subtract


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 1 1 1 1 1 0 size 1                   Rm         0 0 1 0 1 1               Rn             Rd
                                  U


                       Scalar variant

                       UQSUB <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 1 0 1 1 1 0 size 1                   Rm         0 0 1 0 1 1               Rn             Rd
                                  U


                       Vector variant

                       UQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         B           when size = 00

                                         H           when size = 01

                                         S           when size = 10

                                         D           when size = 11

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.



C7-1450                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;
                 integer diff;
                 boolean sat;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     diff = element1 - element2;
                     (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
                    if sat then FPSR.QC = '1';

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1451
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.331       UQXTN, UQXTN2

                       Unsigned saturating extract narrow


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 1 1 1 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0                                   Rn               Rd
                                  U


                       Scalar variant

                       UQXTN <Vb><d>, <Va><n>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer part = 0;
                         integer elements = 1;

                         boolean unsigned = (U == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                    5 4             0
                            0 Q 1 0 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0                                   Rn               Rd
                                  U


                       Vector variant

                       UQXTN{2} <Vd>.<Tb>, <Vn>.<Ta>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if size == '11' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = 64;
                         integer part = UInt(Q);
                         integer elements = datasize DIV esize;

                         boolean unsigned = (U == '1');


                       Assembler symbols

                       2                 Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                         64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                         the following values:

                                         [absent]    when Q = 0

                                         [present]   when Q = 1

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.



C7-1452                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                            ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vb>          Is the destination width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              It is RESERVED when size = 11.

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <Va>          Is the source width specifier, encoded in the "size" field. It can have the following values:

                              H           when size = 00

                              S           when size = 01

                              D           when size = 10

                              It is RESERVED when size = 11.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(2*datasize) operand = V[n];
                 bits(datasize) result;
                 bits(2*esize) element;
                 boolean sat;

                 for e = 0 to elements-1
                     element = Elem[operand, e, 2*esize];
                     (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
                     if sat then FPSR.QC = '1';

                 Vpart[d, part] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                   C7-1453
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.332       URECPE

                       Unsigned reciprocal estimate




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                            0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 0 1 0                                Rn              Rd




                       Vector variant

                       URECPE <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz == '1' then ReservedValue();
                         integer esize = 32;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         It is RESERVED when sz = 1, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(32) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, 32];
                              Elem[result, e, 32] = UnsignedRecipEstimate(element);

                         V[d] = result;




C7-1454                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.333    URHADD

                Unsigned rounding halving add




                  31 30 29 28 27 26 25 24 23 22 21 20          16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 1 0 1 1 1 0 size 1                 Rm         0 0 0 1 0 1               Rn              Rd
                        U


                Three registers of the same type variant

                URHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');


                Assembler symbols

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;
                 integer element1;
                 integer element2;

                 for e = 0 to elements-1
                     element1 = Int(Elem[operand1, e, esize], unsigned);
                     element2 = Int(Elem[operand2, e, esize], unsigned);
                     Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1455
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.334       URSHL

                       Unsigned rounding shift left (register)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 1 1 1 1 1 1 0 size 1                  Rm          0 1 0 1 0 1               Rn             Rd
                                  U                                                       R S


                       Scalar variant

                       URSHL <V><d>, <V><n>, <V><m>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         integer esize = 8 << UInt(size);
                         integer datasize = esize;
                         integer elements = 1;
                         boolean unsigned = (U == '1');
                         boolean rounding = (R == '1');
                         boolean saturating = (S == '1');
                         if S == '0' && size != '11' then ReservedValue();


                       Vector


                           31 30 29 28 27 26 25 24 23 22 21 20             16 15 14 13 12 11 10 9                5 4          0
                            0 Q 1 0 1 1 1 0 size 1                  Rm          0 1 0 1 0 1               Rn             Rd
                                  U                                                       R S


                       Vector variant

                       URSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);
                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         boolean unsigned = (U == '1');
                         boolean rounding = (R == '1');
                         boolean saturating = (S == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "size" field. It can have the following values:

                                         D           when size = 11

                                         It is RESERVED when:

                                         ·      size = 0x.

                                         ·      size = 10.

                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.


C7-1456                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                              ID121714

                                                              C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <m>           Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              2D          when size = 11, Q = 1

                              It is RESERVED when size = 11, Q = 0.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;

                 integer round_const = 0;
                 integer shift;
                 integer element;
                 boolean sat;

                 for e = 0 to elements-1
                     shift = SInt(Elem[operand2, e, esize]<7:0>);
                     if rounding then
                         round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                     element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                     if saturating then
                         (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                         if sat then FPSR.QC = '1';
                     else
                         Elem[result, e, esize] = element<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1457
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.335       URSHR

                       Unsigned rounding shift right (immediate)


                       Scalar


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 1 1 1 1 1 1 1 0              !=0000     immb      0 0 1 0 0 1             Rn             Rd
                                  U                         immh                    o1 o0


                       Scalar variant

                       URSHR <V><d>, <V><n>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh<3> != '1' then ReservedValue();
                         integer esize = 8 << 3;
                         integer datasize = esize;
                         integer elements = 1;

                         integer shift = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         boolean round = (o1 == '1');
                         boolean accumulate = (o0 == '1');


                       Vector


                           31 30 29 28 27 26 25 24 23 22          19 18    16 15 14 13 12 11 10 9               5 4          0
                            0 Q 1 0 1 1 1 1 0              !=0000     immb      0 0 1 0 0 1             Rn             Rd
                                  U                         immh                    o1 o0


                       Vector variant

                       URSHR <Vd>.<T>, <Vn>.<T>, #<shift>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if immh == '0000' then SEE "Advanced SIMD modified immediate";
                         if immh<3>:Q == '10' then ReservedValue();
                         integer esize = 8 << HighestSetBit(immh);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;

                         integer shift = (esize * 2) - UInt(immh:immb);
                         boolean unsigned = (U == '1');
                         boolean round = (o1 == '1');
                         boolean accumulate = (o0 == '1');


                       Assembler symbols

                       <V>               Is a width specifier, encoded in the "immh" field. It can have the following values:

                                         D           when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.


C7-1458                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                <d>           Is the number of the SIMD&FP destination register, in the "Rd" field.

                <n>           Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>           Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                              8B           when immh = 0001, Q = 0

                              16B          when immh = 0001, Q = 1

                              4H           when immh = 001x, Q = 0

                              8H           when immh = 001x, Q = 1

                              2S           when immh = 01xx, Q = 0

                              4S           when immh = 01xx, Q = 1

                              2D           when immh = 1xxx, Q = 1

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                              It is RESERVED when immh = 1xxx, Q = 0.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <shift>       For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                              field. It can have the following values:

                              (128-UInt(immh:immb))when immh = 1xxx

                              It is RESERVED when immh = 0xxx.

                              For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                              in the "immh:immb" field. It can have the following values:

                              (16-UInt(immh:immb))when immh = 0001

                              (32-UInt(immh:immb))when immh = 001x

                              (64-UInt(immh:immb))when immh = 01xx

                              (128-UInt(immh:immb))when immh = 1xxx

                              See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                Operation for all encodings

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand   = V[n];
                 bits(datasize) operand2;
                 bits(datasize) result;
                 integer round_const = if round then (1 << (shift - 1)) else 0;
                 integer element;

                 operand2 = if accumulate then V[d] else Zeros();
                 for e = 0 to elements-1
                     element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                     Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                 V[d] = result;




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                      C7-1459
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.336       URSQRTE

                       Unsigned reciprocal square root estimate




                           31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4            0
                            0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 0 1 0                                Rn              Rd




                       Vector variant

                       URSQRTE <Vd>.<T>, <Vn>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);

                         if sz == '1' then ReservedValue();
                         integer esize = 32;
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

                                         2S          when sz = 0, Q = 0

                                         4S          when sz = 0, Q = 1

                                         It is RESERVED when sz = 1, Q = x.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;
                         bits(32) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, 32];
                              Elem[result, e, 32] = UnsignedRSqrtEstimate(element);

                         V[d] = result;




C7-1460                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                       ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.337    URSRA

                Unsigned rounding shift right and accumulate (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0             !=0000     immb      0 0 1 1 0 1              Rn             Rd
                        U                        immh                    o1 o0


                Scalar variant

                URSRA <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22        19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0             !=0000     immb      0 0 1 1 0 1              Rn             Rd
                        U                        immh                    o1 o0


                Vector variant

                URSRA <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "immh" field. It can have the following values:

                              D           when immh = 1xxx

                              It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1461
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1462                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.338    USHL

                Unsigned shift left (register)


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 0 size 1                   Rm         0 1 0 0 0 1               Rn             Rd
                        U                                                       R S


                Scalar variant

                USHL <V><d>, <V><n>, <V><m>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');
                 if S == '0' && size != '11' then ReservedValue();


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 0 size 1                   Rm         0 1 0 0 0 1               Rn             Rd
                        U                                                       R S


                Vector variant

                USHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);
                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 boolean unsigned = (U == '1');
                 boolean rounding = (R == '1');
                 boolean saturating = (S == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "size" field. It can have the following values:

                               D             when size = 11

                               It is RESERVED when:

                               ·       size = 0x.

                               ·       size = 10.

                <d>            Is the number of the SIMD&FP destination register, in the "Rd" field.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1463
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <m>               Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand1 = V[n];
                         bits(datasize) operand2 = V[m];
                         bits(datasize) result;

                         integer round_const = 0;
                         integer shift;
                         integer element;
                         boolean sat;

                         for e = 0 to elements-1
                              shift = SInt(Elem[operand2, e, esize]<7:0>);
                              if rounding then
                                   round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift
                              element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
                              if saturating then
                                   (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
                                   if sat then FPSR.QC = '1';
                              else
                                   Elem[result, e, esize] = element<esize-1:0>;

                         V[d] = result;




C7-1464                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.339    USHLL, USHLL2

                Unsigned shift left long (immediate)

                This instruction is used by the alias UXTL. See the Alias conditions table for details of when each alias is preferred.




                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 1 0                !=0000     immb      1 0 1 0 0 1               Rn               Rd
                         U                          immh


                Vector variant

                USHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3> == '1' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 integer shift = UInt(immh:immb) - esize;
                 boolean unsigned = (U == '1');


                Alias conditions


                                      Alias                   is preferred when

                                      UXTL                     immb == '000' && BitCount(immh) == 1



                Assembler symbols

                2               Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                the following values:

                                [absent]     when Q = 0

                                [present]    when Q = 1

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>            Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                8H           when immh = 0001

                                4S           when immh = 001x

                                2D           when immh = 01xx

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                It is RESERVED when immh = 1xxx.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1465
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Tb>              Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = x.

                       <shift>           Is the left shift amount, in the range 0 to the source element width in bits minus 1, encoded in the
                                         "immh:immb" field. It can have the following values:

                                         (UInt(immh:immb)-8)when immh = 0001

                                         (UInt(immh:immb)-16)when immh = 001x

                                         (UInt(immh:immb)-32)when immh = 01xx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                         It is RESERVED when immh = 1xxx.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = Vpart[n, part];
                         bits(datasize*2) result;
                         integer element;

                         for e = 0 to elements-1
                              element = Int(Elem[operand, e, esize], unsigned) << shift;
                              Elem[result, e, 2*esize] = element<2*esize-1:0>;

                         V[d] = result;




C7-1466                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                         ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.340    USHR

                Unsigned shift right (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0              !=0000     immb      0 0 0 0 0 1              Rn             Rd
                        U                         immh                    o1 o0


                Scalar variant

                USHR <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0              !=0000     immb      0 0 0 0 0 1              Rn             Rd
                        U                         immh                    o1 o0


                Vector variant

                USHR <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "immh" field. It can have the following values:

                               D           when immh = 1xxx

                               It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1467
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1468                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                           C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.341    USQADD

                Unsigned saturating accumulate of signed value


                Scalar


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4          0
                  0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0                                 Rn             Rd
                        U


                Scalar variant

                USQADD <V><d>, <V><n>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 integer esize = 8 << UInt(size);
                 integer datasize = esize;
                 integer elements = 1;

                 boolean unsigned = (U == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                 5 4          0
                  0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0                                 Rn             Rd
                        U


                Vector variant

                USQADD <Vd>.<T>, <Vn>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 boolean unsigned = (U == '1');


                Assembler symbols

                <V>           Is a width specifier, encoded in the "size" field. It can have the following values:

                              B           when size = 00

                              H           when size = 01

                              S           when size = 10

                              D           when size = 11

                <d>           Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

                <n>           Is the number of the SIMD&FP source register, encoded in the "Rn" field.



ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                               C7-1469
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand = V[n];
                         bits(datasize) result;

                         bits(datasize) operand2 = V[d];
                         integer op1;
                         integer op2;
                         boolean sat;

                         for e = 0 to elements-1
                              op1 = Int(Elem[operand, e, esize], !unsigned);
                              op2 = Int(Elem[operand2, e, esize], unsigned);
                              (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
                              if sat then FPSR.QC = '1';
                         V[d] = result;




C7-1470                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.342    USRA

                Unsigned shift right and accumulate (immediate)


                Scalar


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 1 1 1 1 1 1 1 0              !=0000     immb      0 0 0 1 0 1              Rn             Rd
                        U                         immh                    o1 o0


                Scalar variant

                USRA <V><d>, <V><n>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh<3> != '1' then ReservedValue();
                 integer esize = 8 << 3;
                 integer datasize = esize;
                 integer elements = 1;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Vector


                  31 30 29 28 27 26 25 24 23 22         19 18    16 15 14 13 12 11 10 9                5 4          0
                  0 Q 1 0 1 1 1 1 0              !=0000     immb      0 0 0 1 0 1              Rn             Rd
                        U                         immh                    o1 o0


                Vector variant

                USRA <Vd>.<T>, <Vn>.<T>, #<shift>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if immh == '0000' then SEE "Advanced SIMD modified immediate";
                 if immh<3>:Q == '10' then ReservedValue();
                 integer esize = 8 << HighestSetBit(immh);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;

                 integer shift = (esize * 2) - UInt(immh:immb);
                 boolean unsigned = (U == '1');
                 boolean round = (o1 == '1');
                 boolean accumulate = (o0 == '1');


                Assembler symbols

                <V>            Is a width specifier, encoded in the "immh" field. It can have the following values:

                               D           when immh = 1xxx

                               It is RESERVED when immh = 0xxx.


ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                C7-1471
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <d>               Is the number of the SIMD&FP destination register, in the "Rd" field.

                       <n>               Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                         8B           when immh = 0001, Q = 0

                                         16B          when immh = 0001, Q = 1

                                         4H           when immh = 001x, Q = 0

                                         8H           when immh = 001x, Q = 1

                                         2S           when immh = 01xx, Q = 0

                                         4S           when immh = 01xx, Q = 1

                                         2D           when immh = 1xxx, Q = 1

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                         It is RESERVED when immh = 1xxx, Q = 0.

                       <Vn>              Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                       <shift>           For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
                                         field. It can have the following values:

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         It is RESERVED when immh = 0xxx.

                                         For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
                                         in the "immh:immb" field. It can have the following values:

                                         (16-UInt(immh:immb))when immh = 0001

                                         (32-UInt(immh:immb))when immh = 001x

                                         (64-UInt(immh:immb))when immh = 01xx

                                         (128-UInt(immh:immb))when immh = 1xxx

                                         See Advanced SIMD modified immediate on page C4-213 when immh = 0000.


                       Operation for all encodings

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operand      = V[n];
                         bits(datasize) operand2;
                         bits(datasize) result;
                         integer round_const = if round then (1 << (shift - 1)) else 0;
                         integer element;

                         operand2 = if accumulate then V[d] else Zeros();
                         for e = 0 to elements-1
                              element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
                              Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;

                         V[d] = result;




C7-1472                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                          ARM DDI 0487A.e
                                                             Non-Confidential - Beta                                                   ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.343    USUBL, USUBL2

                Unsigned subtract long




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 0 1 0 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                USUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1473
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize)      operand1 = Vpart[n, part];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                         V[d] = result;




C7-1474                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                   ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                        ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.344    USUBW, USUBW2

                Unsigned subtract wide




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                5 4             0
                  0 Q 1 0 1 1 1 0 size 1                  Rm          0 0 1 1 0 0               Rn               Rd
                        U                                                   o1


                Three registers, not all the same type variant

                USUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;

                 boolean sub_op = (o1 == '1');
                 boolean unsigned = (U == '1');


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.

                <Vn>          Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>          Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1475
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                                         It is RESERVED when size = 11, Q = x.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(2*datasize) operand1 = V[n];
                         bits(datasize)      operand2 = Vpart[m, part];
                         bits(2*datasize) result;
                         integer element1;
                         integer element2;
                         integer sum;

                         for e = 0 to elements-1
                              element1 = Int(Elem[operand1, e, 2*esize], unsigned);
                              element2 = Int(Elem[operand2, e, esize], unsigned);
                              if sub_op then
                                   sum = element1 - element2;
                              else
                                   sum = element1 + element2;
                              Elem[result, e, 2*esize] = sum<2*esize-1:0>;

                         V[d] = result;




C7-1476                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                  C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                              C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.345    UXTL

                Unsigned extend long

                This instruction is an alias of the USHLL, USHLL2 instruction. This means that:

                ·      The encodings in this description are named to match the encodings of USHLL, USHLL2.

                ·      The description of USHLL, USHLL2 gives the operational pseudocode for this instruction.




                  31 30 29 28 27 26 25 24 23 22           19 18    16 15 14 13 12 11 10 9                5 4             0
                   0 Q 1 0 1 1 1 1 0               !=0000     0 0 0 1 0 1 0 0 1                   Rn               Rd
                         U                          immh      immb


                Vector variant

                UXTL{2} <Vd>.<Ta>, <Vn>.<Tb>

                is equivalent to

                USHLL{2}   <Vd>.<Ta>, <Vn>.<Tb>, #0

                and is the preferred disassembly when BitCount(immh) == 1.


                Assembler symbols

                2               Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                                64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                                the following values:

                                [absent]     when Q = 0

                                [present]    when Q = 1

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Ta>            Is an arrangement specifier, encoded in the "immh" field. It can have the following values:

                                8H           when immh = 0001

                                4S           when immh = 001x

                                2D           when immh = 01xx

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000.

                                It is RESERVED when immh = 1xxx.

                <Vn>            Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Tb>            Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:

                                8B           when immh = 0001, Q = 0

                                16B          when immh = 0001, Q = 1

                                4H           when immh = 001x, Q = 0

                                8H           when immh = 001x, Q = 1

                                2S           when immh = 01xx, Q = 0

                                4S           when immh = 01xx, Q = 1

                                See Advanced SIMD modified immediate on page C4-213 when immh = 0000, Q = x.

                                It is RESERVED when immh = 1xxx, Q = x.




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1477
ID121714                                             Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                       The description of USHLL, USHLL2 gives the operational pseudocode for this instruction.




C7-1478                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.             ARM DDI 0487A.e
                                                          Non-Confidential - Beta                                    ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.346    UZP1

                Unzip vectors (primary)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 0                  Rm         0 0 0 1 1 0               Rn              Rd
                                                                       op


                Advanced SIMD variant

                UZP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 integer part = UInt(op);


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1

                               2D          when size = 11, Q = 1

                               It is RESERVED when size = 11, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operandl = V[n];
                 bits(datasize) operandh = V[m];
                 bits(datasize) result;
                 integer e;

                 bits(datasize*2) zipped = operandh:operandl;
                 for e = 0 to elements-1
                     Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];

                 V[d] = result;




ARM DDI 0487A.e                  Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1479
ID121714                                          Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.347       UZP2

                       Unzip vectors (secondary)




                           31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9               5 4             0
                            0 Q 0 0 1 1 1 0 size 0                  Rm         0 1 0 1 1 0               Rn              Rd
                                                                                 op


                       Advanced SIMD variant

                       UZP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                       Decode for this encoding

                         integer d = UInt(Rd);
                         integer n = UInt(Rn);
                         integer m = UInt(Rm);

                         if size:Q == '110' then ReservedValue();
                         integer esize = 8 << UInt(size);
                         integer datasize = if Q == '1' then 128 else 64;
                         integer elements = datasize DIV esize;
                         integer part = UInt(op);


                       Assembler symbols

                       <Vd>              Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                       <T>               Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                         8B          when size = 00, Q = 0

                                         16B         when size = 00, Q = 1

                                         4H          when size = 01, Q = 0

                                         8H          when size = 01, Q = 1

                                         2S          when size = 10, Q = 0

                                         4S          when size = 10, Q = 1

                                         2D          when size = 11, Q = 1

                                         It is RESERVED when size = 11, Q = 0.

                       <Vn>              Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                       <Vm>              Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(datasize) operandl = V[n];
                         bits(datasize) operandh = V[m];
                         bits(datasize) result;
                         integer e;

                         bits(datasize*2) zipped = operandh:operandl;
                         for e = 0 to elements-1
                              Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];

                         V[d] = result;




C7-1480                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.                        ARM DDI 0487A.e
                                                            Non-Confidential - Beta                                                ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.348    XTN, XTN2

                Extract narrow




                  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                  5 4             0
                  0 Q 0 0 1 1 1 0 size 1 0 0 0 0 1 0 0 1 0 1 0                                  Rn               Rd




                Vector variant

                XTN{2} <Vd>.<Tb>, <Vn>.<Ta>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);

                 if size == '11' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = 64;
                 integer part = UInt(Q);
                 integer elements = datasize DIV esize;


                Assembler symbols

                2             Is the second and upper half specifier. If present it causes the operation to be performed on the upper
                              64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
                              the following values:

                              [absent]    when Q = 0

                              [present]   when Q = 1

                <Vd>          Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <Tb>          Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                              8B          when size = 00, Q = 0

                              16B         when size = 00, Q = 1

                              4H          when size = 01, Q = 0

                              8H          when size = 01, Q = 1

                              2S          when size = 10, Q = 0

                              4S          when size = 10, Q = 1

                              It is RESERVED when size = 11, Q = x.

                <Vn>          Is the name of the SIMD&FP source register, encoded in the "Rn" field.

                <Ta>          Is an arrangement specifier, encoded in the "size" field. It can have the following values:

                              8H          when size = 00

                              4S          when size = 01

                              2D          when size = 10

                              It is RESERVED when size = 11.




ARM DDI 0487A.e                 Copyright © 2013, 2014 ARM Limited. All rights reserved.                                     C7-1481
ID121714                                         Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                       Operation

                         CheckFPAdvSIMDEnabled64();
                         bits(2*datasize) operand = V[n];
                         bits(datasize) result;
                         bits(2*esize) element;

                         for e = 0 to elements-1
                              element = Elem[operand, e, 2*esize];
                              Elem[result, e, esize] = element<esize-1:0>;
                         Vpart[d, part] = result;




C7-1482                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                                C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                             C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.349    ZIP1

                Zip vectors (primary)




                  31 30 29 28 27 26 25 24 23 22 21 20            16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 0                   Rm         0 0 1 1 1 0               Rn              Rd
                                                                        op


                Advanced SIMD variant

                ZIP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 integer part = UInt(op);
                 integer pairs = elements DIV 2;


                Assembler symbols

                <Vd>            Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>             Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                                8B          when size = 00, Q = 0

                                16B         when size = 00, Q = 1

                                4H          when size = 01, Q = 0

                                8H          when size = 01, Q = 1

                                2S          when size = 10, Q = 0

                                4S          when size = 10, Q = 1

                                2D          when size = 11, Q = 1

                                It is RESERVED when size = 11, Q = 0.

                <Vn>            Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>            Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;

                 integer base = part * pairs;
                 integer p;

                 for p = 0 to pairs-1
                     Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];




ARM DDI 0487A.e                   Copyright © 2013, 2014 ARM Limited. All rights reserved.                                 C7-1483
ID121714                                           Non-Confidential - Beta

C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



                              Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];

                         V[d] = result;




C7-1484                                    Copyright © 2013, 2014 ARM Limited. All rights reserved.    ARM DDI 0487A.e
                                                          Non-Confidential - Beta                           ID121714

                                                               C7 A64 Advanced SIMD and Floating-point Instruction Descriptions
                                                            C7.3 Alphabetical list of floating-point and Advanced SIMD instructions



C7.3.350    ZIP2

                Zip vectors (secondary)




                  31 30 29 28 27 26 25 24 23 22 21 20           16 15 14 13 12 11 10 9                 5 4           0
                  0 Q 0 0 1 1 1 0 size 0                  Rm         0 1 1 1 1 0               Rn              Rd
                                                                       op


                Advanced SIMD variant

                ZIP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>


                Decode for this encoding

                 integer d = UInt(Rd);
                 integer n = UInt(Rn);
                 integer m = UInt(Rm);

                 if size:Q == '110' then ReservedValue();
                 integer esize = 8 << UInt(size);
                 integer datasize = if Q == '1' then 128 else 64;
                 integer elements = datasize DIV esize;
                 integer part = UInt(op);
                 integer pairs = elements DIV 2;


                Assembler symbols

                <Vd>           Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

                <T>            Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

                               8B          when size = 00, Q = 0

                               16B         when size = 00, Q = 1

                               4H          when size = 01, Q = 0

                               8H          when size = 01, Q = 1

                               2S          when size = 10, Q = 0

                               4S          when size = 10, Q = 1

                               2D          when size = 11, Q = 1

                               It is RESERVED when size = 11, Q = 0.

                <Vn>           Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

                <Vm>           Is the name of the second SIMD&FP source register, encoded in the "Rm" field.


                Operation

                 CheckFPAdvSIMDEnabled64();
                 bits(datasize) operand1 = V[n];
                 bits(datasize) operand2 = V[m];
                 bits(datasize) result;

                 integer base = part * pairs;
                 integer p;

                 for p = 0 to pairs-1
                     Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
                     Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];
                     V[d] = result;